!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var n;"undefined"!=typeof window?n=window:"undefined"!=typeof global?n=global:"undefined"!=typeof self&&(n=self),n.ramlClientGeneratorPlugin=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],3:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }
    
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.scheme == 'https' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

},{"./lib/request":4,"events":2,"url":25}],4:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.scheme || 'http') + '://'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    try { xhr.withCredentials = true }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            if (isArray(value)) {
                for (var j = 0; j < value.length; j++) {
                    xhr.setRequestHeader(key, value[j]);
                }
            }
            else xhr.setRequestHeader(key, value)
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            this.xhr.setRequestHeader(key, value[i]);
        }
    }
    else {
        this.xhr.setRequestHeader(key, value);
    }
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);
    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

},{"./response":5,"Base64":6,"inherits":8,"stream":18}],5:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":18,"util":27}],6:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],7:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    return http.request.call(this, params, cb);
}

},{"http":3}],8:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],10:[function(require,module,exports){
var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
   if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined')
      return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Relevant Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  switch (encoding) {
    case 'hex':
      return _hexWrite(this, string, offset, length)
    case 'utf8':
    case 'utf-8':
    case 'ucs2': // TODO: No support for ucs2 or utf16le encodings yet
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return _utf8Write(this, string, offset, length)
    case 'ascii':
      return _asciiWrite(this, string, offset, length)
    case 'binary':
      return _binaryWrite(this, string, offset, length)
    case 'base64':
      return _base64Write(this, string, offset, length)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  switch (encoding) {
    case 'hex':
      return _hexSlice(self, start, end)
    case 'utf8':
    case 'utf-8':
    case 'ucs2': // TODO: No support for ucs2 or utf16le encodings yet
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return _utf8Slice(self, start, end)
    case 'ascii':
      return _asciiSlice(self, start, end)
    case 'binary':
      return _binarySlice(self, start, end)
    case 'base64':
      return _base64Slice(self, start, end)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

// http://nodejs.org/api/buffer.html#buffer_buf_slice_start_end
Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value >= 0,
      'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":11,"ieee754":12}],11:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],12:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],13:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],16:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":14,"./encode":15}],17:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

},{"./readable.js":21,"./writable.js":23,"inherits":8,"process/browser.js":19}],18:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"./duplex.js":17,"./passthrough.js":20,"./readable.js":21,"./transform.js":22,"./writable.js":23,"events":2,"inherits":8}],19:[function(require,module,exports){
module.exports=require(9)
},{}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./transform.js":22,"inherits":8}],21:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("/Users/aanand/IdeaProjects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./index.js":18,"/Users/aanand/IdeaProjects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":9,"buffer":10,"events":2,"inherits":8,"process/browser.js":19,"string_decoder":24}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./duplex.js":17,"inherits":8}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./index.js":18,"buffer":10,"inherits":8,"process/browser.js":19}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":10}],25:[function(require,module,exports){
/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(delims),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = rest.indexOf('@');
    if (atSign !== -1) {
      var auth = rest.slice(0, atSign);

      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        if (auth.indexOf(nonAuthChars[i]) !== -1) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }

      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = decodeURIComponent(auth);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = rest.indexOf(nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = Object.keys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = out.hostname[0] === '[' &&
        out.hostname[out.hostname.length - 1] === ']';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else if (!ipv6Hostname) {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = out.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      out.hostname = newOut.join('.');
    }

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;

    // strip [ and ] from the hostname
    if (ipv6Hostname) {
      out.hostname = out.hostname.substr(1, out.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = obj.protocol || '',
      pathname = obj.pathname || '',
      hash = obj.hash || '',
      host = false,
      query = '';

  if (obj.host !== undefined) {
    host = auth + obj.host;
  } else if (obj.hostname !== undefined) {
    host = auth + (obj.hostname.indexOf(':') === -1 ?
        obj.hostname :
        '[' + obj.hostname + ']');
    if (obj.port) {
      host += ':' + obj.port;
    }
  }

  if (obj.query && typeof obj.query === 'object' &&
      Object.keys(obj.query).length) {
    query = querystring.stringify(obj.query);
  }

  var search = obj.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && source.host.indexOf('@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && source.host.indexOf('@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      out.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

}());

},{"punycode":13,"querystring":16}],26:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],27:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("/Users/aanand/IdeaProjects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":26,"/Users/aanand/IdeaProjects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":9,"inherits":8}],28:[function(require,module,exports){
(function() {
  var MarkedYAMLError, events, nodes, raml, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  events = require('./events');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  raml = require('./raml');

  util = require('./util');

  this.ComposerError = (function(_super) {
    __extends(ComposerError, _super);

    function ComposerError() {
      _ref = ComposerError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ComposerError;

  })(MarkedYAMLError);

  this.Composer = (function() {
    function Composer() {
      this.composeRamlTree = __bind(this.composeRamlTree, this);
      this.anchors = {};
      this.filesToRead = [];
    }

    Composer.prototype.check_node = function() {
      if (this.check_event(events.StreamStartEvent)) {
        this.get_event();
      }
      return !this.check_event(events.StreamEndEvent);
    };

    /*
    Get the root node of the next document.
    */


    Composer.prototype.get_node = function() {
      if (!this.check_event(events.StreamEndEvent)) {
        return this.compose_document();
      }
    };

    Composer.prototype.getYamlRoot = function() {
      var document, event;
      this.get_event();
      document = null;
      if (!this.check_event(events.StreamEndEvent)) {
        document = this.compose_document();
      }
      if (!this.check_event(events.StreamEndEvent)) {
        event = this.get_event();
        throw new exports.ComposerError('document scan', document.start_mark, 'expected a single document in the stream but found another document', event.start_mark);
      }
      this.get_event();
      return document;
    };

    Composer.prototype.composeRamlTree = function(node, settings) {
      if (settings.validate || settings.transform) {
        this.load_schemas(node);
        this.load_traits(node);
        this.load_types(node);
        this.load_security_schemes(node);
      }
      if (settings.validate) {
        this.validate_document(node);
      }
      if (settings.transform) {
        this.apply_types(node);
        this.apply_traits(node);
        this.apply_schemas(node);
        this.apply_protocols(node);
        this.join_resources(node);
      }
      return node;
    };

    Composer.prototype.compose_document = function() {
      var node;
      this.get_event();
      node = this.compose_node();
      this.get_event();
      this.anchors = {};
      return node;
    };

    Composer.prototype.getPendingFilesList = function() {
      return this.filesToRead;
    };

    Composer.prototype.compose_node = function(parent, index) {
      var anchor, event, node;
      if (this.check_event(events.AliasEvent)) {
        event = this.get_event();
        anchor = event.anchor;
        if (!(anchor in this.anchors)) {
          throw new exports.ComposerError(null, null, "found undefined alias " + anchor, event.start_mark);
        }
        return this.anchors[anchor].clone();
      }
      event = this.peek_event();
      anchor = event.anchor;
      if (anchor !== null && anchor in this.anchors) {
        throw new exports.ComposerError("found duplicate anchor " + anchor + "; first occurence", this.anchors[anchor].start_mark, 'second occurrence', event.start_mark);
      }
      this.descend_resolver(parent, index);
      if (this.check_event(events.ScalarEvent)) {
        node = this.compose_scalar_node(anchor, parent, index);
      } else if (this.check_event(events.SequenceStartEvent)) {
        node = this.compose_sequence_node(anchor);
      } else if (this.check_event(events.MappingStartEvent)) {
        node = this.compose_mapping_node(anchor);
      }
      this.ascend_resolver();
      return node;
    };

    Composer.prototype.compose_fixed_scalar_node = function(anchor, value) {
      var event, node;
      event = this.get_event();
      node = new nodes.ScalarNode('tag:yaml.org,2002:str', value, event.start_mark, event.end_mark, event.style);
      if (anchor !== null) {
        this.anchors[anchor] = node;
      }
      return node;
    };

    Composer.prototype.compose_scalar_node = function(anchor, parent, key) {
      var event, extension, fileType, node, tag;
      event = this.get_event();
      tag = event.tag;
      node = {};
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.ScalarNode, event.value, event.implicit);
      }
      if (event.tag === '!include') {
        if (event.value.match(/^\s*$/)) {
          throw new exports.ComposerError('while composing scalar out of !include', null, "file name/URL cannot be null", event.start_mark);
        }
        extension = event.value.split('.').pop();
        if (extension === 'yaml' || extension === 'yml' || extension === 'raml') {
          fileType = 'fragment';
        } else {
          fileType = 'scalar';
        }
        this.filesToRead.push({
          targetUri: event.value,
          type: fileType,
          parentNode: parent,
          parentKey: key,
          event: event,
          includingContext: this.src,
          targetFileUri: event.value
        });
        node = void 0;
      } else {
        node = new nodes.ScalarNode(tag, event.value, event.start_mark, event.end_mark, event.style);
      }
      if (anchor && node) {
        this.anchors[anchor] = node;
      }
      return node;
    };

    Composer.prototype.compose_sequence_node = function(anchor) {
      var end_event, index, node, start_event, tag, value;
      start_event = this.get_event();
      tag = start_event.tag;
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.SequenceNode, null, start_event.implicit);
      }
      node = new nodes.SequenceNode(tag, [], start_event.start_mark, null, start_event.flow_style);
      index = 0;
      if (anchor) {
        this.anchors[anchor] = node;
      }
      while (!this.check_event(events.SequenceEndEvent)) {
        if (value = this.compose_node(node, index)) {
          node.value[index] = value;
        }
        index++;
      }
      end_event = this.get_event();
      node.end_mark = end_event.end_mark;
      return node;
    };

    Composer.prototype.compose_mapping_node = function(anchor) {
      var end_event, item_key, item_value, node, start_event, tag;
      start_event = this.get_event();
      tag = start_event.tag;
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.MappingNode, null, start_event.implicit);
      }
      node = new nodes.MappingNode(tag, [], start_event.start_mark, null, start_event.flow_style);
      if (anchor !== null) {
        this.anchors[anchor] = node;
      }
      while (!this.check_event(events.MappingEndEvent)) {
        item_key = this.compose_node(node);
        if (!util.isScalar(item_key)) {
          throw new exports.ComposerError('while composing mapping key', null, "only scalar map keys are allowed in RAML", item_key.start_mark);
        }
        if (item_value = this.compose_node(node, item_key)) {
          node.value.push([item_key, item_value]);
        }
      }
      end_event = this.get_event();
      node.end_mark = end_event.end_mark;
      return node;
    };

    return Composer;

  })();

}).call(this);

},{"./errors":30,"./events":31,"./nodes":34,"./raml":37,"./util":47}],29:[function(require,module,exports){
(function (Buffer){
(function() {
  var MarkedYAMLError, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  this.ConstructorError = (function(_super) {
    __extends(ConstructorError, _super);

    function ConstructorError() {
      _ref = ConstructorError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ConstructorError;

  })(MarkedYAMLError);

  this.BaseConstructor = (function() {
    BaseConstructor.prototype.yaml_constructors = {};

    BaseConstructor.prototype.yaml_multi_constructors = {};

    BaseConstructor.add_constructor = function(tag, constructor) {
      if (!this.prototype.hasOwnProperty('yaml_constructors')) {
        this.prototype.yaml_constructors = util.extend({}, this.prototype.yaml_constructors);
      }
      return this.prototype.yaml_constructors[tag] = constructor;
    };

    BaseConstructor.add_multi_constructor = function(tag_prefix, multi_constructor) {
      if (!this.prototype.hasOwnProperty('yaml_multi_constructors')) {
        this.prototype.yaml_multi_constructors = util.extend({}, this.prototype.yaml_multi_constructors);
      }
      return this.prototype.yaml_multi_constructors[tag_prefix] = multi_constructor;
    };

    function BaseConstructor() {
      this.constructed_objects = {};
      this.constructing_nodes = [];
      this.deferred_constructors = [];
    }

    BaseConstructor.prototype.construct_document = function(node) {
      var data;
      this.applyAstTransformations(node);
      data = this.construct_object(node);
      while (!util.is_empty(this.deferred_constructors)) {
        this.deferred_constructors.pop()();
      }
      this.applyTransformations(data);
      return data;
    };

    BaseConstructor.prototype.defer = function(f) {
      return this.deferred_constructors.push(f);
    };

    BaseConstructor.prototype.construct_object = function(node) {
      var constructor, object, tag_prefix, tag_suffix, _ref1;
      if (node.unique_id in this.constructed_objects) {
        return this.constructed_objects[node.unique_id];
      }
      if (_ref1 = node.unique_id, __indexOf.call(this.constructing_nodes, _ref1) >= 0) {
        throw new exports.ConstructorError(null, null, 'found unconstructable recursive node', node.start_mark);
      }
      this.constructing_nodes.push(node.unique_id);
      constructor = null;
      tag_suffix = null;
      if (node.tag in this.yaml_constructors) {
        constructor = this.yaml_constructors[node.tag];
      } else {
        for (tag_prefix in this.yaml_multi_constructors) {
          if (node.tag.indexOf(tag_prefix === 0)) {
            tag_suffix = node.tag.slice(tag_prefix.length);
            constructor = this.yaml_multi_constructors[tag_prefix];
            break;
          }
        }
        if (constructor == null) {
          if (null in this.yaml_multi_constructors) {
            tag_suffix = node.tag;
            constructor = this.yaml_multi_constructors[null];
          } else if (null in this.yaml_constructors) {
            constructor = this.yaml_constructors[null];
          } else if (node instanceof nodes.ScalarNode) {
            constructor = this.construct_scalar;
          } else if (node instanceof nodes.SequenceNode) {
            constructor = this.construct_sequence;
          } else if (node instanceof nodes.MappingNode) {
            constructor = this.construct_mapping;
          }
        }
      }
      object = constructor.call(this, tag_suffix != null ? tag_suffix : node, node);
      this.constructed_objects[node.unique_id] = object;
      this.constructing_nodes.pop();
      return object;
    };

    BaseConstructor.prototype.construct_scalar = function(node) {
      if (!(node instanceof nodes.ScalarNode)) {
        throw new exports.ConstructorError(null, null, "expected a scalar node but found " + node.id, node.start_mark);
      }
      return node.value;
    };

    BaseConstructor.prototype.construct_sequence = function(node) {
      var child, _i, _len, _ref1, _results;
      if (!(node instanceof nodes.SequenceNode)) {
        throw new exports.ConstructorError(null, null, "expected an array node but found " + node.id, node.start_mark);
      }
      _ref1 = node.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        _results.push(this.construct_object(child));
      }
      return _results;
    };

    BaseConstructor.prototype.construct_mapping = function(node) {
      var key, key_item, key_item_value, key_node, mapping, value, value_node, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
      if (!(node instanceof nodes.MappingNode)) {
        throw new exports.ConstructorError(null, null, "expected a map node but found " + node.id, node.start_mark);
      }
      mapping = {};
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], key_node = _ref2[0], value_node = _ref2[1];
        key = this.construct_object(key_node);
        value = this.construct_object(value_node);
        if (typeof key === 'object' && key_node.tag === 'tag:yaml.org,2002:seq') {
          _ref3 = key_node.value;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            key_item = _ref3[_j];
            key_item_value = this.construct_object(key_item);
            mapping[key_item_value] = value;
          }
        } else if (typeof key === 'object') {
          throw new exports.ConstructorError('while constructing a map', node.start_mark, 'found unhashable key', key_node.start_mark);
        } else {
          mapping[key] = value;
        }
      }
      return mapping;
    };

    BaseConstructor.prototype.construct_pairs = function(node) {
      var key, key_node, pairs, value, value_node, _i, _len, _ref1, _ref2;
      if (!(node instanceof nodes.MappingNode)) {
        throw new exports.ConstructorError(null, null, "expected a map node but found " + node.id, node.start_mark);
      }
      pairs = [];
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], key_node = _ref2[0], value_node = _ref2[1];
        key = this.construct_object(key_node);
        value = this.construct_object(value_node);
        pairs.push([key, value]);
      }
      return pairs;
    };

    return BaseConstructor;

  })();

  this.Constructor = (function(_super) {
    var BOOL_VALUES, TIMESTAMP_PARTS, TIMESTAMP_REGEX;

    __extends(Constructor, _super);

    function Constructor() {
      _ref1 = Constructor.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    BOOL_VALUES = {
      "true": true,
      "false": false
    };

    TIMESTAMP_REGEX = /^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[\x20\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\.([0-9]*))?(?:[\x20\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$/;

    TIMESTAMP_PARTS = {
      year: 1,
      month: 2,
      day: 3,
      hour: 4,
      minute: 5,
      second: 6,
      fraction: 7,
      tz: 8,
      tz_sign: 9,
      tz_hour: 10,
      tz_minute: 11
    };

    Constructor.prototype.yaml_constructors = {};

    Constructor.prototype.yaml_multi_constructors = {};

    Constructor.prototype.construct_scalar = function(node) {
      var key_node, value_node, _i, _len, _ref2, _ref3;
      if (node instanceof nodes.MappingNode) {
        _ref2 = node.value;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          _ref3 = _ref2[_i], key_node = _ref3[0], value_node = _ref3[1];
          if (key_node.tag === 'tag:yaml.org,2002:value') {
            return this.construct_scalar(value_node);
          }
        }
      }
      return Constructor.__super__.construct_scalar.call(this, node);
    };

    Constructor.prototype.flatten_mapping = function(node) {
      var index, key_node, merge, submerge, subnode, value, value_node, _i, _j, _len, _len1, _ref2, _ref3;
      merge = [];
      index = 0;
      while (index < node.value.length) {
        _ref2 = node.value[index], key_node = _ref2[0], value_node = _ref2[1];
        if (key_node.tag === 'tag:yaml.org,2002:merge') {
          node.value.splice(index, 1);
          if (value_node instanceof nodes.MappingNode) {
            this.flatten_mapping(value_node);
            merge = merge.concat(value_node.value);
          } else if (value_node instanceof nodes.SequenceNode) {
            submerge = [];
            _ref3 = value_node.value;
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              subnode = _ref3[_i];
              if (!(subnode instanceof nodes.MappingNode)) {
                throw new exports.ConstructorError('while constructing a map', node.start_mark, "expected a map for merging, but found " + subnode.id, subnode.start_mark);
              }
              this.flatten_mapping(subnode);
              submerge.push(subnode.value);
            }
            submerge.reverse();
            for (_j = 0, _len1 = submerge.length; _j < _len1; _j++) {
              value = submerge[_j];
              merge = merge.concat(value);
            }
          } else {
            throw new exports.ConstructorError('while constructing a map', node.start_mark, "expected a map or an array of maps for            merging but found " + value_node.id, value_node.start_mark);
          }
        } else if (key_node.tag === 'tag:yaml.org,2002:value') {
          key_node.tag = 'tag:yaml.org,2002:str';
          index++;
        } else {
          index++;
        }
      }
      if (merge.length) {
        return node.value = merge.concat(node.value);
      }
    };

    Constructor.prototype.construct_mapping = function(node) {
      if (node instanceof nodes.MappingNode) {
        this.flatten_mapping(node);
      }
      return Constructor.__super__.construct_mapping.call(this, node);
    };

    Constructor.prototype.construct_yaml_null = function(node) {
      this.construct_scalar(node);
      return null;
    };

    Constructor.prototype.construct_yaml_bool = function(node) {
      var value;
      value = this.construct_scalar(node);
      return BOOL_VALUES[value.toLowerCase()];
    };

    Constructor.prototype.construct_yaml_int = function(node) {
      var base, digit, digits, part, sign, value, _i, _len, _ref2;
      value = this.construct_scalar(node);
      value = value.replace(/_/g, '');
      sign = value[0] === '-' ? -1 : 1;
      if (_ref2 = value[0], __indexOf.call('+-', _ref2) >= 0) {
        value = value.slice(1);
      }
      if (value === '0') {
        return 0;
      } else if (value.indexOf('0b') === 0) {
        return sign * parseInt(value.slice(2), 2);
      } else if (value.indexOf('0x') === 0) {
        return sign * parseInt(value.slice(2), 16);
      } else if (value.indexOf('0o') === 0) {
        return sign * parseInt(value.slice(2), 8);
      } else if (value[0] === '0') {
        return sign * parseInt(value, 8);
      } else if (__indexOf.call(value, ':') >= 0) {
        digits = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = value.split(/:/g);
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            part = _ref3[_i];
            _results.push(parseInt(part));
          }
          return _results;
        })();
        digits.reverse();
        base = 1;
        value = 0;
        for (_i = 0, _len = digits.length; _i < _len; _i++) {
          digit = digits[_i];
          value += digit * base;
          base *= 60;
        }
        return sign * value;
      } else {
        return sign * parseInt(value);
      }
    };

    Constructor.prototype.construct_yaml_float = function(node) {
      var base, digit, digits, part, sign, value, _i, _len, _ref2;
      value = this.construct_scalar(node);
      value = value.replace(/_/g, '').toLowerCase();
      sign = value[0] === '-' ? -1 : 1;
      if (_ref2 = value[0], __indexOf.call('+-', _ref2) >= 0) {
        value = value.slice(1);
      }
      if (value === '.inf') {
        return sign * Infinity;
      } else if (value === '.nan') {
        return NaN;
      } else if (__indexOf.call(value, ':') >= 0) {
        digits = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = value.split(/:/g);
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            part = _ref3[_i];
            _results.push(parseFloat(part));
          }
          return _results;
        })();
        digits.reverse();
        base = 1;
        value = 0.0;
        for (_i = 0, _len = digits.length; _i < _len; _i++) {
          digit = digits[_i];
          value += digit * base;
          base *= 60;
        }
        return sign * value;
      } else {
        return sign * parseFloat(value);
      }
    };

    Constructor.prototype.construct_yaml_binary = function(node) {
      var error, value;
      value = this.construct_scalar(node);
      try {
        if (typeof window !== "undefined" && window !== null) {
          return atob(value);
        }
        return new Buffer(value, 'base64').toString('ascii');
      } catch (_error) {
        error = _error;
        throw new exports.ConstructorError(null, null, "failed to decode base64 data: " + error, node.start_mark);
      }
    };

    Constructor.prototype.construct_yaml_timestamp = function(node) {
      var date, day, fraction, hour, index, key, match, millisecond, minute, month, second, tz_hour, tz_minute, tz_sign, value, values, year;
      value = this.construct_scalar(node);
      match = node.value.match(TIMESTAMP_REGEX);
      values = {};
      for (key in TIMESTAMP_PARTS) {
        index = TIMESTAMP_PARTS[key];
        values[key] = match[index];
      }
      year = parseInt(values.year);
      month = parseInt(values.month) - 1;
      day = parseInt(values.day);
      if (!values.hour) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = parseInt(values.hour);
      minute = parseInt(values.minute);
      second = parseInt(values.second);
      millisecond = 0;
      if (values.fraction) {
        fraction = values.fraction.slice(0, 6);
        while (fraction.length < 6) {
          fraction += '0';
        }
        fraction = parseInt(fraction);
        millisecond = Math.round(fraction / 1000);
      }
      if (values.tz_sign) {
        tz_sign = values.tz_sign === '-' ? 1 : -1;
        if (tz_hour = parseInt(values.tz_hour)) {
          hour += tz_sign * tz_hour;
        }
        if (tz_minute = parseInt(values.tz_minute)) {
          minute += tz_sign * tz_minute;
        }
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      return date;
    };

    Constructor.prototype.construct_yaml_pair_list = function(type, node) {
      var list,
        _this = this;
      list = [];
      if (!(node instanceof nodes.SequenceNode)) {
        throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected an array but found " + node.id, node.start_mark);
      }
      this.defer(function() {
        var key, key_node, subnode, value, value_node, _i, _len, _ref2, _ref3, _results;
        _ref2 = node.value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          subnode = _ref2[_i];
          if (!(subnode instanceof nodes.MappingNode)) {
            throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected a map of length 1 but found " + subnode.id, subnode.start_mark);
          }
          if (subnode.value.length !== 1) {
            throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected a map of length 1 but found " + subnode.id, subnode.start_mark);
          }
          _ref3 = subnode.value[0], key_node = _ref3[0], value_node = _ref3[1];
          key = _this.construct_object(key_node);
          value = _this.construct_object(value_node);
          _results.push(list.push([key, value]));
        }
        return _results;
      });
      return list;
    };

    Constructor.prototype.construct_yaml_omap = function(node) {
      return this.construct_yaml_pair_list('an ordered map', node);
    };

    Constructor.prototype.construct_yaml_pairs = function(node) {
      return this.construct_yaml_pair_list('pairs', node);
    };

    Constructor.prototype.construct_yaml_set = function(node) {
      var data,
        _this = this;
      data = [];
      this.defer(function() {
        var item, _results;
        _results = [];
        for (item in _this.construct_mapping(node)) {
          _results.push(data.push(item));
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_str = function(node) {
      return this.construct_scalar(node);
    };

    Constructor.prototype.construct_yaml_seq = function(node) {
      var data,
        _this = this;
      data = [];
      this.defer(function() {
        var item, _i, _len, _ref2, _results;
        _ref2 = _this.construct_sequence(node);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          item = _ref2[_i];
          _results.push(data.push(item));
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_map = function(node) {
      var data,
        _this = this;
      data = {};
      this.defer(function() {
        var key, value, _ref2, _results;
        _ref2 = _this.construct_mapping(node);
        _results = [];
        for (key in _ref2) {
          value = _ref2[key];
          _results.push(data[key] = value);
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_object = function(node, klass) {
      var data,
        _this = this;
      data = new klass;
      this.defer(function() {
        var key, value, _ref2, _results;
        _ref2 = _this.construct_mapping(node, true);
        _results = [];
        for (key in _ref2) {
          value = _ref2[key];
          _results.push(data[key] = value);
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_undefined = function(node) {
      throw new exports.ConstructorError(null, null, "could not determine a constructor for the tag " + node.tag, node.start_mark);
    };

    return Constructor;

  })(this.BaseConstructor);

  this.Constructor.add_constructor('tag:yaml.org,2002:null', this.Constructor.prototype.construct_yaml_null);

  this.Constructor.add_constructor('tag:yaml.org,2002:bool', this.Constructor.prototype.construct_yaml_bool);

  this.Constructor.add_constructor('tag:yaml.org,2002:int', this.Constructor.prototype.construct_yaml_int);

  this.Constructor.add_constructor('tag:yaml.org,2002:float', this.Constructor.prototype.construct_yaml_float);

  this.Constructor.add_constructor('tag:yaml.org,2002:binary', this.Constructor.prototype.construct_yaml_binary);

  this.Constructor.add_constructor('tag:yaml.org,2002:timestamp', this.Constructor.prototype.construct_yaml_timestamp);

  this.Constructor.add_constructor('tag:yaml.org,2002:omap', this.Constructor.prototype.construct_yaml_omap);

  this.Constructor.add_constructor('tag:yaml.org,2002:pairs', this.Constructor.prototype.construct_yaml_pairs);

  this.Constructor.add_constructor('tag:yaml.org,2002:set', this.Constructor.prototype.construct_yaml_set);

  this.Constructor.add_constructor('tag:yaml.org,2002:str', this.Constructor.prototype.construct_yaml_str);

  this.Constructor.add_constructor('tag:yaml.org,2002:seq', this.Constructor.prototype.construct_yaml_seq);

  this.Constructor.add_constructor('tag:yaml.org,2002:map', this.Constructor.prototype.construct_yaml_map);

  this.Constructor.add_constructor(null, this.Constructor.prototype.construct_undefined);

  module.exports.Constructor = this.Constructor;

  module.exports.ConstructorError = this.ConstructorError;

}).call(this);

}).call(this,require("buffer").Buffer)
},{"./errors":30,"./nodes":34,"./util":47,"buffer":10}],30:[function(require,module,exports){
(function() {
  var _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Mark = (function() {
    function Mark(name, line, column, buffer, pointer) {
      this.name = name;
      this.line = line;
      this.column = column;
      this.buffer = buffer;
      this.pointer = pointer;
    }

    Mark.prototype.get_snippet = function(indent, max_length) {
      var break_chars, end, head, start, tail, _ref, _ref1;
      if (indent == null) {
        indent = 4;
      }
      if (max_length == null) {
        max_length = 75;
      }
      if (this.buffer == null) {
        return null;
      }
      break_chars = '\x00\r\n\x85\u2028\u2029';
      head = '';
      start = this.pointer;
      while (start > 0 && (_ref = this.buffer[start - 1], __indexOf.call(break_chars, _ref) < 0)) {
        start--;
        if (this.pointer - start > max_length / 2 - 1) {
          head = ' ... ';
          start += 5;
          break;
        }
      }
      tail = '';
      end = this.pointer;
      while (end < this.buffer.length && (_ref1 = this.buffer[end], __indexOf.call(break_chars, _ref1) < 0)) {
        end++;
        if (end - this.pointer > max_length / 2 - 1) {
          tail = ' ... ';
          end -= 5;
          break;
        }
      }
      return "" + ((new Array(indent)).join(' ')) + head + this.buffer.slice(start, end) + tail + "\n" + ((new Array(indent + this.pointer - start + head.length)).join(' ')) + "^";
    };

    Mark.prototype.toString = function() {
      var snippet, where;
      snippet = this.get_snippet();
      where = "  in \"" + this.name + "\", line " + (this.line + 1) + ", column " + (this.column + 1);
      if (snippet) {
        return where;
      } else {
        return "" + where + ":\n" + snippet;
      }
    };

    return Mark;

  })();

  this.YAMLError = (function(_super) {
    __extends(YAMLError, _super);

    function YAMLError() {
      YAMLError.__super__.constructor.call(this);
    }

    return YAMLError;

  })(Error);

  this.MarkedYAMLError = (function(_super) {
    __extends(MarkedYAMLError, _super);

    function MarkedYAMLError(context, context_mark, message, problem_mark, note) {
      this.context = context;
      this.context_mark = context_mark;
      this.message = message;
      this.problem_mark = problem_mark;
      this.note = note;
      MarkedYAMLError.__super__.constructor.call(this);
      if (!this.message) {
        this.message = this.context;
      }
      if (!this.problem_mark) {
        this.problem_mark = this.context_mark;
      }
    }

    MarkedYAMLError.prototype.toString = function() {
      var lines;
      lines = [];
      if (this.context != null) {
        lines.push(this.context);
      }
      if ((this.context_mark != null) && ((this.message == null) || (this.problem_mark == null) || this.context_mark.name !== this.problem_mark.name || this.context_mark.line !== this.problem_mark.line || this.context_mark.column !== this.problem_mark.column)) {
        lines.push(this.context_mark.toString());
      }
      if (this.message != null) {
        lines.push(this.message);
      }
      if (this.problem_mark != null) {
        lines.push(this.problem_mark.toString());
      }
      if (this.note != null) {
        lines.push(this.note);
      }
      return lines.join('\n');
    };

    return MarkedYAMLError;

  })(this.YAMLError);

  /*
  The Validator throws these.
  */


  this.ValidationError = (function(_super) {
    __extends(ValidationError, _super);

    function ValidationError() {
      _ref = ValidationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ValidationError;

  })(this.MarkedYAMLError);

}).call(this);

},{}],31:[function(require,module,exports){
(function() {
  var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Event = (function() {
    function Event(start_mark, end_mark) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return Event;

  })();

  this.NodeEvent = (function(_super) {
    __extends(NodeEvent, _super);

    function NodeEvent(anchor, start_mark, end_mark) {
      this.anchor = anchor;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return NodeEvent;

  })(this.Event);

  this.CollectionStartEvent = (function(_super) {
    __extends(CollectionStartEvent, _super);

    function CollectionStartEvent(anchor, tag, implicit, start_mark, end_mark) {
      this.anchor = anchor;
      this.tag = tag;
      this.implicit = implicit;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return CollectionStartEvent;

  })(this.NodeEvent);

  this.CollectionEndEvent = (function(_super) {
    __extends(CollectionEndEvent, _super);

    function CollectionEndEvent() {
      _ref = CollectionEndEvent.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return CollectionEndEvent;

  })(this.Event);

  this.StreamStartEvent = (function(_super) {
    __extends(StreamStartEvent, _super);

    function StreamStartEvent(start_mark, end_mark, explicit, version, tags) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
      this.version = version;
      this.tags = tags;
    }

    return StreamStartEvent;

  })(this.Event);

  this.StreamEndEvent = (function(_super) {
    __extends(StreamEndEvent, _super);

    function StreamEndEvent() {
      _ref1 = StreamEndEvent.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return StreamEndEvent;

  })(this.Event);

  this.DocumentStartEvent = (function(_super) {
    __extends(DocumentStartEvent, _super);

    function DocumentStartEvent(start_mark, end_mark, explicit, version, tags) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
      this.version = version;
      this.tags = tags;
    }

    return DocumentStartEvent;

  })(this.Event);

  this.DocumentEndEvent = (function(_super) {
    __extends(DocumentEndEvent, _super);

    function DocumentEndEvent(start_mark, end_mark, explicit) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
    }

    return DocumentEndEvent;

  })(this.Event);

  this.AliasEvent = (function(_super) {
    __extends(AliasEvent, _super);

    function AliasEvent() {
      _ref2 = AliasEvent.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return AliasEvent;

  })(this.NodeEvent);

  this.ScalarEvent = (function(_super) {
    __extends(ScalarEvent, _super);

    function ScalarEvent(anchor, tag, implicit, value, start_mark, end_mark, style) {
      this.anchor = anchor;
      this.tag = tag;
      this.implicit = implicit;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
    }

    return ScalarEvent;

  })(this.NodeEvent);

  this.SequenceStartEvent = (function(_super) {
    __extends(SequenceStartEvent, _super);

    function SequenceStartEvent() {
      _ref3 = SequenceStartEvent.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    return SequenceStartEvent;

  })(this.CollectionStartEvent);

  this.SequenceEndEvent = (function(_super) {
    __extends(SequenceEndEvent, _super);

    function SequenceEndEvent() {
      _ref4 = SequenceEndEvent.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    return SequenceEndEvent;

  })(this.CollectionEndEvent);

  this.MappingStartEvent = (function(_super) {
    __extends(MappingStartEvent, _super);

    function MappingStartEvent() {
      _ref5 = MappingStartEvent.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    return MappingStartEvent;

  })(this.CollectionStartEvent);

  this.MappingEndEvent = (function(_super) {
    __extends(MappingEndEvent, _super);

    function MappingEndEvent() {
      _ref6 = MappingEndEvent.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    return MappingEndEvent;

  })(this.CollectionEndEvent);

}).call(this);

},{}],32:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Traits throws these.
  */


  this.JoinError = (function(_super) {
    __extends(JoinError, _super);

    function JoinError() {
      _ref = JoinError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return JoinError;

  })(MarkedYAMLError);

  /*
  The Joiner class groups resources under resource property and groups methods under operations property
  */


  this.Joiner = (function() {
    function Joiner() {}

    Joiner.prototype.join_resources = function(node, call) {
      var resources, resourcesArray, resourcesName, resourcesValue,
        _this = this;
      if (call == null) {
        call = 0;
      }
      resources = [];
      if (node != null ? node.value : void 0) {
        resources = node.value.filter(function(childNode) {
          var _ref1;
          return (_ref1 = childNode[0]) != null ? _ref1.value.match(/^\//) : void 0;
        });
      }
      resourcesArray = [];
      if (resources.length > 0) {
        if (node != null ? node.value : void 0) {
          node.value = node.value.filter(function(childNode) {
            return !childNode[0].value.match(/^\//);
          });
        }
        resourcesName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'resources', resources[0][0].start_mark, resources[resources.length - 1][1].end_mark);
        resources.forEach(function(resource) {
          var relativeUriName, relativeUriValue;
          relativeUriName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'relativeUri', resource[0].start_mark, resource[1].end_mark);
          relativeUriValue = new nodes.ScalarNode('tag:yaml.org,2002:str', resource[0].value, resource[0].start_mark, resource[1].end_mark);
          if (resource[1].tag === "tag:yaml.org,2002:null") {
            resource[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], resource[0].start_mark, resource[1].end_mark);
          }
          resource[1].value.push([relativeUriName, relativeUriValue]);
          resourcesArray.push(resource[1]);
          _this.join_methods(resource[1]);
          return _this.join_resources(resource[1], ++call);
        });
        resourcesValue = new nodes.SequenceNode('tag:yaml.org,2002:seq', resourcesArray, resources[0][0].start_mark, resources[resources.length - 1][1].end_mark);
        return node.value.push([resourcesName, resourcesValue]);
      }
    };

    Joiner.prototype.join_methods = function(node) {
      var methods, methodsArray, methodsName, methodsValue,
        _this = this;
      methods = [];
      if (node && node.value) {
        methods = node.value.filter(function(childNode) {
          var _ref1;
          return _this.isHttpMethod((_ref1 = childNode[0]) != null ? _ref1.value : void 0);
        });
      }
      methodsArray = [];
      if (methods.length > 0) {
        node.value = node.value.filter(function(childNode) {
          return !_this.isHttpMethod(childNode[0].value);
        });
        methodsName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'methods', methods[0][0].start_mark, methods[methods.length - 1][1].end_mark);
        methods.forEach(function(method) {
          var methodName, methodValue;
          methodName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'method', method[0].start_mark, method[1].end_mark);
          methodValue = new nodes.ScalarNode('tag:yaml.org,2002:str', method[0].value, method[0].start_mark, method[1].end_mark);
          if (method[1].tag === 'tag:yaml.org,2002:null') {
            method[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], method[1].start_mark, method[1].end_mark);
          }
          method[1].value.push([methodName, methodValue]);
          return methodsArray.push(method[1]);
        });
        methodsValue = new nodes.SequenceNode('tag:yaml.org,2002:seq', methodsArray, methods[0][0].start_mark, methods[methods.length - 1][1].end_mark);
        return node.value.push([methodsName, methodsValue]);
      }
    };

    return Joiner;

  })();

}).call(this);

},{"./errors":30,"./nodes":34}],33:[function(require,module,exports){
(function() {
  var composer, construct, joiner, parser, protocols, reader, resolver, scanner, schemas, securitySchemes, traits, transformations, types, util, validator;

  util = require('./util');

  reader = require('./reader');

  scanner = require('./scanner');

  parser = require('./parser');

  composer = require('./composer');

  resolver = require('./resolver');

  construct = require('./construct');

  validator = require('./validator');

  joiner = require('./joiner');

  traits = require('./traits');

  types = require('./resourceTypes');

  schemas = require('./schemas');

  protocols = require('./protocols');

  securitySchemes = require('./securitySchemes');

  transformations = require('./transformations');

  this.make_loader = function(Reader, Scanner, Parser, Composer, Resolver, Validator, ResourceTypes, Traits, Schemas, Protocols, Joiner, SecuritySchemes, Constructor, Transformations) {
    if (Reader == null) {
      Reader = reader.Reader;
    }
    if (Scanner == null) {
      Scanner = scanner.Scanner;
    }
    if (Parser == null) {
      Parser = parser.Parser;
    }
    if (Composer == null) {
      Composer = composer.Composer;
    }
    if (Resolver == null) {
      Resolver = resolver.Resolver;
    }
    if (Validator == null) {
      Validator = validator.Validator;
    }
    if (ResourceTypes == null) {
      ResourceTypes = types.ResourceTypes;
    }
    if (Traits == null) {
      Traits = traits.Traits;
    }
    if (Schemas == null) {
      Schemas = schemas.Schemas;
    }
    if (Protocols == null) {
      Protocols = protocols.Protocols;
    }
    if (Joiner == null) {
      Joiner = joiner.Joiner;
    }
    if (SecuritySchemes == null) {
      SecuritySchemes = securitySchemes.SecuritySchemes;
    }
    if (Constructor == null) {
      Constructor = construct.Constructor;
    }
    if (Transformations == null) {
      Transformations = transformations.Transformations;
    }
    return (function() {
      var component, components;

      components = [Reader, Scanner, Composer, Transformations, Parser, Resolver, Validator, Traits, ResourceTypes, Schemas, Protocols, Joiner, Constructor, SecuritySchemes];

      util.extend.apply(util, [_Class.prototype].concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = components.length; _i < _len; _i++) {
          component = components[_i];
          _results.push(component.prototype);
        }
        return _results;
      })()));

      function _Class(stream, location, settings, parent) {
        var _i, _len, _ref;
        this.parent = parent != null ? parent : null;
        components[0].call(this, stream, location);
        components[1].call(this, settings);
        components[2].call(this, settings);
        components[3].call(this, settings);
        _ref = components.slice(4);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          component = _ref[_i];
          component.call(this);
        }
      }

      return _Class;

    })();
  };

  this.Loader = this.make_loader();

}).call(this);

},{"./composer":28,"./construct":29,"./joiner":32,"./parser":35,"./protocols":36,"./reader":38,"./resolver":39,"./resourceTypes":40,"./scanner":41,"./schemas":42,"./securitySchemes":43,"./traits":45,"./transformations":46,"./util":47,"./validator":48}],34:[function(require,module,exports){
(function() {
  var MarkedYAMLError, unique_id, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  unique_id = 0;

  this.ApplicationError = (function(_super) {
    __extends(ApplicationError, _super);

    function ApplicationError() {
      _ref = ApplicationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ApplicationError;

  })(MarkedYAMLError);

  this.Node = (function() {
    function Node(tag, value, start_mark, end_mark) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.unique_id = "node_" + (unique_id++);
    }

    Node.prototype.clone = function() {
      var temp;
      temp = new this.constructor(this.tag, this.value, this.start_mark, this.end_mark);
      return temp;
    };

    return Node;

  })();

  this.ScalarNode = (function(_super) {
    __extends(ScalarNode, _super);

    ScalarNode.prototype.id = 'scalar';

    function ScalarNode(tag, value, start_mark, end_mark, style) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
      ScalarNode.__super__.constructor.apply(this, arguments);
    }

    ScalarNode.prototype.clone = function() {
      var temp;
      temp = new this.constructor(this.tag, this.value, this.start_mark, this.end_mark, this.style);
      return temp;
    };

    ScalarNode.prototype.cloneRemoveIs = function() {
      return this.clone();
    };

    ScalarNode.prototype.combine = function(node) {
      if (this.tag === 'tag:yaml.org,2002:null' && node.tag === 'tag:yaml.org,2002:map') {
        this.value = new exports.MappingNode('tag:yaml.org,2002:map', [], node.start_mark, node.end_mark);
        return this.value.combine(node);
      } else if (!(node instanceof exports.ScalarNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      return this.value = node.value;
    };

    ScalarNode.prototype.remove_question_mark_properties = function() {};

    return ScalarNode;

  })(this.Node);

  this.CollectionNode = (function(_super) {
    __extends(CollectionNode, _super);

    function CollectionNode(tag, value, start_mark, end_mark, flow_style) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.flow_style = flow_style;
      CollectionNode.__super__.constructor.apply(this, arguments);
    }

    return CollectionNode;

  })(this.Node);

  this.SequenceNode = (function(_super) {
    __extends(SequenceNode, _super);

    function SequenceNode() {
      _ref1 = SequenceNode.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SequenceNode.prototype.id = 'sequence';

    SequenceNode.prototype.clone = function() {
      var item, items, temp, value, _i, _len, _ref2;
      items = [];
      _ref2 = this.value;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        value = item.clone();
        items.push(value);
      }
      temp = new this.constructor(this.tag, items, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    SequenceNode.prototype.cloneRemoveIs = function() {
      return this.clone();
    };

    SequenceNode.prototype.combine = function(node) {
      var property, value, _i, _len, _ref2, _results;
      if (!(node instanceof exports.SequenceNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      _ref2 = node.value;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        property = _ref2[_i];
        value = property.clone();
        _results.push(this.value.push(value));
      }
      return _results;
    };

    SequenceNode.prototype.remove_question_mark_properties = function() {
      var item, _i, _len, _ref2, _results;
      _ref2 = this.value;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        _results.push(item.remove_question_mark_properties());
      }
      return _results;
    };

    return SequenceNode;

  })(this.CollectionNode);

  this.MappingNode = (function(_super) {
    __extends(MappingNode, _super);

    function MappingNode() {
      _ref2 = MappingNode.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    MappingNode.prototype.id = 'mapping';

    MappingNode.prototype.clone = function() {
      var name, properties, property, temp, value, _i, _len, _ref3;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].clone();
        value = property[1].clone();
        properties.push([name, value]);
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneRemoveIs = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].cloneRemoveIs();
        value = property[1].cloneRemoveIs();
        if ((_ref4 = name.value) !== 'is') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneForTrait = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].clone();
        value = property[1].clone();
        if ((_ref4 = name.value) !== 'usage' && _ref4 !== 'displayName') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneForResourceType = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].cloneRemoveIs();
        value = property[1].cloneRemoveIs();
        if ((_ref4 = name.value) !== 'is' && _ref4 !== 'type' && _ref4 !== 'usage' && _ref4 !== 'displayName') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.combine = function(resourceNode) {
      var name, node_has_property, nonNullNode, ownNodeProperty, ownNodePropertyName, resourceProperty, _i, _len, _ref3, _results;
      if (resourceNode.tag === 'tag:yaml.org,2002:null') {
        resourceNode = new exports.MappingNode('tag:yaml.org,2002:map', [], resourceNode.start_mark, resourceNode.end_mark);
      }
      if (!(resourceNode instanceof exports.MappingNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      _ref3 = resourceNode.value;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        resourceProperty = _ref3[_i];
        name = resourceProperty[0].value;
        node_has_property = this.value.some(function(someProperty) {
          return (someProperty[0].value === name) || ((someProperty[0].value + '?') === name) || (someProperty[0].value === (name + '?'));
        });
        if (node_has_property) {
          _results.push((function() {
            var _j, _len1, _ref4, _results1;
            _ref4 = this.value;
            _results1 = [];
            for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
              ownNodeProperty = _ref4[_j];
              ownNodePropertyName = ownNodeProperty[0].value;
              if ((ownNodePropertyName === name) || ((ownNodePropertyName + '?') === name) || (ownNodePropertyName === (name + '?'))) {
                if ((ownNodeProperty[1].tag === 'tag:yaml.org,2002:null') && (resourceProperty[1].tag === 'tag:yaml.org,2002:map')) {
                  nonNullNode = new exports.MappingNode('tag:yaml.org,2002:map', [], ownNodeProperty[1].start_mark, ownNodeProperty[1].end_mark);
                  ownNodeProperty[1] = nonNullNode;
                }
                ownNodeProperty[1].combine(resourceProperty[1]);
                if (!((ownNodeProperty[0].value.slice(-1) === '?') && (resourceProperty[0].value.slice(-1) === '?'))) {
                  if (ownNodeProperty[0].value.slice(-1) === '?') {
                    _results1.push(ownNodeProperty[0].value = ownNodeProperty[0].value.slice(0, -1));
                  } else {
                    _results1.push(void 0);
                  }
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(this.value.push([resourceProperty[0].clone(), resourceProperty[1].clone()]));
        }
      }
      return _results;
    };

    MappingNode.prototype.remove_question_mark_properties = function() {
      var property, _i, _len, _ref3, _results;
      this.value = this.value.filter(function(property) {
        return property[0].value.slice(-1) !== '?';
      });
      _ref3 = this.value;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        _results.push(property[1].remove_question_mark_properties());
      }
      return _results;
    };

    return MappingNode;

  })(this.CollectionNode);

}).call(this);

},{"./errors":30}],35:[function(require,module,exports){
(function() {
  var MarkedYAMLError, events, tokens, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  events = require('./events');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  tokens = require('./tokens');

  this.ParserError = (function(_super) {
    __extends(ParserError, _super);

    function ParserError() {
      _ref = ParserError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ParserError;

  })(MarkedYAMLError);

  this.Parser = (function() {
    var DEFAULT_TAGS;

    DEFAULT_TAGS = {
      '!': '!',
      '!!': 'tag:yaml.org,2002:'
    };

    function Parser() {
      this.current_event = null;
      this.yaml_version = null;
      this.tag_handles = {};
      this.states = [];
      this.marks = [];
      this.state = 'parse_stream_start';
    }

    /*
    Reset the state attributes.
    */


    Parser.prototype.dispose = function() {
      this.states = [];
      return this.state = null;
    };

    /*
    Check the type of the next event.
    */


    Parser.prototype.check_event = function() {
      var choice, choices, _i, _len;
      choices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.current_event === null) {
        if (this.state != null) {
          this.current_event = this[this.state]();
        }
      }
      if (this.current_event !== null) {
        if (choices.length === 0) {
          return true;
        }
        for (_i = 0, _len = choices.length; _i < _len; _i++) {
          choice = choices[_i];
          if (this.current_event instanceof choice) {
            return true;
          }
        }
      }
      return false;
    };

    /*
    Get the next event.
    */


    Parser.prototype.peek_event = function() {
      if (this.current_event === null && (this.state != null)) {
        this.current_event = this[this.state]();
      }
      return this.current_event;
    };

    /*
    Get the event and proceed further.
    */


    Parser.prototype.get_event = function() {
      var event;
      if (this.current_event === null && (this.state != null)) {
        this.current_event = this[this.state]();
      }
      event = this.current_event;
      this.current_event = null;
      return event;
    };

    /*
    Parse the stream start.
    */


    Parser.prototype.parse_stream_start = function() {
      var event, token;
      token = this.get_token();
      event = new events.StreamStartEvent(token.start_mark, token.end_mark);
      this.state = 'parse_implicit_document_start';
      return event;
    };

    /*
    Parse an implicit document.
    */


    Parser.prototype.parse_implicit_document_start = function() {
      var end_mark, event, start_mark, token;
      if (!this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.StreamEndToken)) {
        this.tag_handles = DEFAULT_TAGS;
        token = this.peek_token();
        start_mark = end_mark = token.start_mark;
        event = new events.DocumentStartEvent(start_mark, end_mark, false);
        this.states.push('parse_document_end');
        this.state = 'parse_block_node';
        return event;
      } else {
        return this.parse_document_start();
      }
    };

    /*
    Parse an explicit document.
    */


    Parser.prototype.parse_document_start = function() {
      var end_mark, event, start_mark, tags, token, version, _ref1;
      while (this.check_token(tokens.DocumentEndToken)) {
        this.get_token();
      }
      if (!this.check_token(tokens.StreamEndToken)) {
        start_mark = this.peek_token().start_mark;
        _ref1 = this.process_directives(), version = _ref1[0], tags = _ref1[1];
        if (!this.check_token(tokens.DocumentStartToken)) {
          throw new exports.ParserError("expected '<document start>', but found " + (this.peek_token().id), this.peek_token().start_mark);
        }
        token = this.get_token();
        end_mark = token.end_mark;
        event = new events.DocumentStartEvent(start_mark, end_mark, true, version, tags);
        this.states.push('parse_document_end');
        this.state = 'parse_document_content';
      } else {
        token = this.get_token();
        event = new events.StreamEndEvent(token.start_mark, token.end_mark);
        if (this.states.length !== 0) {
          throw new Error('assertion error, states should be empty');
        }
        if (this.marks.length !== 0) {
          throw new Error('assertion error, marks should be empty');
        }
        this.state = null;
      }
      return event;
    };

    /*
    Parse the document end.
    */


    Parser.prototype.parse_document_end = function() {
      var end_mark, event, explicit, start_mark, token;
      token = this.peek_token();
      start_mark = end_mark = token.start_mark;
      explicit = false;
      if (this.check_token(tokens.DocumentEndToken)) {
        token = this.get_token();
        end_mark = token.end_mark;
        explicit = true;
      }
      event = new events.DocumentEndEvent(start_mark, end_mark, explicit);
      this.state = 'parse_document_start';
      return event;
    };

    Parser.prototype.parse_document_content = function() {
      var event;
      if (this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.DocumentEndToken, tokens.StreamEndToken)) {
        event = this.process_empty_scalar(this.peek_token().start_mark);
        this.state = this.states.pop();
        return event;
      } else {
        return this.parse_block_node();
      }
    };

    Parser.prototype.process_directives = function() {
      var handle, major, minor, prefix, tag_handles_copy, token, value, _ref1, _ref2, _ref3;
      this.yaml_version = null;
      this.tag_handles = {};
      while (this.check_token(tokens.DirectiveToken)) {
        token = this.get_token();
        if (token.name === 'YAML') {
          if (this.yaml_version !== null) {
            throw new exports.ParserError(null, null, 'found duplicate YAML directive', token.start_mark);
          }
          _ref1 = token.value, major = _ref1[0], minor = _ref1[1];
          if (major !== 1 || minor !== 2) {
            throw new exports.ParserError(null, null, 'found incompatible YAML document (version 1.2 is required)', token.start_mark);
          }
          this.yaml_version = token.value;
        } else if (token.name === 'TAG') {
          _ref2 = token.value, handle = _ref2[0], prefix = _ref2[1];
          if (handle in this.tag_handles) {
            throw new exports.ParserError(null, null, "duplicate tag handle " + handle, token.start_mark);
          }
          this.tag_handles[handle] = prefix;
        }
      }
      tag_handles_copy = null;
      _ref3 = this.tag_handles;
      for (handle in _ref3) {
        if (!__hasProp.call(_ref3, handle)) continue;
        prefix = _ref3[handle];
        if (tag_handles_copy == null) {
          tag_handles_copy = {};
        }
        tag_handles_copy[handle] = prefix;
      }
      value = [this.yaml_version, tag_handles_copy];
      for (handle in DEFAULT_TAGS) {
        if (!__hasProp.call(DEFAULT_TAGS, handle)) continue;
        prefix = DEFAULT_TAGS[handle];
        if (!(prefix in this.tag_handles)) {
          this.tag_handles[handle] = prefix;
        }
      }
      return value;
    };

    Parser.prototype.parse_block_node = function() {
      return this.parse_node(true);
    };

    Parser.prototype.parse_flow_node = function() {
      return this.parse_node();
    };

    Parser.prototype.parse_block_node_or_indentless_sequence = function() {
      return this.parse_node(true, true);
    };

    Parser.prototype.parse_node = function(block, indentless_sequence) {
      var anchor, end_mark, event, handle, implicit, node, start_mark, suffix, tag, tag_mark, token;
      if (block == null) {
        block = false;
      }
      if (indentless_sequence == null) {
        indentless_sequence = false;
      }
      if (this.check_token(tokens.AliasToken)) {
        token = this.get_token();
        event = new events.AliasEvent(token.value, token.start_mark, token.end_mark);
        this.state = this.states.pop();
      } else {
        anchor = null;
        tag = null;
        start_mark = end_mark = tag_mark = null;
        if (this.check_token(tokens.AnchorToken)) {
          token = this.get_token();
          start_mark = token.start_mark;
          end_mark = token.end_mark;
          anchor = token.value;
          if (this.check_token(tokens.TagToken)) {
            token = this.get_token();
            tag_mark = token.start_mark;
            end_mark = token.end_mark;
            tag = token.value;
          }
        } else if (this.check_token(tokens.TagToken)) {
          token = this.get_token();
          start_mark = tag_mark = token.start_mark;
          end_mark = token.end_mark;
          tag = token.value;
          if (this.check_token(tokens.AnchorToken)) {
            token = this.get_token();
            end_mark = token.end_mark;
            anchor = token.value;
          }
        }
        if (tag !== null) {
          handle = tag[0], suffix = tag[1];
          if (handle !== null) {
            if (!(handle in this.tag_handles)) {
              throw new exports.ParserError('while parsing a node', start_mark, "found undefined tag handle " + handle, tag_mark);
            }
            tag = this.tag_handles[handle] + suffix;
          } else {
            tag = suffix;
          }
        }
        if (start_mark === null) {
          start_mark = end_mark = this.peek_token().start_mark;
        }
        event = null;
        implicit = tag === null || tag === '!';
        if (indentless_sequence && this.check_token(tokens.BlockEntryToken)) {
          end_mark = this.peek_token().end_mark;
          event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark);
          this.state = 'parse_indentless_sequence_entry';
        } else {
          if (this.check_token(tokens.ScalarToken)) {
            token = this.get_token();
            end_mark = token.end_mark;
            if ((token.plain && tag === null) || tag === '!') {
              implicit = [true, false];
            } else if (tag === null) {
              implicit = [false, true];
            } else {
              implicit = [false, false];
            }
            event = new events.ScalarEvent(anchor, tag, implicit, token.value, start_mark, end_mark, token.style);
            this.state = this.states.pop();
          } else if (this.check_token(tokens.FlowSequenceStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, true);
            this.state = 'parse_flow_sequence_first_entry';
          } else if (this.check_token(tokens.FlowMappingStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, true);
            this.state = 'parse_flow_mapping_first_key';
          } else if (block && this.check_token(tokens.BlockSequenceStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, false);
            this.state = 'parse_block_sequence_first_entry';
          } else if (block && this.check_token(tokens.BlockMappingStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, false);
            this.state = 'parse_block_mapping_first_key';
          } else if (anchor !== null || tag !== null) {
            event = new events.ScalarEvent(anchor, tag, [implicit, false], '', start_mark, end_mark);
            this.state = this.states.pop();
          } else {
            if (block) {
              node = 'block';
            } else {
              node = 'flow';
            }
            token = this.peek_token();
            throw new exports.ParserError("while parsing a " + node + " node", start_mark, "expected the node content, but found " + token.id, token.start_mark);
          }
        }
      }
      return event;
    };

    Parser.prototype.parse_block_sequence_first_entry = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_block_sequence_entry();
    };

    Parser.prototype.parse_block_sequence_entry = function() {
      var event, token;
      if (this.check_token(tokens.BlockEntryToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.BlockEntryToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_sequence_entry');
          return this.parse_block_node();
        } else {
          this.state = 'parse_block_sequence_entry';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      if (!this.check_token(tokens.BlockEndToken)) {
        token = this.peek_token();
        throw new exports.ParserError('while parsing a block collection', this.marks.slice(-1)[0], "expected <block end>, but found " + token.id, token.start_mark);
      }
      token = this.get_token();
      event = new events.SequenceEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_indentless_sequence_entry = function() {
      var event, token;
      if (this.check_token(tokens.BlockEntryToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.BlockEntryToken, tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_indentless_sequence_entry');
          return this.parse_block_node();
        } else {
          this.state = 'parse_indentless_sequence_entry';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      token = this.peek_token();
      event = new events.SequenceEndEvent(token.start_mark, token.start_mark);
      this.state = this.states.pop();
      return event;
    };

    Parser.prototype.parse_block_mapping_first_key = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_block_mapping_key();
    };

    Parser.prototype.parse_block_mapping_key = function() {
      var event, token;
      if (this.check_token(tokens.KeyToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_mapping_value');
          return this.parse_block_node_or_indentless_sequence();
        } else {
          this.state = 'parse_block_mapping_value';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      if (!this.check_token(tokens.BlockEndToken)) {
        token = this.peek_token();
        throw new exports.ParserError('while parsing a block mapping', this.marks.slice(-1)[0], "expected <block end>, but found " + token.id, token.start_mark);
      }
      token = this.get_token();
      event = new events.MappingEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_block_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_mapping_key');
          return this.parse_block_node_or_indentless_sequence();
        } else {
          this.state = 'parse_block_mapping_key';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_block_mapping_key';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_first_entry = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_flow_sequence_entry(true);
    };

    Parser.prototype.parse_flow_sequence_entry = function(first) {
      var event, token;
      if (first == null) {
        first = false;
      }
      if (!this.check_token(tokens.FlowSequenceEndToken)) {
        if (!first) {
          if (this.check_token(tokens.FlowEntryToken)) {
            this.get_token();
          } else {
            token = this.peek_token();
            throw new exports.ParserError('while parsing a flow sequence', this.marks.slice(-1)[0], "expected ',' or ']', but got " + token.id, token.start_mark);
          }
        }
        if (this.check_token(tokens.KeyToken)) {
          token = this.peek_token();
          event = new events.MappingStartEvent(null, null, true, token.start_mark, token.end_mark, true);
          this.state = 'parse_flow_sequence_entry_mapping_key';
          return event;
        } else if (!this.check_token(tokens.FlowSequenceEndToken)) {
          this.states.push('parse_flow_sequence_entry');
          return this.parse_flow_node();
        }
      }
      token = this.get_token();
      event = new events.SequenceEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_key = function() {
      var token;
      token = this.get_token();
      if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {
        this.states.push('parse_flow_sequence_entry_mapping_value');
        return this.parse_flow_node();
      } else {
        this.state = 'parse_flow_sequence_entry_mapping_value';
        return this.process_empty_scalar(token.end_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {
          this.states.push('parse_flow_sequence_entry_mapping_end');
          return this.parse_flow_node();
        } else {
          this.state = 'parse_flow_sequence_entry_mapping_end';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_flow_sequence_entry_mapping_end';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_end = function() {
      var token;
      this.state = 'parse_flow_sequence_entry';
      token = this.peek_token();
      return new events.MappingEndEvent(token.start_mark, token.start_mark);
    };

    Parser.prototype.parse_flow_mapping_first_key = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_flow_mapping_key(true);
    };

    Parser.prototype.parse_flow_mapping_key = function(first) {
      var event, token;
      if (first == null) {
        first = false;
      }
      if (!this.check_token(tokens.FlowMappingEndToken)) {
        if (!first) {
          if (this.check_token(tokens.FlowEntryToken)) {
            this.get_token();
          } else {
            token = this.peek_token();
            throw new exports.ParserError('while parsing a flow mapping', this.marks.slice(-1)[0], "expected ',' or '}', but got " + token.id, token.start_mark);
          }
        }
        if (this.check_token(tokens.KeyToken)) {
          token = this.get_token();
          if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {
            this.states.push('parse_flow_mapping_value');
            return this.parse_flow_node();
          } else {
            this.state = 'parse_flow_mapping_value';
            return this.process_empty_scalar(token.end_mark);
          }
        } else if (!this.check_token(tokens.FlowMappingEndToken)) {
          this.states.push('parse_flow_mapping_empty_value');
          return this.parse_flow_node();
        }
      }
      token = this.get_token();
      event = new events.MappingEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_flow_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {
          this.states.push('parse_flow_mapping_key');
          return this.parse_flow_node();
        } else {
          this.state = 'parse_flow_mapping_key';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_flow_mapping_key';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_mapping_empty_value = function() {
      this.state = 'parse_flow_mapping_key';
      return this.process_empty_scalar(this.peek_token().start_mark);
    };

    Parser.prototype.process_empty_scalar = function(mark) {
      return new events.ScalarEvent(null, null, [true, false], '', mark, mark);
    };

    return Parser;

  })();

}).call(this);

},{"./errors":30,"./events":31,"./tokens":44}],36:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, url, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  url = require('url');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  /*
  The Protocols class deals with applying protocols to methods according to the spec
  */


  this.Protocols = (function() {
    function Protocols() {
      this.apply_protocols = __bind(this.apply_protocols, this);
    }

    Protocols.prototype.apply_protocols = function(node) {
      var protocols;
      if (protocols = this.apply_protocols_to_root(node)) {
        return this.apply_protocols_to_resources(node, protocols);
      }
    };

    Protocols.prototype.apply_protocols_to_root = function(node) {
      var baseUri, parsedBaseUri, protocol, protocols;
      if (this.has_property(node, 'protocols')) {
        return this.get_property(node, 'protocols');
      }
      if (!(baseUri = this.property_value(node, 'baseUri'))) {
        return;
      }
      parsedBaseUri = url.parse(baseUri);
      protocol = (parsedBaseUri.protocol || 'http:').slice(0, -1).toUpperCase();
      protocols = [new nodes.ScalarNode('tag:yaml.org,2002:str', 'protocols', node.start_mark, node.end_mark), new nodes.SequenceNode('tag:yaml.org,2002:seq', [new nodes.ScalarNode('tag:yaml.org,2002:str', protocol, node.start_mark, node.end_mark)], node.start_mark, node.end_mark)];
      node.value.push(protocols);
      return protocols[1];
    };

    Protocols.prototype.apply_protocols_to_resources = function(node, protocols) {
      var resource, _i, _len, _ref, _results;
      _ref = this.child_resources(node);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        resource = _ref[_i];
        this.apply_protocols_to_resources(resource, protocols);
        _results.push(this.apply_protocols_to_methods(resource, protocols));
      }
      return _results;
    };

    Protocols.prototype.apply_protocols_to_methods = function(node, protocols) {
      var method, _i, _len, _ref, _results;
      _ref = this.child_methods(node[1]);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        method = _ref[_i];
        if (!this.has_property(method[1], 'protocols')) {
          if (!util.isMapping(method[1])) {
            method[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], method[1].start_mark, method[1].end_mark);
          }
          _results.push(method[1].value.push([new nodes.ScalarNode('tag:yaml.org,2002:str', 'protocols', method[0].start_mark, method[0].end_mark), protocols.clone()]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Protocols;

  })();

}).call(this);

},{"./errors":30,"./nodes":34,"./util":47,"url":25}],37:[function(require,module,exports){
(function() {
  var defaultSettings, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.errors = require('./errors');

  this.loader = require('./loader');

  util = require('./util');

  this.FileError = (function(_super) {
    __extends(FileError, _super);

    function FileError() {
      _ref = FileError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return FileError;

  })(this.errors.MarkedYAMLError);

  this.FileReader = (function() {
    function FileReader(readFileAsyncOverride) {
      this.q = require('q');
      this.url = require('url');
      if (readFileAsyncOverride) {
        this.readFileAsyncOverride = readFileAsyncOverride;
      }
    }

    /*
    Read file either locally or from the network.
    */


    FileReader.prototype.readFileAsync = function(file) {
      var targerUrl;
      if (this.readFileAsyncOverride) {
        return this.readFileAsyncOverride(file);
      }
      targerUrl = this.url.parse(file);
      if (targerUrl.protocol != null) {
        if (!targerUrl.protocol.match(/^https?/i)) {
          throw new exports.FileError("while reading " + file, null, "unknown protocol " + targerUrl.protocol, this.start_mark);
        } else {
          return this.fetchFileAsync(file);
        }
      } else {
        if (typeof window !== "undefined" && window !== null) {
          return this.fetchFileAsync(file);
        } else {
          return this.fetchLocalFileAsync(file);
        }
      }
    };

    /*
    Read file from the disk.
    */


    FileReader.prototype.fetchLocalFileAsync = function(file) {
      var deferred,
        _this = this;
      deferred = this.q.defer();
      require('fs').readFile(file, function(err, data) {
        if (err) {
          return deferred.reject(new exports.FileError("while reading " + file, null, "cannot read " + file + " (" + err + ")", _this.start_mark));
        } else {
          return deferred.resolve(data.toString());
        }
      });
      return deferred.promise;
    };

    /*
    Read file from the network.
    */


    FileReader.prototype.fetchFileAsync = function(file) {
      var deferred, error, xhr,
        _this = this;
      deferred = this.q.defer();
      if (typeof window !== "undefined" && window !== null) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new (require('xmlhttprequest').XMLHttpRequest)();
      }
      try {
        xhr.open('GET', file, false);
        xhr.setRequestHeader('Accept', 'application/raml+yaml, */*');
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if ((typeof xhr.status === 'number' && xhr.status === 200) || (typeof xhr.status === 'string' && xhr.status.match(/^200/i))) {
              return deferred.resolve(xhr.responseText);
            } else {
              return deferred.reject(new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + xhr.statusText + ")", _this.start_mark));
            }
          }
        };
        xhr.send(null);
        return deferred.promise;
      } catch (_error) {
        error = _error;
        throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + "), check that the server is up and that CORS is enabled", this.start_mark);
      }
    };

    return FileReader;

  })();

  /*
  OO version of the parser, static functions will be removed after consumers move on to use the OO version
  OO will offer caching
  */


  this.RamlParser = (function() {
    function RamlParser(settings) {
      this.settings = settings != null ? settings : defaultSettings;
      this.q = require('q');
      this.url = require('url');
      this.nodes = require('./nodes');
      this.loadDefaultSettings(settings);
    }

    RamlParser.prototype.loadDefaultSettings = function(settings) {
      var _this = this;
      return Object.keys(defaultSettings).forEach(function(settingName) {
        if (!(settingName in settings)) {
          return settings[settingName] = defaultSettings[settingName];
        }
      });
    };

    RamlParser.prototype.loadFile = function(file, settings) {
      var error,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      try {
        return settings.reader.readFileAsync(file).then(function(stream) {
          return _this.load(stream, file, settings);
        });
      } catch (_error) {
        error = _error;
        return this.q.fcall(function() {
          throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + ")", null);
        });
      }
    };

    RamlParser.prototype.composeFile = function(file, settings, parent) {
      var error,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      try {
        return settings.reader.readFileAsync(file).then(function(stream) {
          return _this.compose(stream, file, settings, parent);
        });
      } catch (_error) {
        error = _error;
        return this.q.fcall(function() {
          throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + ")", null);
        });
      }
    };

    RamlParser.prototype.compose = function(stream, location, settings, parent) {
      if (settings == null) {
        settings = this.settings;
      }
      if (parent == null) {
        parent = {
          src: location
        };
      }
      settings.compose = false;
      return this.parseStream(stream, location, settings, parent);
    };

    RamlParser.prototype.load = function(stream, location, settings) {
      if (settings == null) {
        settings = this.settings;
      }
      settings.compose = true;
      return this.parseStream(stream, location, settings, {
        src: location
      });
    };

    RamlParser.prototype.parseStream = function(stream, location, settings, parent) {
      var loader,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      loader = new exports.loader.Loader(stream, location, settings, parent);
      return this.q.fcall(function() {
        return loader.getYamlRoot();
      }).then(function(partialTree) {
        var files;
        files = loader.getPendingFilesList();
        return _this.getPendingFiles(loader, partialTree, files);
      }).then(function(fullyAssembledTree) {
        loader.composeRamlTree(fullyAssembledTree, settings);
        if (settings.compose) {
          if (fullyAssembledTree != null) {
            return loader.construct_document(fullyAssembledTree);
          } else {
            return null;
          }
        } else {
          return fullyAssembledTree;
        }
      });
    };

    RamlParser.prototype.getPendingFiles = function(loader, node, files) {
      var file, lastVisitedNode, loc, _i, _len,
        _this = this;
      loc = [];
      lastVisitedNode = void 0;
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        loc.push(this.getPendingFile(loader, file).then(function(overwritingnode) {
          if (overwritingnode && !lastVisitedNode) {
            return lastVisitedNode = overwritingnode;
          }
        }));
      }
      return this.q.all(loc).then(function() {
        if (lastVisitedNode) {
          return lastVisitedNode;
        } else {
          return node;
        }
      });
    };

    RamlParser.prototype.getPendingFile = function(loader, fileInfo) {
      var error, event, fileUri, key, node,
        _this = this;
      node = fileInfo.parentNode;
      event = fileInfo.event;
      key = fileInfo.parentKey;
      fileUri = fileInfo.targetFileUri;
      if (fileInfo.includingContext) {
        fileUri = this.url.resolve(fileInfo.includingContext, fileInfo.targetFileUri);
      }
      if (loader.parent && this.isInIncludeTagsStack(fileUri, loader)) {
        throw new exports.FileError('while composing scalar out of !include', null, "detected circular !include of " + event.value, event.start_mark);
      }
      try {
        if (fileInfo.type === 'fragment') {
          return this.settings.reader.readFileAsync(fileUri).then(function(result) {
            return _this.compose(result, fileUri, {
              validate: false,
              transform: false,
              compose: true
            }, loader);
          }).then(function(value) {
            return _this.appendNewNodeToParent(node, key, value);
          })["catch"](function(error) {
            return _this.addContextToError(error, event);
          });
        } else {
          return this.settings.reader.readFileAsync(fileUri).then(function(result) {
            var value;
            value = new _this.nodes.ScalarNode('tag:yaml.org,2002:str', result, event.start_mark, event.end_mark, event.style);
            return _this.appendNewNodeToParent(node, key, value);
          })["catch"](function(error) {
            return _this.addContextToError(error, event);
          });
        }
      } catch (_error) {
        error = _error;
        return this.addContextToError(error, event);
      }
    };

    RamlParser.prototype.addContextToError = function(error, event) {
      if (error.constructor.name === "FileError") {
        if (!error.problem_mark) {
          error.problem_mark = event.start_mark;
        }
        throw error;
      } else {
        throw new exports.FileError('while reading file', null, "error: " + error, event.start_mark);
      }
    };

    RamlParser.prototype.isInIncludeTagsStack = function(include, parent) {
      while (parent = parent.parent) {
        if (parent.src === include) {
          return true;
        }
      }
      return false;
    };

    RamlParser.prototype.appendNewNodeToParent = function(node, key, value) {
      if (node) {
        if (util.isSequence(node)) {
          node.value[key] = value;
        } else {
          node.value.push([key, value]);
        }
        return null;
      } else {
        return value;
      }
    };

    return RamlParser;

  })();

  /*
    validate controls whether the stream must be processed as a
  */


  defaultSettings = {
    validate: true,
    transform: true,
    compose: true,
    reader: new exports.FileReader(null)
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  Javascript object.
  */


  this.loadFile = function(file, settings) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    parser = new exports.RamlParser(settings);
    return parser.loadFile(file, settings);
  };

  /*
  Parse the first RAML document in a file and produce the corresponding
  representation tree.
  */


  this.composeFile = function(file, settings, parent) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    if (parent == null) {
      parent = file;
    }
    parser = new exports.RamlParser(settings);
    return parser.composeFile(file, settings, parent);
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  representation tree.
  */


  this.compose = function(stream, location, settings, parent) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    if (parent == null) {
      parent = location;
    }
    parser = new exports.RamlParser(settings);
    return parser.compose(stream, location, settings, parent);
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  Javascript object.
  */


  this.load = function(stream, location, settings) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    parser = new exports.RamlParser(settings);
    return parser.load(stream, location, settings, null);
  };

}).call(this);

},{"./errors":30,"./loader":33,"./nodes":34,"./util":47,"fs":1,"q":51,"url":25,"xmlhttprequest":53}],38:[function(require,module,exports){
(function() {
  var Mark, MarkedYAMLError, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./errors'), Mark = _ref.Mark, MarkedYAMLError = _ref.MarkedYAMLError;

  this.ReaderError = (function(_super) {
    __extends(ReaderError, _super);

    function ReaderError() {
      _ref1 = ReaderError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ReaderError;

  })(MarkedYAMLError);

  /*
  Reader:
    checks if characters are within the allowed range
    add '\x00' to the end
  */


  this.Reader = (function() {
    var NON_PRINTABLE;

    NON_PRINTABLE = /[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD]/;

    function Reader(string, src) {
      this.string = string;
      this.src = src;
      this.line = 0;
      this.column = 0;
      this.index = 0;
      this.string += '\x00';
    }

    Reader.prototype.peek = function(index) {
      if (index == null) {
        index = 0;
      }
      return this.string[this.index + index];
    };

    Reader.prototype.prefix = function(length) {
      if (length == null) {
        length = 1;
      }
      return this.string.slice(this.index, this.index + length);
    };

    Reader.prototype.forward = function(length) {
      var char, _results;
      if (length == null) {
        length = 1;
      }
      _results = [];
      while (length) {
        char = this.string[this.index];
        this.index++;
        if (__indexOf.call('\n\x85\u2082\u2029', char) >= 0 || (char === '\r' && this.string[this.index] !== '\n')) {
          this.line++;
          this.column = 0;
        } else {
          this.check_printable(char);
          this.column++;
        }
        _results.push(length--);
      }
      return _results;
    };

    Reader.prototype.create_mark = function(line, column) {
      if (line == null) {
        line = this.line;
      }
      if (column == null) {
        column = this.column;
      }
      return new Mark(this.src, line, column, this.string, this.index);
    };

    Reader.prototype.get_mark = function() {
      return this.create_mark();
    };

    Reader.prototype.check_printable = function(char) {
      if (NON_PRINTABLE.exec(char)) {
        throw new exports.ReaderError('while reading file', null, "non printable characters are not allowed column: " + (this.get_mark().column), this.get_mark());
      }
    };

    return Reader;

  })();

}).call(this);

},{"./errors":30}],39:[function(require,module,exports){
(function() {
  var YAMLError, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  nodes = require('./nodes');

  util = require('./util');

  YAMLError = require('./errors').YAMLError;

  this.ResolverError = (function(_super) {
    __extends(ResolverError, _super);

    function ResolverError() {
      _ref = ResolverError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ResolverError;

  })(YAMLError);

  this.BaseResolver = (function() {
    var DEFAULT_MAPPING_TAG, DEFAULT_SCALAR_TAG, DEFAULT_SEQUENCE_TAG;

    DEFAULT_SCALAR_TAG = 'tag:yaml.org,2002:str';

    DEFAULT_SEQUENCE_TAG = 'tag:yaml.org,2002:seq';

    DEFAULT_MAPPING_TAG = 'tag:yaml.org,2002:map';

    BaseResolver.prototype.yaml_implicit_resolvers = {};

    BaseResolver.prototype.yaml_path_resolvers = {};

    BaseResolver.add_implicit_resolver = function(tag, regexp, first) {
      var char, _base, _i, _len, _results;
      if (first == null) {
        first = [null];
      }
      if (!this.prototype.hasOwnProperty('yaml_implicit_resolvers')) {
        this.prototype.yaml_implicit_resolvers = util.extend({}, this.prototype.yaml_implicit_resolvers);
      }
      _results = [];
      for (_i = 0, _len = first.length; _i < _len; _i++) {
        char = first[_i];
        _results.push(((_base = this.prototype.yaml_implicit_resolvers)[char] != null ? (_base = this.prototype.yaml_implicit_resolvers)[char] : _base[char] = []).push([tag, regexp]));
      }
      return _results;
    };

    function BaseResolver() {
      this.resolver_exact_paths = [];
      this.resolver_prefix_paths = [];
    }

    BaseResolver.prototype.descend_resolver = function(current_node, current_index) {
      var depth, exact_paths, kind, path, prefix_paths, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
      if (util.is_empty(this.yaml_path_resolvers)) {
        return;
      }
      exact_paths = {};
      prefix_paths = [];
      if (current_node) {
        depth = this.resolver_prefix_paths.length;
        _ref1 = this.resolver_prefix_paths.slice(-1)[0];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], path = _ref2[0], kind = _ref2[1];
          if (this.check_resolver_prefix(depth, path, kind, current_node, current_index)) {
            if (path.length > depth) {
              prefix_paths.push([path, kind]);
            } else {
              exact_paths[kind] = this.yaml_path_resolvers[path][kind];
            }
          }
        }
      } else {
        _ref3 = this.yaml_path_resolvers;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          _ref4 = _ref3[_j], path = _ref4[0], kind = _ref4[1];
          if (!path) {
            exact_paths[kind] = this.yaml_path_resolvers[path][kind];
          } else {
            prefix_paths.push([path, kind]);
          }
        }
      }
      this.resolver_exact_paths.push(exact_paths);
      return this.resolver_prefix_paths.push(prefix_paths);
    };

    BaseResolver.prototype.ascend_resolver = function() {
      if (util.is_empty(this.yaml_path_resolvers)) {
        return;
      }
      this.resolver_exact_paths.pop();
      return this.resolver_prefix_paths.pop();
    };

    BaseResolver.prototype.check_resolver_prefix = function(depth, path, kind, current_node, current_index) {
      var index_check, node_check, _ref1;
      _ref1 = path[depth - 1], node_check = _ref1[0], index_check = _ref1[1];
      if (typeof node_check === 'string') {
        if (current_node.tag !== node_check) {
          return;
        }
      } else if (node_check !== null) {
        if (!(current_node instanceof node_check)) {
          return;
        }
      }
      if (index_check === true && current_index !== null) {
        return;
      }
      if ((index_check === false || index_check === null) && current_index === null) {
        return;
      }
      if (typeof index_check === 'string') {
        if (!(current_index instanceof nodes.ScalarNode) && index_check === current_index.value) {
          return;
        }
      } else if (typeof index_check === 'number') {
        if (index_check !== current_index) {
          return;
        }
      }
      return true;
    };

    BaseResolver.prototype.resolve = function(kind, value, implicit) {
      var empty, exact_paths, k, regexp, resolvers, tag, _i, _len, _ref1, _ref2, _ref3, _ref4;
      if (kind === nodes.ScalarNode && implicit[0]) {
        if (value === '') {
          resolvers = (_ref1 = this.yaml_implicit_resolvers['']) != null ? _ref1 : [];
        } else {
          resolvers = (_ref2 = this.yaml_implicit_resolvers[value[0]]) != null ? _ref2 : [];
        }
        resolvers = resolvers.concat((_ref3 = this.yaml_implicit_resolvers[null]) != null ? _ref3 : []);
        for (_i = 0, _len = resolvers.length; _i < _len; _i++) {
          _ref4 = resolvers[_i], tag = _ref4[0], regexp = _ref4[1];
          if (value.match(regexp)) {
            return tag;
          }
        }
        implicit = implicit[1];
      }
      empty = true;
      for (k in this.yaml_path_resolvers) {
        if ({}[k] == null) {
          empty = false;
        }
      }
      if (!empty) {
        exact_paths = this.resolver_exact_paths.slice(-1)[0];
        if (__indexOf.call(exact_paths, kind) >= 0) {
          return exact_paths[kind];
        }
        if (__indexOf.call(exact_paths, null) >= 0) {
          return exact_paths[null];
        }
      }
      if (kind === nodes.ScalarNode) {
        return DEFAULT_SCALAR_TAG;
      }
      if (kind === nodes.SequenceNode) {
        return DEFAULT_SEQUENCE_TAG;
      }
      if (kind === nodes.MappingNode) {
        return DEFAULT_MAPPING_TAG;
      }
    };

    return BaseResolver;

  })();

  this.Resolver = (function(_super) {
    __extends(Resolver, _super);

    function Resolver() {
      _ref1 = Resolver.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return Resolver;

  })(this.BaseResolver);

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:bool', /^(?:true|True|TRUE|false|False|FALSE)$/, 'tTfF');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:float', /^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?|\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*|[-+]?\.(?:inf|Inf|INF)|\.(?:nan|NaN|NAN))$/, '-+0123456789.');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:int', /^(?:[-+]?0b[01_]+|[-+]?0[0-7_]+|[-+]?(?:0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?0o[0-7_]+|[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$/, '-+0123456789');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:merge', /^(?:<<)$/, '<');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:null', /^(?:~|null|Null|NULL|)$/, ['~', 'n', 'N', '']);

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:timestamp', /^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]|[0-9][0-9][0-9][0-9]-[0-9][0-9]?-[0-9][0-9]?(?:[Tt]|[\x20\t]+)[0-9][0-9]?:[0-9][0-9]:[0-9][0-9](?:\.[0-9]*)?(?:[\x20\t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$/, '0123456789');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:value', /^(?:=)$/, '=');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:yaml', /^(?:!|&|\*)$/, '!&*');

}).call(this);

},{"./errors":30,"./nodes":34,"./util":47}],40:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  /*
  The ResourceTypes throws these.
  */


  this.ResourceTypeError = (function(_super) {
    __extends(ResourceTypeError, _super);

    function ResourceTypeError() {
      _ref = ResourceTypeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ResourceTypeError;

  })(MarkedYAMLError);

  /*
  The ResourceTypes class deals with applying ResourceTypes to resources according to the spec
  */


  this.ResourceTypes = (function() {
    function ResourceTypes() {
      this.apply_parameters_to_type = __bind(this.apply_parameters_to_type, this);
      this.apply_type = __bind(this.apply_type, this);
      this.apply_types = __bind(this.apply_types, this);
      this.get_type = __bind(this.get_type, this);
      this.has_types = __bind(this.has_types, this);
      this.load_types = __bind(this.load_types, this);
      this.declaredTypes = {};
    }

    ResourceTypes.prototype.load_types = function(node) {
      var allTypes,
        _this = this;
      this.load_default_media_type(node);
      if (this.has_property(node, 'resourceTypes')) {
        allTypes = this.property_value(node, 'resourceTypes');
        if (allTypes && typeof allTypes === 'object') {
          return allTypes.forEach(function(type_item) {
            if (type_item && typeof type_item === 'object' && typeof type_item.value === 'object') {
              return type_item.value.forEach(function(type) {
                return _this.declaredTypes[type[0].value] = type;
              });
            }
          });
        }
      }
    };

    ResourceTypes.prototype.has_types = function(node) {
      if (Object.keys(this.declaredTypes).length === 0 && this.has_property(node, 'resourceTypes')) {
        this.load_types(node);
      }
      return Object.keys(this.declaredTypes).length > 0;
    };

    ResourceTypes.prototype.get_type = function(typeName) {
      return this.declaredTypes[typeName];
    };

    ResourceTypes.prototype.apply_types = function(node, resourceUri) {
      var resources,
        _this = this;
      if (resourceUri == null) {
        resourceUri = "";
      }
      if (!util.isMapping(node)) {
        return;
      }
      if (this.has_types(node)) {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          var type;
          _this.apply_default_media_type_to_resource(resource[1]);
          if (_this.has_property(resource[1], 'type')) {
            type = _this.get_property(resource[1], 'type');
            _this.apply_type(resourceUri + resource[0].value, resource, type);
          }
          return _this.apply_types(resource[1], resourceUri + resource[0].value);
        });
      } else {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          return _this.apply_default_media_type_to_resource(resource[1]);
        });
      }
    };

    ResourceTypes.prototype.apply_type = function(resourceUri, resource, typeKey) {
      var tempType;
      tempType = this.resolve_inheritance_chain(resourceUri, typeKey);
      tempType.combine(resource[1]);
      resource[1] = tempType;
      return resource[1].remove_question_mark_properties();
    };

    ResourceTypes.prototype.resolve_inheritance_chain = function(resourceUri, typeKey) {
      var baseType, childType, childTypeName, childTypeProperty, compiledTypes, inheritsFrom, parentType, parentTypeName, pathToCircularRef, result, rootType, typesToApply;
      childTypeName = this.key_or_value(typeKey);
      childType = this.apply_parameters_to_type(resourceUri, childTypeName, typeKey);
      typesToApply = [childTypeName];
      compiledTypes = {};
      compiledTypes[childTypeName] = childType;
      this.apply_default_media_type_to_resource(childType);
      this.apply_traits_to_resource(resourceUri, childType, false);
      while (this.has_property(childType, 'type')) {
        typeKey = this.get_property(childType, 'type');
        parentTypeName = this.key_or_value(typeKey);
        if (parentTypeName in compiledTypes) {
          pathToCircularRef = typesToApply.concat(parentTypeName).join(' -> ');
          childTypeProperty = this.get_type(childTypeName)[0];
          throw new exports.ResourceTypeError('while applying resourceTypes', null, "circular reference of \"" + parentTypeName + "\" has been detected: " + pathToCircularRef, childTypeProperty.start_mark);
        }
        parentType = this.apply_parameters_to_type(resourceUri, parentTypeName, typeKey);
        this.apply_default_media_type_to_resource(parentType);
        this.apply_traits_to_resource(resourceUri, parentType, false);
        childTypeName = parentTypeName;
        childType = parentType;
        compiledTypes[childTypeName] = childType;
        typesToApply.push(childTypeName);
      }
      rootType = typesToApply.pop();
      baseType = compiledTypes[rootType].cloneForResourceType();
      result = baseType;
      while (inheritsFrom = typesToApply.pop()) {
        baseType = compiledTypes[inheritsFrom].cloneForResourceType();
        result.combine(baseType);
      }
      return result;
    };

    ResourceTypes.prototype.apply_parameters_to_type = function(resourceUri, typeName, typeKey) {
      var parameters, type;
      if (!(typeName != null ? typeName.trim() : void 0)) {
        throw new exports.ResourceTypeError('while applying resource type', null, 'resource type name must be provided', typeKey.start_mark);
      }
      if (!(type = this.get_type(typeName))) {
        throw new exports.ResourceTypeError('while applying resource type', null, "there is no resource type named " + typeName, typeKey.start_mark);
      }
      type = type[1].clone();
      parameters = this._get_parameters_from_type_key(resourceUri, typeKey);
      this.apply_parameters(type, parameters, typeKey);
      return type;
    };

    ResourceTypes.prototype._get_parameters_from_type_key = function(resourceUri, typeKey) {
      var parameter, parameters, reserved, result, _i, _len, _ref1;
      result = {};
      reserved = {
        resourcePath: resourceUri.replace(/\/\/*/g, '/'),
        resourcePathName: this.extractResourcePathName(resourceUri)
      };
      if (util.isMapping(typeKey)) {
        parameters = this.value_or_undefined(typeKey);
        if (util.isMapping(parameters[0][1])) {
          _ref1 = parameters[0][1].value;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            parameter = _ref1[_i];
            if (parameter[0].value in reserved) {
              throw new exports.ResourceTypeError('while applying parameters', null, "invalid parameter name: " + parameter[0].value + " is reserved", parameter[0].start_mark);
            }
            result[parameter[0].value] = parameter[1].value;
          }
        }
      }
      return util.extend(result, reserved);
    };

    return ResourceTypes;

  })();

}).call(this);

},{"./errors":30,"./nodes":34,"./util":47}],41:[function(require,module,exports){
(function() {
  var MarkedYAMLError, SimpleKey, tokens, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  tokens = require('./tokens');

  util = require('./util');

  /*
  The Scanner throws these.
  */


  this.ScannerError = (function(_super) {
    __extends(ScannerError, _super);

    function ScannerError() {
      _ref = ScannerError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ScannerError;

  })(MarkedYAMLError);

  /*
  Represents a possible simple key.
  */


  SimpleKey = (function() {
    function SimpleKey(token_number, required, index, line, column, mark) {
      this.token_number = token_number;
      this.required = required;
      this.index = index;
      this.line = line;
      this.column = column;
      this.mark = mark;
    }

    return SimpleKey;

  })();

  /*
  The Scanner class deals with converting a YAML stream into a token stream.
  */


  this.Scanner = (function() {
    var C_LB, C_NUMBERS, C_WS, ESCAPE_CODES, ESCAPE_REPLACEMENTS, RAML_VERSION, RAML_VERSION_RE;

    C_LB = '\r\n\x85\u2028\u2029';

    C_WS = '\t ';

    C_NUMBERS = '0123456789';

    ESCAPE_REPLACEMENTS = {
      '0': '\x00',
      'a': '\x07',
      'b': '\x08',
      't': '\x09',
      '\t': '\x09',
      'n': '\x0A',
      'v': '\x0B',
      'f': '\x0C',
      'r': '\x0D',
      'e': '\x1B',
      ' ': '\x20',
      '"': '"',
      '\\': '\\',
      'N': '\x85',
      '_': '\xA0',
      'L': '\u2028',
      'P': '\u2029'
    };

    ESCAPE_CODES = {
      'x': 2,
      'u': 4,
      'U': 8
    };

    RAML_VERSION = '#%RAML 0.8';

    RAML_VERSION_RE = /^#%RAML .+$/;

    /*
    Initialise the Scanner
    */


    function Scanner(settings) {
      this.settings = settings;
      this.done = false;
      this.ramlHeaderFound = !this.settings.validate;
      this.flow_level = 0;
      this.tokens = [];
      this.fetch_stream_start();
      this.tokens_taken = 0;
      this.indent = -1;
      this.indents = [];
      this.allow_simple_key = true;
      this.possible_simple_keys = {};
    }

    /*
    Check if the next token is one of the given types.
    */


    Scanner.prototype.check_token = function() {
      var choice, choices, _i, _len;
      choices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        if (choices.length === 0) {
          return true;
        }
        for (_i = 0, _len = choices.length; _i < _len; _i++) {
          choice = choices[_i];
          if (this.tokens[0] instanceof choice) {
            return true;
          }
        }
      }
      return false;
    };

    /*
    Return the next token, but do not delete it from the queue.
    */


    Scanner.prototype.peek_token = function() {
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        return this.tokens[0];
      }
    };

    /*
    Return the next token, and remove it from the queue.
    */


    Scanner.prototype.get_token = function() {
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        this.tokens_taken++;
        return this.tokens.shift();
      }
    };

    Scanner.prototype.need_more_tokens = function() {
      if (this.done) {
        return false;
      }
      if (this.tokens.length === 0) {
        return true;
      }
      this.stale_possible_simple_keys();
      if (this.next_possible_simple_key() === this.tokens_taken) {
        return true;
      }
      return false;
    };

    Scanner.prototype.fetch_more_tokens = function() {
      var char;
      this.scan_to_next_token();
      this.stale_possible_simple_keys();
      this.unwind_indent(this.column);
      char = this.peek();
      if (char === '\x00') {
        return this.fetch_stream_end();
      }
      if (char === '%' && this.check_directive()) {
        return this.fetch_directive();
      }
      if (char === '-' && this.check_document_start()) {
        return this.fetch_document_start();
      }
      if (char === '.' && this.check_document_end()) {
        return this.fetch_document_end();
      }
      if (char === '[') {
        return this.fetch_flow_sequence_start();
      }
      if (char === '{') {
        return this.fetch_flow_mapping_start();
      }
      if (char === ']') {
        return this.fetch_flow_sequence_end();
      }
      if (char === '}') {
        return this.fetch_flow_mapping_end();
      }
      if (char === ',') {
        return this.fetch_flow_entry();
      }
      if (char === '-' && this.check_block_entry()) {
        return this.fetch_block_entry();
      }
      if (char === '?' && this.check_key()) {
        return this.fetch_key();
      }
      if (char === ':' && this.check_value()) {
        return this.fetch_value();
      }
      if (char === '*') {
        return this.fetch_alias();
      }
      if (char === '&') {
        return this.fetch_anchor();
      }
      if (char === '!') {
        return this.fetch_tag();
      }
      if (char === '|' && this.flow_level === 0) {
        return this.fetch_literal();
      }
      if (char === '>' && this.flow_level === 0) {
        return this.fetch_folded();
      }
      if (char === '\'') {
        return this.fetch_single();
      }
      if (char === '"') {
        return this.fetch_double();
      }
      if (this.check_plain()) {
        return this.fetch_plain();
      }
      throw new exports.ScannerError('while scanning for the next token', null, "found character " + char + " that cannot start any token", this.get_mark());
    };

    /*
    Return the number of the nearest possible simple key.
    */


    Scanner.prototype.next_possible_simple_key = function() {
      var key, level, min_token_number, _ref1;
      min_token_number = null;
      _ref1 = this.possible_simple_keys;
      for (level in _ref1) {
        if (!__hasProp.call(_ref1, level)) continue;
        key = _ref1[level];
        if (min_token_number === null || key.token_number < min_token_number) {
          min_token_number = key.token_number;
        }
      }
      return min_token_number;
    };

    /*
    Remove entries that are no longer possible simple keys.  According to the
    YAML spec, simple keys:
      should be limited to a single line
      should be no longer than 1024 characters
    Disabling this procedure will allow simple keys of any length and height
    (may cause problems if indentation is broken though).
    */


    Scanner.prototype.stale_possible_simple_keys = function() {
      var key, level, _ref1, _results;
      _ref1 = this.possible_simple_keys;
      _results = [];
      for (level in _ref1) {
        if (!__hasProp.call(_ref1, level)) continue;
        key = _ref1[level];
        if (key.line === this.line && this.index - key.index <= 1024) {
          continue;
        }
        if (!key.required) {
          _results.push(delete this.possible_simple_keys[level]);
        } else {
          throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \':\'', this.get_mark());
        }
      }
      return _results;
    };

    /*
    The next token may start a simple key.  We check if it's possible and save
    its position.  This function is called for ALIAS, ANCHOR, TAG,
    SCALAR (flow),'[' and '{'.
    */


    Scanner.prototype.save_possible_simple_key = function() {
      var required, token_number;
      required = this.flow_level === 0 && this.indent === this.column;
      if (required && !this.allow_simple_key) {
        throw new Error('logic failure');
      }
      if (!this.allow_simple_key) {
        return;
      }
      this.remove_possible_simple_key();
      token_number = this.tokens_taken + this.tokens.length;
      return this.possible_simple_keys[this.flow_level] = new SimpleKey(token_number, required, this.index, this.line, this.column, this.get_mark());
    };

    /*
    Remove the saved possible simple key at the current flow level.
    */


    Scanner.prototype.remove_possible_simple_key = function() {
      var key;
      if (!(key = this.possible_simple_keys[this.flow_level])) {
        return;
      }
      if (!key.required) {
        return delete this.possible_simple_keys[this.flow_level];
      } else {
        throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \':\'', this.get_mark());
      }
    };

    /*
    In flow context, tokens should respect indentation.
    Actually the condition should be `self.indent >= column` according to
    the spec. But this condition will prohibit intuitively correct
    constructions such as
      key : {
      }
    */


    Scanner.prototype.unwind_indent = function(column) {
      var mark, _results;
      if (this.flow_level !== 0) {
        return;
      }
      _results = [];
      while (this.indent > column) {
        mark = this.get_mark();
        this.indent = this.indents.pop();
        _results.push(this.tokens.push(new tokens.BlockEndToken(mark, mark)));
      }
      return _results;
    };

    /*
    Check if we need to increase indentation.
    */


    Scanner.prototype.add_indent = function(column) {
      if (!(column > this.indent)) {
        return false;
      }
      this.indents.push(this.indent);
      this.indent = column;
      return true;
    };

    Scanner.prototype.fetch_stream_start = function() {
      var mark;
      mark = this.get_mark();
      return this.tokens.push(new tokens.StreamStartToken(mark, mark, this.encoding));
    };

    Scanner.prototype.fetch_stream_end = function() {
      var mark;
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_possible_simple_key = false;
      this.possible_simple_keys = {};
      mark = this.get_mark();
      this.tokens.push(new tokens.StreamEndToken(mark, mark));
      return this.done = true;
    };

    Scanner.prototype.fetch_directive = function() {
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_directive());
    };

    Scanner.prototype.fetch_document_start = function() {
      return this.fetch_document_indicator(tokens.DocumentStartToken);
    };

    Scanner.prototype.fetch_document_end = function() {
      return this.fetch_document_indicator(tokens.DocumentEndToken);
    };

    Scanner.prototype.fetch_document_indicator = function(TokenClass) {
      var start_mark;
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_simple_key = false;
      start_mark = this.get_mark();
      this.forward(3);
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_sequence_start = function() {
      return this.fetch_flow_collection_start(tokens.FlowSequenceStartToken);
    };

    Scanner.prototype.fetch_flow_mapping_start = function() {
      return this.fetch_flow_collection_start(tokens.FlowMappingStartToken);
    };

    Scanner.prototype.fetch_flow_collection_start = function(TokenClass) {
      var start_mark;
      this.save_possible_simple_key();
      this.flow_level++;
      this.allow_simple_key = true;
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_sequence_end = function() {
      return this.fetch_flow_collection_end(tokens.FlowSequenceEndToken);
    };

    Scanner.prototype.fetch_flow_mapping_end = function() {
      return this.fetch_flow_collection_end(tokens.FlowMappingEndToken);
    };

    Scanner.prototype.fetch_flow_collection_end = function(TokenClass) {
      var start_mark;
      this.remove_possible_simple_key();
      this.flow_level--;
      this.allow_simple_key = false;
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_entry = function() {
      var start_mark;
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.FlowEntryToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_block_entry = function() {
      var mark, start_mark;
      if (this.flow_level === 0) {
        if (!this.allow_simple_key) {
          throw new exports.ScannerError(null, null, 'sequence entries are not allowed here', this.get_mark());
        }
        if (this.add_indent(this.column)) {
          mark = this.get_mark();
          this.tokens.push(new tokens.BlockSequenceStartToken(mark, mark));
        }
      }
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.BlockEntryToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_key = function() {
      var mark, start_mark;
      if (this.flow_level === 0) {
        if (!this.allow_simple_key) {
          throw new exports.ScannerError(null, null, 'mapping keys are not allowed here', this.get_mark());
        }
        if (this.add_indent(this.column)) {
          mark = this.get_mark();
          this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));
        }
      }
      this.allow_simple_key = !this.flow_level;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.KeyToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_value = function() {
      var key, mark, start_mark;
      if (key = this.possible_simple_keys[this.flow_level]) {
        delete this.possible_simple_keys[this.flow_level];
        this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.KeyToken(key.mark, key.mark));
        if (this.flow_level === 0) {
          if (this.add_indent(key.column)) {
            this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.BlockMappingStartToken(key.mark, key.mark));
          }
        }
        this.allow_simple_key = false;
      } else {
        if (this.flow_level === 0) {
          if (!this.allow_simple_key) {
            throw new exports.ScannerError(null, null, 'mapping values are not allowed here', this.get_mark());
          }
          if (this.add_indent(this.column)) {
            mark = this.get_mark();
            this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));
          }
        }
        this.allow_simple_key = !this.flow_level;
        this.remove_possible_simple_key();
      }
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.ValueToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_alias = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_anchor(tokens.AliasToken));
    };

    Scanner.prototype.fetch_anchor = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_anchor(tokens.AnchorToken));
    };

    Scanner.prototype.fetch_tag = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_tag());
    };

    Scanner.prototype.fetch_literal = function() {
      return this.fetch_block_scalar('|');
    };

    Scanner.prototype.fetch_folded = function() {
      return this.fetch_block_scalar('>');
    };

    Scanner.prototype.fetch_block_scalar = function(style) {
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      return this.tokens.push(this.scan_block_scalar(style));
    };

    Scanner.prototype.fetch_single = function() {
      return this.fetch_flow_scalar('\'');
    };

    Scanner.prototype.fetch_double = function() {
      return this.fetch_flow_scalar('"');
    };

    Scanner.prototype.fetch_flow_scalar = function(style) {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_flow_scalar(style));
    };

    Scanner.prototype.fetch_plain = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_plain());
    };

    /*
    DIRECTIVE: ^ '%'
    */


    Scanner.prototype.check_directive = function() {
      if (this.column === 0) {
        return true;
      }
      return false;
    };

    /*
    DOCUMENT-START: ^ '---' (' '|'\n')
    */


    Scanner.prototype.check_document_start = function() {
      var _ref1;
      if (this.column === 0 && this.prefix(3) === '---' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
        return true;
      }
      return false;
    };

    /*
    DOCUMENT-END: ^ '...' (' '|'\n')
    */


    Scanner.prototype.check_document_end = function() {
      var _ref1;
      if (this.column === 0 && this.prefix(3) === '...' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
        return true;
      }
      return false;
    };

    /*
    BLOCK-ENTRY: '-' (' '|'\n')
    */


    Scanner.prototype.check_block_entry = function() {
      var _ref1;
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    KEY (flow context):  '?'
    KEY (block context): '?' (' '|'\n')
    */


    Scanner.prototype.check_key = function() {
      var _ref1;
      if (this.flow_level !== 0) {
        return true;
      }
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    VALUE (flow context):  ':'
    VALUE (block context): ':' (' '|'\n')
    */


    Scanner.prototype.check_value = function() {
      var _ref1;
      if (this.flow_level !== 0) {
        return true;
      }
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    A plain scalar may start with any non-space character except:
      '-', '?', ':', ',', '[', ']', '{', '}',
      '#', '&', '*', '!', '|', '>', '\'', '"',
      '%', '@', '`'.
    
    It may also start with
      '-', '?', ':'
    if it is followed by a non-space character.
    
    Note that we limit the last rule to the block context (except the '-'
    character) because we want the flow context to be space independent.
    */


    Scanner.prototype.check_plain = function() {
      var char, _ref1;
      char = this.peek();
      return __indexOf.call(C_LB + C_WS + '\x00-?:,[]{}#&*!|>\'"%@`', char) < 0 || ((_ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) < 0) && (char === '-' || (this.flow_level === 0 && __indexOf.call('?:', char) >= 0)));
    };

    /*
    We ignore spaces, line breaks and comments.
    If we find a line break in the block context, we set the flag
    `allow_simple_key` on.
    The byte order mark is stripped if it's the first character in the stream.
    We do not yet support BOM inside the stream as the specification requires.
    Any such mark will be considered as a part of the document.
    
    TODO: We need to make tab handling rules more sane.  A good rule is
      Tabs cannot precede tokens BLOCK-SEQUENCE-START, BLOCK-MAPPING-START,
      BLOCK-END, KEY (block context), VALUE (block context), BLOCK-ENTRY
    So the tab checking code is
      @allow_simple_key = off if <TAB>
    We also need to add the check for `allow_simple_key is on` to
    `unwind_indent` before issuing BLOCK-END.  Scanners for block, flow and
    plain scalars need to be modified.
    */


    Scanner.prototype.scan_to_next_token = function() {
      var comment, found, trimmedComment, _ref1, _results;
      if (this.index === 0 && this.peek() === '\uFEFF') {
        this.forward();
      }
      found = false;
      _results = [];
      while (!found) {
        while (this.peek() === ' ') {
          this.forward();
        }
        comment = '';
        if (this.peek() === '#') {
          while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
            if (!this.ramlHeaderFound) {
              comment += this.peek();
            }
            this.forward();
          }
        }
        if (!this.ramlHeaderFound) {
          trimmedComment = comment.trim();
          if (trimmedComment && RAML_VERSION_RE.test(trimmedComment)) {
            if (trimmedComment === RAML_VERSION) {
              this.ramlHeaderFound = true;
            } else {
              throw new exports.ScannerError('version validation', null, "Unsupported RAML version: '" + comment + "'", this.create_mark(0, 0));
            }
          } else {
            throw new exports.ScannerError('version validation', null, "The first line must be: '" + RAML_VERSION + "'", this.create_mark(0, 0));
          }
        }
        if (this.scan_line_break()) {
          if (this.flow_level === 0) {
            _results.push(this.allow_simple_key = true);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(found = true);
        }
      }
      return _results;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive = function() {
      var end_mark, name, start_mark, value, _ref1;
      start_mark = this.get_mark();
      this.forward();
      name = this.scan_directive_name(start_mark);
      value = null;
      if (name === 'YAML') {
        value = this.scan_yaml_directive_value(start_mark);
        end_mark = this.get_mark();
      } else if (name === 'TAG') {
        value = this.scan_tag_directive_value(start_mark);
        end_mark = this.get_mark();
      } else {
        end_mark = this.get_mark();
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      this.scan_directive_ignored_line(start_mark);
      return new tokens.DirectiveToken(name, value, start_mark, end_mark);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive_name = function(start_mark) {
      var char, length, value;
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
        length++;
        char = this.peek(length);
      }
      if (length === 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected alphanumeric or numeric character but found " + char, this.get_mark());
      }
      value = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected alphanumeric or numeric character but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_yaml_directive_value = function(start_mark) {
      var major, minor, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      major = this.scan_yaml_directive_number(start_mark);
      if (this.peek() !== '.') {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit or '.' but found " + (this.peek()), this.get_mark());
      }
      this.forward();
      minor = this.scan_yaml_directive_number(start_mark);
      if (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00 ', _ref1) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit or ' ' but found " + (this.peek()), this.get_mark());
      }
      return [major, minor];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_yaml_directive_number = function(start_mark) {
      var char, length, value, _ref1;
      char = this.peek();
      if (!(('0' <= char && char <= '9'))) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit but found " + char, this.get_mark());
      }
      length = 0;
      while (('0' <= (_ref1 = this.peek(length)) && _ref1 <= '9')) {
        length++;
      }
      value = parseInt(this.prefix(length));
      this.forward(length);
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_value = function(start_mark) {
      var handle, prefix;
      while (this.peek() === ' ') {
        this.forward();
      }
      handle = this.scan_tag_directive_handle(start_mark);
      while (this.peek() === ' ') {
        this.forward();
      }
      prefix = this.scan_tag_directive_prefix(start_mark);
      return [handle, prefix];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_handle = function(start_mark) {
      var char, value;
      value = this.scan_tag_handle('directive', start_mark);
      char = this.peek();
      if (char !== ' ') {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_prefix = function(start_mark) {
      var char, value;
      value = this.scan_tag_uri('directive', start_mark);
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive_ignored_line = function(start_mark) {
      var char, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      if (this.peek() === '#') {
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a comment or a line break but found " + char, this.get_mark());
      }
      return this.scan_line_break();
    };

    /*
    The specification does not restrict characters for anchors and aliases.
    This may lead to problems, for instance, the document:
      [ *alias, value ]
    can be interpteted in two ways, as
      [ "value" ]
    and
      [ *alias , "value" ]
    Therefore we restrict aliases to numbers and ASCII letters.
    */


    Scanner.prototype.scan_anchor = function(TokenClass) {
      var char, indicator, length, name, start_mark, value;
      start_mark = this.get_mark();
      indicator = this.peek();
      if (indicator === '*') {
        name = 'alias';
      } else {
        name = 'anchor';
      }
      this.forward();
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
        length++;
        char = this.peek(length);
      }
      if (length === 0) {
        throw new exports.ScannerError("while scanning an " + name, start_mark, "expected alphabetic or numeric character but found '" + char + "'", this.get_mark());
      }
      value = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB + C_WS + '\x00' + '?:,]}%@`', char) < 0) {
        throw new exports.ScannerError("while scanning an " + name, start_mark, "expected alphabetic or numeric character but found '" + char + "'", this.get_mark());
      }
      return new TokenClass(value, start_mark, this.get_mark());
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag = function() {
      var char, handle, length, start_mark, suffix, use_handle;
      start_mark = this.get_mark();
      char = this.peek(1);
      if (char === '<') {
        handle = null;
        this.forward(2);
        suffix = this.scan_tag_uri('tag', start_mark);
        if (this.peek() !== '>') {
          throw new exports.ScannerError('while parsing a tag', start_mark, "expected '>' but found " + (this.peek()), this.get_mark());
        }
        this.forward();
      } else if (__indexOf.call(C_LB + C_WS + '\x00', char) >= 0) {
        handle = null;
        suffix = '!';
        this.forward();
      } else {
        length = 1;
        use_handle = false;
        while (__indexOf.call(C_LB + '\x00 ', char) < 0) {
          if (char === '!') {
            use_handle = true;
            break;
          }
          length++;
          char = this.peek(length);
        }
        if (use_handle) {
          handle = this.scan_tag_handle('tag', start_mark);
        } else {
          handle = '!';
          this.forward();
        }
        suffix = this.scan_tag_uri('tag', start_mark);
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a tag', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return new tokens.TagToken([handle, suffix], start_mark, this.get_mark());
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar = function(style) {
      var breaks, chomping, chunks, end_mark, folded, increment, indent, leading_non_space, length, line_break, max_indent, min_indent, start_mark, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      folded = style === '>';
      chunks = [];
      start_mark = this.get_mark();
      this.forward();
      _ref1 = this.scan_block_scalar_indicators(start_mark), chomping = _ref1[0], increment = _ref1[1];
      this.scan_block_scalar_ignored_line(start_mark);
      min_indent = this.indent + 1;
      if (min_indent < 1) {
        min_indent = 1;
      }
      if (increment == null) {
        _ref2 = this.scan_block_scalar_indentation(), breaks = _ref2[0], max_indent = _ref2[1], end_mark = _ref2[2];
        indent = Math.max(min_indent, max_indent);
      } else {
        indent = min_indent + increment - 1;
        _ref3 = this.scan_block_scalar_breaks(indent), breaks = _ref3[0], end_mark = _ref3[1];
      }
      line_break = '';
      while (this.column === indent && this.peek() !== '\x00') {
        chunks = chunks.concat(breaks);
        leading_non_space = (_ref4 = this.peek(), __indexOf.call(' \t', _ref4) < 0);
        length = 0;
        while (_ref5 = this.peek(length), __indexOf.call(C_LB + '\x00', _ref5) < 0) {
          length++;
        }
        chunks.push(this.prefix(length));
        this.forward(length);
        line_break = this.scan_line_break();
        _ref6 = this.scan_block_scalar_breaks(indent), breaks = _ref6[0], end_mark = _ref6[1];
        if (this.column === indent && this.peek() !== '\x00') {
          if (folded && line_break === '\n' && leading_non_space && (_ref7 = this.peek(), __indexOf.call(' \t', _ref7) < 0)) {
            if (util.is_empty(breaks)) {
              chunks.push(' ');
            }
          } else {
            chunks.push(line_break);
          }
        } else {
          break;
        }
      }
      if (chomping !== false) {
        chunks.push(line_break);
      }
      if (chomping === true) {
        chunks = chunks.concat(breaks);
      }
      return new tokens.ScalarToken(chunks.join(''), false, start_mark, end_mark, style);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_indicators = function(start_mark) {
      var char, chomping, increment;
      chomping = null;
      increment = null;
      char = this.peek();
      if (__indexOf.call('+-', char) >= 0) {
        chomping = char === '+';
        this.forward();
        char = this.peek();
        if (__indexOf.call(C_NUMBERS, char) >= 0) {
          increment = parseInt(char);
          if (increment === 0) {
            throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());
          }
          this.forward();
        }
      } else if (__indexOf.call(C_NUMBERS, char) >= 0) {
        increment = parseInt(char);
        if (increment === 0) {
          throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());
        }
        this.forward();
        char = this.peek();
        if (__indexOf.call('+-', char) >= 0) {
          chomping = char === '+';
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a block scalar', start_mark, "expected chomping or indentation indicators, but found " + char, this.get_mark());
      }
      return [chomping, increment];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_ignored_line = function(start_mark) {
      var char, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      if (this.peek() === '#') {
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00', char) < 0) {
        throw new exports.ScannerError('while scanning a block scalar', start_mark, "expected a comment or a line break but found " + char, this.get_mark());
      }
      return this.scan_line_break();
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_indentation = function() {
      var chunks, end_mark, max_indent, _ref1;
      chunks = [];
      max_indent = 0;
      end_mark = this.get_mark();
      while (_ref1 = this.peek(), __indexOf.call(C_LB + ' ', _ref1) >= 0) {
        if (this.peek() !== ' ') {
          chunks.push(this.scan_line_break());
          end_mark = this.get_mark();
        } else {
          this.forward();
          if (this.column > max_indent) {
            max_indent = this.column;
          }
        }
      }
      return [chunks, max_indent, end_mark];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_breaks = function(indent) {
      var chunks, end_mark, _ref1;
      chunks = [];
      end_mark = this.get_mark();
      while (this.column < indent && this.peek() === ' ') {
        this.forward();
      }
      while (_ref1 = this.peek(), __indexOf.call(C_LB, _ref1) >= 0) {
        chunks.push(this.scan_line_break());
        end_mark = this.get_mark();
        while (this.column < indent && this.peek() === ' ') {
          this.forward();
        }
      }
      return [chunks, end_mark];
    };

    /*
    See the specification for details.
    Note that we loose indentation rules for quoted scalars. Quoted scalars
    don't need to adhere indentation because " and ' clearly mark the beginning
    and the end of them. Therefore we are less restrictive than the
    specification requires. We only need to check that document separators are
    not included in scalars.
    */


    Scanner.prototype.scan_flow_scalar = function(style) {
      var chunks, double, quote, start_mark;
      double = style === '"';
      chunks = [];
      start_mark = this.get_mark();
      quote = this.peek();
      this.forward();
      chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));
      while (this.peek() !== quote) {
        chunks = chunks.concat(this.scan_flow_scalar_spaces(double, start_mark));
        chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));
      }
      this.forward();
      return new tokens.ScalarToken(chunks.join(''), false, start_mark, this.get_mark(), style);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_non_spaces = function(double, start_mark) {
      var char, chunks, code, k, length, _i, _ref1, _ref2;
      chunks = [];
      while (true) {
        length = 0;
        while (_ref1 = this.peek(length), __indexOf.call(C_LB + C_WS + '\'"\\\x00', _ref1) < 0) {
          length++;
        }
        if (length !== 0) {
          chunks.push(this.prefix(length));
          this.forward(length);
        }
        char = this.peek();
        if (!double && char === '\'' && this.peek(1) === '\'') {
          chunks.push('\'');
          this.forward(2);
        } else if ((double && char === '\'') || (!double && __indexOf.call('"\\', char) >= 0)) {
          chunks.push(char);
          this.forward();
        } else if (double && char === '\\') {
          this.forward();
          char = this.peek();
          if (char in ESCAPE_REPLACEMENTS) {
            chunks.push(ESCAPE_REPLACEMENTS[char]);
            this.forward();
          } else if (char in ESCAPE_CODES) {
            length = ESCAPE_CODES[char];
            this.forward();
            for (k = _i = 0; 0 <= length ? _i < length : _i > length; k = 0 <= length ? ++_i : --_i) {
              if (_ref2 = this.peek(k), __indexOf.call(C_NUMBERS + 'ABCDEFabcdef', _ref2) < 0) {
                throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, "expected escape sequence of " + length + " hexadecimal numbers, but found " + (this.peek(k)), this.get_mark());
              }
            }
            code = parseInt(this.prefix(length), 16);
            chunks.push(String.fromCharCode(code));
            this.forward(length);
          } else if (__indexOf.call(C_LB, char) >= 0) {
            this.scan_line_break();
            chunks = chunks.concat(this.scan_flow_scalar_breaks(double, start_mark));
          } else {
            throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, "found unknown escape character " + char, this.get_mark());
          }
        } else {
          return chunks;
        }
      }
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_spaces = function(double, start_mark) {
      var breaks, char, chunks, length, line_break, whitespaces, _ref1;
      chunks = [];
      length = 0;
      while (_ref1 = this.peek(length), __indexOf.call(C_WS, _ref1) >= 0) {
        length++;
      }
      whitespaces = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (char === '\x00') {
        throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected end of stream', this.get_mark());
      }
      if (__indexOf.call(C_LB, char) >= 0) {
        line_break = this.scan_line_break();
        breaks = this.scan_flow_scalar_breaks(double, start_mark);
        if (line_break !== '\n') {
          chunks.push(line_break);
        } else if (!breaks) {
          chunks.push(' ');
        }
        chunks = chunks.concat(breaks);
      } else {
        chunks.push(whitespaces);
      }
      return chunks;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_breaks = function(double, start_mark) {
      var chunks, prefix, _ref1, _ref2, _ref3;
      chunks = [];
      while (true) {
        prefix = this.prefix(3);
        if (prefix === '---' || prefix === '...' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
          throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected document separator', this.get_mark());
        }
        while (_ref2 = this.peek(), __indexOf.call(C_WS, _ref2) >= 0) {
          this.forward();
        }
        if (_ref3 = this.peek(), __indexOf.call(C_LB, _ref3) >= 0) {
          chunks.push(this.scan_line_break());
        } else {
          return chunks;
        }
      }
    };

    /*
    See the specification for details.
    We add an additional restriction for the flow context:
      plain scalars in the flow context cannot contain ',', ':' and '?'.
    We also keep track of the `allow_simple_key` flag here.
    Indentation rules are loosed for the flow context.
    */


    Scanner.prototype.scan_plain = function() {
      var char, chunks, end_mark, indent, length, spaces, start_mark, _ref1, _ref2;
      chunks = [];
      start_mark = end_mark = this.get_mark();
      indent = this.indent + 1;
      spaces = [];
      while (true) {
        length = 0;
        if (this.peek() === '#') {
          break;
        }
        while (true) {
          char = this.peek(length);
          if (__indexOf.call(C_LB + C_WS + '\x00', char) >= 0 || (this.flow_level === 0 && char === ':' && (_ref1 = this.peek(length + 1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) || (this.flow_level !== 0 && __indexOf.call(',:?[]{}', char) >= 0)) {
            break;
          }
          length++;
        }
        if (this.flow_level !== 0 && char === ':' && (_ref2 = this.peek(length + 1), __indexOf.call(C_LB + C_WS + '\x00,[]{}', _ref2) < 0)) {
          this.forward(length);
          throw new exports.ScannerError('while scanning a plain scalar', start_mark, 'found unexpected \':\'', this.get_mark(), 'Please check http://pyyaml.org/wiki/YAMLColonInFlowContext');
        }
        if (length === 0) {
          break;
        }
        this.allow_simple_key = false;
        chunks = chunks.concat(spaces);
        chunks.push(this.prefix(length));
        this.forward(length);
        end_mark = this.get_mark();
        spaces = this.scan_plain_spaces(indent, start_mark);
        if ((spaces == null) || spaces.length === 0 || this.peek() === '#' || (this.flow_level === 0 && this.column < indent)) {
          break;
        }
      }
      return new tokens.ScalarToken(chunks.join(''), true, start_mark, end_mark);
    };

    /*
    See the specification for details.
    The specification is really confusing about tabs in plain scalars.
    We just forbid them completely. Do not use tabs in YAML!
    */


    Scanner.prototype.scan_plain_spaces = function(indent, start_mark) {
      var breaks, char, chunks, length, line_break, prefix, whitespaces, _ref1, _ref2;
      chunks = [];
      length = 0;
      while (_ref1 = this.peek(length), __indexOf.call(' ', _ref1) >= 0) {
        length++;
      }
      whitespaces = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB, char) >= 0) {
        line_break = this.scan_line_break();
        this.allow_simple_key = true;
        prefix = this.prefix(3);
        if (prefix === '---' || prefix === '...' && this.peek(__indexOf.call(C_LB + C_WS + '\x00', 3) >= 0)) {
          return;
        }
        breaks = [];
        while (_ref2 = this.peek(), __indexOf.call(C_LB + ' ', _ref2) >= 0) {
          if (this.peek() === ' ') {
            this.forward();
          } else {
            breaks.push(this.scan_line_break());
            prefix = this.prefix(3);
            if (prefix === '---' || prefix === '...' && this.peek(__indexOf.call(C_LB + C_WS + '\x00', 3) >= 0)) {
              return;
            }
          }
        }
        if (line_break !== '\n') {
          chunks.push(line_break);
        } else if (breaks.length === 0) {
          chunks.push(' ');
        }
        chunks = chunks.concat(breaks);
      } else if (whitespaces) {
        chunks.push(whitespaces);
      }
      return chunks;
    };

    /*
    See the specification for details.
    For some strange reasons, the specification does not allow '_' in tag
    handles. I have allowed it anyway.
    */


    Scanner.prototype.scan_tag_handle = function(name, start_mark) {
      var char, length, value;
      char = this.peek();
      if (char !== '!') {
        throw new exports.ScannerError("while scanning a " + name, start_mark, "expected '!' but found " + char, this.get_mark());
      }
      length = 1;
      char = this.peek(length);
      if (char !== ' ') {
        while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
          length++;
          char = this.peek(length);
        }
        if (char !== '!') {
          this.forward(length);
          throw new exports.ScannerError("while scanning a " + name, start_mark, "expected '!' but found " + char, this.get_mark());
        }
        length++;
      }
      value = this.prefix(length);
      this.forward(length);
      return value;
    };

    /*
    See the specification for details.
    Note: we do not check if URI is well-formed.
    */


    Scanner.prototype.scan_tag_uri = function(name, start_mark) {
      var char, chunks, length;
      chunks = [];
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-;/?:@&=+$,_.!~*\'()[]%', char) >= 0) {
        if (char === '%') {
          chunks.push(this.prefix(length));
          this.forward(length);
          length = 0;
          chunks.push(this.scan_uri_escapes(name, start_mark));
        } else {
          length++;
        }
        char = this.peek(length);
      }
      if (length !== 0) {
        chunks.push(this.prefix(length));
        this.forward(length);
        length = 0;
      }
      if (chunks.length === 0) {
        throw new exports.ScannerError("while parsing a " + name, start_mark, "expected URI but found " + char, this.get_mark());
      }
      return chunks.join('');
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_uri_escapes = function(name, start_mark) {
      var bytes, k, mark, _i;
      bytes = [];
      mark = this.get_mark();
      while (this.peek() === '%') {
        this.forward();
        for (k = _i = 0; _i <= 2; k = ++_i) {
          throw new exports.ScannerError("while scanning a " + name, start_mark, "expected URI escape sequence of 2 hexadecimal numbers but found          " + (this.peek(k)), this.get_mark());
        }
        bytes.push(String.fromCharCode(parseInt(this.prefix(2), 16)));
        this.forward(2);
      }
      return bytes.join('');
    };

    /*
    Transforms:
      '\r\n'      :   '\n'
      '\r'        :   '\n'
      '\n'        :   '\n'
      '\x85'      :   '\n'
      '\u2028'    :   '\u2028'
      '\u2029     :   '\u2029'
      default     :   ''
    */


    Scanner.prototype.scan_line_break = function() {
      var char;
      char = this.peek();
      if (__indexOf.call('\r\n\x85', char) >= 0) {
        if (this.prefix(2) === '\r\n') {
          this.forward(2);
        } else {
          this.forward();
        }
        return '\n';
      } else if (__indexOf.call('\u2028\u2029', char) >= 0) {
        this.forward();
        return char;
      }
      return '';
    };

    return Scanner;

  })();

}).call(this);

},{"./errors":30,"./tokens":44,"./util":47}],42:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Schemas throws these.
  */


  this.SchemaError = (function(_super) {
    __extends(SchemaError, _super);

    function SchemaError() {
      _ref = SchemaError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return SchemaError;

  })(MarkedYAMLError);

  /*
    The Schemas class deals with applying schemas to resources according to the spec
  */


  this.Schemas = (function() {
    function Schemas() {
      this.get_schemas_used = __bind(this.get_schemas_used, this);
      this.apply_schemas = __bind(this.apply_schemas, this);
      this.get_all_schemas = __bind(this.get_all_schemas, this);
      this.has_schemas = __bind(this.has_schemas, this);
      this.load_schemas = __bind(this.load_schemas, this);
      this.declaredSchemas = {};
    }

    Schemas.prototype.load_schemas = function(node) {
      var allSchemas,
        _this = this;
      if (this.has_property(node, "schemas")) {
        allSchemas = this.property_value(node, 'schemas');
        if (allSchemas && typeof allSchemas === "object") {
          return allSchemas.forEach(function(schema_entry) {
            if (schema_entry && typeof schema_entry === "object" && typeof schema_entry.value === "object") {
              return schema_entry.value.forEach(function(schema) {
                return _this.declaredSchemas[schema[0].value] = schema;
              });
            }
          });
        }
      }
    };

    Schemas.prototype.has_schemas = function(node) {
      if (this.declaredSchemas.length === 0 && this.has_property(node, "schemas")) {
        this.load_schemas(node);
      }
      return Object.keys(this.declaredSchemas).length > 0;
    };

    Schemas.prototype.get_all_schemas = function() {
      return this.declaredSchemas;
    };

    Schemas.prototype.apply_schemas = function(node) {
      var resources, schemas,
        _this = this;
      resources = this.child_resources(node);
      schemas = this.get_schemas_used(resources);
      return schemas.forEach(function(schema) {
        if (schema[1].value in _this.declaredSchemas) {
          return schema[1].value = _this.declaredSchemas[schema[1].value][1].value;
        }
      });
    };

    Schemas.prototype.get_schemas_used = function(resources) {
      var schemas,
        _this = this;
      schemas = [];
      resources.forEach(function(resource) {
        var properties;
        properties = _this.get_properties(resource[1], "schema");
        return schemas = schemas.concat(properties);
      });
      return schemas;
    };

    return Schemas;

  })();

}).call(this);

},{"./errors":30,"./nodes":34}],43:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Schemas throws these.
  */


  this.SecuritySchemeError = (function(_super) {
    __extends(SecuritySchemeError, _super);

    /*
      The Schemas class deals with applying schemas to resources according to the spec
    */


    function SecuritySchemeError() {
      _ref = SecuritySchemeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return SecuritySchemeError;

  })(MarkedYAMLError);

  this.SecuritySchemes = (function() {
    function SecuritySchemes() {
      this.get_security_scheme = __bind(this.get_security_scheme, this);
      this.get_all_schemes = __bind(this.get_all_schemes, this);
      this.load_security_schemes = __bind(this.load_security_schemes, this);
      this.declaredSchemes = {};
    }

    SecuritySchemes.prototype.load_security_schemes = function(node) {
      var allschemes,
        _this = this;
      if (this.has_property(node, "securitySchemes")) {
        allschemes = this.property_value(node, 'securitySchemes');
        if (allschemes && typeof allschemes === "object") {
          return allschemes.forEach(function(scheme_entry) {
            if (scheme_entry.tag === 'tag:yaml.org,2002:map') {
              return scheme_entry.value.forEach(function(scheme) {
                return _this.declaredSchemes[scheme[0].value] = scheme[1].value;
              });
            }
          });
        }
      }
    };

    SecuritySchemes.prototype.get_all_schemes = function() {
      return this.declaredSchemes;
    };

    SecuritySchemes.prototype.get_security_scheme = function(schemaName) {
      return this.declaredSchemes[schemaName];
    };

    return SecuritySchemes;

  })();

}).call(this);

},{"./errors":30,"./nodes":34}],44:[function(require,module,exports){
(function() {
  var _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Token = (function() {
    function Token(start_mark, end_mark) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return Token;

  })();

  this.DirectiveToken = (function(_super) {
    __extends(DirectiveToken, _super);

    DirectiveToken.prototype.id = '<directive>';

    function DirectiveToken(name, value, start_mark, end_mark) {
      this.name = name;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return DirectiveToken;

  })(this.Token);

  this.DocumentStartToken = (function(_super) {
    __extends(DocumentStartToken, _super);

    function DocumentStartToken() {
      _ref = DocumentStartToken.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    DocumentStartToken.prototype.id = '<document start>';

    return DocumentStartToken;

  })(this.Token);

  this.DocumentEndToken = (function(_super) {
    __extends(DocumentEndToken, _super);

    function DocumentEndToken() {
      _ref1 = DocumentEndToken.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    DocumentEndToken.prototype.id = '<document end>';

    return DocumentEndToken;

  })(this.Token);

  this.StreamStartToken = (function(_super) {
    __extends(StreamStartToken, _super);

    StreamStartToken.prototype.id = '<stream start>';

    function StreamStartToken(start_mark, end_mark, encoding) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.encoding = encoding;
    }

    return StreamStartToken;

  })(this.Token);

  this.StreamEndToken = (function(_super) {
    __extends(StreamEndToken, _super);

    function StreamEndToken() {
      _ref2 = StreamEndToken.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    StreamEndToken.prototype.id = '<stream end>';

    return StreamEndToken;

  })(this.Token);

  this.BlockSequenceStartToken = (function(_super) {
    __extends(BlockSequenceStartToken, _super);

    function BlockSequenceStartToken() {
      _ref3 = BlockSequenceStartToken.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    BlockSequenceStartToken.prototype.id = '<block sequence start>';

    return BlockSequenceStartToken;

  })(this.Token);

  this.BlockMappingStartToken = (function(_super) {
    __extends(BlockMappingStartToken, _super);

    function BlockMappingStartToken() {
      _ref4 = BlockMappingStartToken.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    BlockMappingStartToken.prototype.id = '<block mapping end>';

    return BlockMappingStartToken;

  })(this.Token);

  this.BlockEndToken = (function(_super) {
    __extends(BlockEndToken, _super);

    function BlockEndToken() {
      _ref5 = BlockEndToken.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    BlockEndToken.prototype.id = '<block end>';

    return BlockEndToken;

  })(this.Token);

  this.FlowSequenceStartToken = (function(_super) {
    __extends(FlowSequenceStartToken, _super);

    function FlowSequenceStartToken() {
      _ref6 = FlowSequenceStartToken.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    FlowSequenceStartToken.prototype.id = '[';

    return FlowSequenceStartToken;

  })(this.Token);

  this.FlowMappingStartToken = (function(_super) {
    __extends(FlowMappingStartToken, _super);

    function FlowMappingStartToken() {
      _ref7 = FlowMappingStartToken.__super__.constructor.apply(this, arguments);
      return _ref7;
    }

    FlowMappingStartToken.prototype.id = '{';

    return FlowMappingStartToken;

  })(this.Token);

  this.FlowSequenceEndToken = (function(_super) {
    __extends(FlowSequenceEndToken, _super);

    function FlowSequenceEndToken() {
      _ref8 = FlowSequenceEndToken.__super__.constructor.apply(this, arguments);
      return _ref8;
    }

    FlowSequenceEndToken.prototype.id = ']';

    return FlowSequenceEndToken;

  })(this.Token);

  this.FlowMappingEndToken = (function(_super) {
    __extends(FlowMappingEndToken, _super);

    function FlowMappingEndToken() {
      _ref9 = FlowMappingEndToken.__super__.constructor.apply(this, arguments);
      return _ref9;
    }

    FlowMappingEndToken.prototype.id = '}';

    return FlowMappingEndToken;

  })(this.Token);

  this.KeyToken = (function(_super) {
    __extends(KeyToken, _super);

    function KeyToken() {
      _ref10 = KeyToken.__super__.constructor.apply(this, arguments);
      return _ref10;
    }

    KeyToken.prototype.id = '?';

    return KeyToken;

  })(this.Token);

  this.ValueToken = (function(_super) {
    __extends(ValueToken, _super);

    function ValueToken() {
      _ref11 = ValueToken.__super__.constructor.apply(this, arguments);
      return _ref11;
    }

    ValueToken.prototype.id = ':';

    return ValueToken;

  })(this.Token);

  this.BlockEntryToken = (function(_super) {
    __extends(BlockEntryToken, _super);

    function BlockEntryToken() {
      _ref12 = BlockEntryToken.__super__.constructor.apply(this, arguments);
      return _ref12;
    }

    BlockEntryToken.prototype.id = '-';

    return BlockEntryToken;

  })(this.Token);

  this.FlowEntryToken = (function(_super) {
    __extends(FlowEntryToken, _super);

    function FlowEntryToken() {
      _ref13 = FlowEntryToken.__super__.constructor.apply(this, arguments);
      return _ref13;
    }

    FlowEntryToken.prototype.id = ',';

    return FlowEntryToken;

  })(this.Token);

  this.AliasToken = (function(_super) {
    __extends(AliasToken, _super);

    AliasToken.prototype.id = '<alias>';

    function AliasToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return AliasToken;

  })(this.Token);

  this.AnchorToken = (function(_super) {
    __extends(AnchorToken, _super);

    AnchorToken.prototype.id = '<anchor>';

    function AnchorToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return AnchorToken;

  })(this.Token);

  this.TagToken = (function(_super) {
    __extends(TagToken, _super);

    TagToken.prototype.id = '<tag>';

    function TagToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return TagToken;

  })(this.Token);

  this.ScalarToken = (function(_super) {
    __extends(ScalarToken, _super);

    ScalarToken.prototype.id = '<scalar>';

    function ScalarToken(value, plain, start_mark, end_mark, style) {
      this.value = value;
      this.plain = plain;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
    }

    return ScalarToken;

  })(this.Token);

}).call(this);

},{}],45:[function(require,module,exports){
(function() {
  var MarkedYAMLError, inflection, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  inflection = require('inflection');

  util = require('./util');

  /*
  The Traits throws these.
  */


  this.TraitError = (function(_super) {
    __extends(TraitError, _super);

    function TraitError() {
      _ref = TraitError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return TraitError;

  })(MarkedYAMLError);

  /*
  */


  this.ParameterError = (function(_super) {
    __extends(ParameterError, _super);

    function ParameterError() {
      _ref1 = ParameterError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ParameterError;

  })(MarkedYAMLError);

  /*
  The Traits class deals with applying traits to resources according to the spec
  */


  this.Traits = (function() {
    function Traits() {
      this.declaredTraits = {};
    }

    Traits.prototype.load_traits = function(node) {
      var allTraits,
        _this = this;
      if (this.has_property(node, 'traits')) {
        allTraits = this.property_value(node, 'traits');
        if (allTraits && typeof allTraits === "object") {
          return allTraits.forEach(function(trait_item) {
            if (trait_item && typeof trait_item === "object" && typeof trait_item.value === "object") {
              return trait_item.value.forEach(function(trait) {
                return _this.declaredTraits[trait[0].value] = trait;
              });
            }
          });
        }
      }
    };

    Traits.prototype.has_traits = function(node) {
      if (this.declaredTraits.length === 0 && this.has_property(node, 'traits')) {
        this.load_traits(node);
      }
      return Object.keys(this.declaredTraits).length > 0;
    };

    Traits.prototype.get_trait = function(traitName) {
      if (traitName in this.declaredTraits) {
        return this.declaredTraits[traitName][1];
      }
      return null;
    };

    Traits.prototype.apply_traits = function(node, resourceUri, removeQs) {
      var resources,
        _this = this;
      if (resourceUri == null) {
        resourceUri = "";
      }
      if (removeQs == null) {
        removeQs = true;
      }
      if (!util.isMapping(node)) {
        return;
      }
      if (this.has_traits(node)) {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          return _this.apply_traits_to_resource(resourceUri + resource[0].value, resource[1], removeQs);
        });
      }
    };

    Traits.prototype.apply_traits_to_resource = function(resourceUri, resource, removeQs) {
      var methods, uses,
        _this = this;
      if (!util.isMapping(resource)) {
        return;
      }
      methods = this.child_methods(resource);
      if (this.has_property(resource, 'is')) {
        uses = this.property_value(resource, 'is');
        uses.forEach(function(use) {
          return methods.forEach(function(method) {
            return _this.apply_trait(resourceUri, method, use);
          });
        });
      }
      methods.forEach(function(method) {
        if (_this.has_property(method[1], 'is')) {
          uses = _this.property_value(method[1], 'is');
          return uses.forEach(function(use) {
            return _this.apply_trait(resourceUri, method, use);
          });
        }
      });
      if (removeQs) {
        resource.remove_question_mark_properties();
      }
      return this.apply_traits(resource, resourceUri, removeQs);
    };

    Traits.prototype.apply_trait = function(resourceUri, method, useKey) {
      var plainParameters, temp, trait, traitName;
      traitName = this.key_or_value(useKey);
      if (!(traitName != null ? traitName.trim() : void 0)) {
        throw new exports.TraitError('while applying trait', null, 'trait name must be provided', useKey.start_mark);
      }
      if (!(trait = this.get_trait(traitName))) {
        throw new exports.TraitError('while applying trait', null, "there is no trait named " + traitName, useKey.start_mark);
      }
      plainParameters = this.get_parameters_from_is_key(resourceUri, method[0].value, useKey);
      temp = trait.cloneForTrait();
      this.apply_parameters(temp, plainParameters, useKey);
      this.apply_default_media_type_to_method(temp);
      temp.combine(method[1]);
      return method[1] = temp;
    };

    Traits.prototype.apply_parameters = function(resource, parameters, useKey) {
      var parameterName, usedParameters, _results;
      this._apply_parameters(resource, parameters, useKey, usedParameters = {
        resourcePath: true,
        resourcePathName: true,
        methodName: true
      });
      _results = [];
      for (parameterName in parameters) {
        if (!usedParameters[parameterName]) {
          throw new exports.ParameterError('while applying parameters', null, "unused parameter: " + parameterName, useKey.start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Traits.prototype._apply_parameters = function(resource, parameters, useKey, usedParameters) {
      var parameterUse,
        _this = this;
      if (!resource) {
        return;
      }
      if (util.isString(resource)) {
        if (parameterUse = resource.value.match(/<<\s*([^\|\s>]+)\s*(\|.*)?\s*>>/g)) {
          parameterUse.forEach(function(parameter) {
            var method, parameterName, value, _ref2, _ref3;
            parameterName = parameter != null ? (_ref2 = parameter.trim()) != null ? _ref2.replace(/[<>]+/g, '').trim() : void 0 : void 0;
            _ref3 = parameterName.split(/\s*\|\s*/), parameterName = _ref3[0], method = _ref3[1];
            if (!(parameterName in parameters)) {
              throw new exports.ParameterError('while applying parameters', null, "value was not provided for parameter: " + parameterName, useKey.start_mark);
            }
            value = parameters[parameterName];
            usedParameters[parameterName] = true;
            if (method) {
              if (method.match(/!\s*singularize/)) {
                value = inflection.singularize(value);
              } else if (method.match(/!\s*pluralize/)) {
                value = inflection.pluralize(value);
              } else {
                throw new exports.ParameterError('while validating parameter', null, 'unknown function applied to parameter', resource.start_mark);
              }
            }
            return resource.value = resource.value.replace(parameter, value);
          });
        }
        return;
      }
      if (util.isSequence(resource)) {
        resource.value.forEach(function(node) {
          return _this._apply_parameters(node, parameters, useKey, usedParameters);
        });
        return;
      }
      if (util.isMapping(resource)) {
        resource.value.forEach(function(property) {
          _this._apply_parameters(property[0], parameters, useKey, usedParameters);
          return _this._apply_parameters(property[1], parameters, useKey, usedParameters);
        });
      }
    };

    Traits.prototype.get_parameters_from_is_key = function(resourceUri, methodName, typeKey) {
      var parameter, parameters, reserved, result, _i, _len, _ref2;
      result = {};
      reserved = {
        methodName: methodName,
        resourcePath: resourceUri.replace(/\/\/*/g, '/'),
        resourcePathName: this.extractResourcePathName(resourceUri)
      };
      if (util.isMapping(typeKey)) {
        parameters = this.value_or_undefined(typeKey);
        if (util.isMapping(parameters[0][1])) {
          _ref2 = parameters[0][1].value;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            parameter = _ref2[_i];
            if (parameter[0].value in reserved) {
              throw new exports.TraitError('while applying parameters', null, "invalid parameter name: " + parameter[0].value + " is reserved", parameter[0].start_mark);
            }
            result[parameter[0].value] = parameter[1].value;
          }
        }
      }
      return util.extend(result, reserved);
    };

    Traits.prototype.extractResourcePathName = function(resourceUri) {
      var pathSegments, segment;
      pathSegments = resourceUri.split(/\//);
      while (segment = pathSegments.pop()) {
        if (!(typeof segment !== "undefined" && segment !== null ? segment.match(/[{}]/) : void 0)) {
          return segment;
        }
      }
      return "";
    };

    return Traits;

  })();

}).call(this);

},{"./errors":30,"./nodes":34,"./util":47,"inflection":49}],46:[function(require,module,exports){
(function() {
  var nodes, uritemplate, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  uritemplate = require('uritemplate');

  nodes = require('./nodes');

  util = require('./util');

  /*
     Applies transformations to the RAML
  */


  this.Transformations = (function() {
    function Transformations(settings) {
      this.settings = settings;
      this.isContentTypeString = __bind(this.isContentTypeString, this);
      this.add_key_value_to_node = __bind(this.add_key_value_to_node, this);
      this.apply_default_media_type_to_resource = __bind(this.apply_default_media_type_to_resource, this);
      this.get_media_type = __bind(this.get_media_type, this);
      this.load_default_media_type = __bind(this.load_default_media_type, this);
      this.applyAstTransformations = __bind(this.applyAstTransformations, this);
      this.applyTransformations = __bind(this.applyTransformations, this);
      this.declaredSchemas = {};
    }

    Transformations.prototype.applyTransformations = function(rootObject) {
      var resources;
      if (this.settings.transform) {
        this.applyTransformationsToRoot(rootObject);
        resources = rootObject.resources;
        return this.applyTransformationsToResources(rootObject, resources);
      }
    };

    Transformations.prototype.applyAstTransformations = function(document) {
      if (this.settings.transform) {
        return this.transform_document(document);
      }
    };

    Transformations.prototype.load_default_media_type = function(node) {
      if (!util.isMapping(node || (node != null ? node.value : void 0))) {
        return;
      }
      return this.mediaType = this.property_value(node, 'mediaType');
    };

    Transformations.prototype.get_media_type = function() {
      return this.mediaType;
    };

    Transformations.prototype.applyTransformationsToRoot = function(rootObject) {
      var expressions, template;
      if (rootObject.baseUri) {
        template = uritemplate.parse(rootObject.baseUri);
        expressions = template.expressions.filter(function(expr) {
          return 'templateText' in expr;
        }).map(function(expression) {
          return expression.templateText;
        });
        if (expressions.length) {
          if (!rootObject.baseUriParameters) {
            rootObject.baseUriParameters = {};
          }
        }
        return expressions.forEach(function(parameterName) {
          if (!(parameterName in rootObject.baseUriParameters)) {
            rootObject.baseUriParameters[parameterName] = {
              type: "string",
              required: true,
              displayName: parameterName
            };
            if (parameterName === "version") {
              return rootObject.baseUriParameters[parameterName]["enum"] = [rootObject.version];
            }
          }
        });
      }
    };

    Transformations.prototype.applyTransformationsToResources = function(rootObject, resources) {
      var expressions, inheritedSecScheme, method, parameterName, pathParts, resource, template, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      if (resources != null ? resources.length : void 0) {
        _results = [];
        for (_i = 0, _len = resources.length; _i < _len; _i++) {
          resource = resources[_i];
          inheritedSecScheme = resource.securedBy ? resource.securedBy : rootObject != null ? rootObject.securedBy : void 0;
          if ((_ref = resource.methods) != null ? _ref.length : void 0) {
            _ref1 = resource.methods;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              method = _ref1[_j];
              if (!("securedBy" in method)) {
                if (inheritedSecScheme) {
                  method.securedBy = inheritedSecScheme;
                }
              }
            }
          }
          pathParts = resource.relativeUri.split('\/');
          while (!pathParts[0] && pathParts.length) {
            pathParts.shift();
          }
          resource.relativeUriPathSegments = pathParts;
          template = uritemplate.parse(resource.relativeUri);
          expressions = template.expressions.filter(function(expr) {
            return 'templateText' in expr;
          }).map(function(expression) {
            return expression.templateText;
          });
          if (expressions.length) {
            if (!resource.uriParameters) {
              resource.uriParameters = {};
            }
          }
          for (_k = 0, _len2 = expressions.length; _k < _len2; _k++) {
            parameterName = expressions[_k];
            if (!(parameterName in resource.uriParameters)) {
              resource.uriParameters[parameterName] = {
                type: "string",
                required: true,
                displayName: parameterName
              };
            }
          }
          _results.push(this.applyTransformationsToResources(rootObject, resource.resources));
        }
        return _results;
      }
    };

    /*
    Media Type pivot when using default mediaType property
    */


    Transformations.prototype.apply_default_media_type_to_resource = function(resource) {
      var childResource, method, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (!this.mediaType) {
        return;
      }
      if (!util.isMapping(resource)) {
        return;
      }
      _ref = this.child_resources(resource);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        childResource = _ref[_i];
        this.apply_default_media_type_to_resource(childResource[1]);
      }
      _ref1 = this.child_methods(resource);
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        method = _ref1[_j];
        _results.push(this.apply_default_media_type_to_method(method[1]));
      }
      return _results;
    };

    Transformations.prototype.apply_default_media_type_to_method = function(method) {
      var responses,
        _this = this;
      if (!this.mediaType) {
        return;
      }
      if (!util.isMapping(method)) {
        return;
      }
      if (this.has_property(method, 'body')) {
        this.apply_default_media_type_to_body(this.get_property(method, 'body'));
      }
      if (this.has_property(method, 'responses')) {
        responses = this.get_property(method, 'responses');
        if (!(responses && responses.value)) {
          return;
        }
        return responses.value.forEach(function(response) {
          if (_this.has_property(response[1], 'body')) {
            return _this.apply_default_media_type_to_body(_this.get_property(response[1], 'body'));
          }
        });
      }
    };

    Transformations.prototype.apply_default_media_type_to_body = function(body) {
      var key, responseType, responseTypeKey, _ref, _ref1, _ref2;
      if (!util.isMapping(body)) {
        return;
      }
      if (body != null ? (_ref = body.value) != null ? (_ref1 = _ref[0]) != null ? (_ref2 = _ref1[0]) != null ? _ref2.value : void 0 : void 0 : void 0 : void 0) {
        key = body.value[0][0].value;
        if (!key.match(/\//)) {
          responseType = new nodes.MappingNode('tag:yaml.org,2002:map', [], body.start_mark, body.end_mark);
          responseTypeKey = new nodes.ScalarNode('tag:yaml.org,2002:str', this.mediaType, body.start_mark, body.end_mark);
          responseType.value.push([responseTypeKey, body.clone()]);
          return body.value = responseType.value;
        }
      }
    };

    Transformations.prototype.noop = function() {};

    Transformations.prototype.transform_types = function(typeProperty) {
      var types,
        _this = this;
      types = typeProperty.value;
      return types.forEach(function(type_entry) {
        return type_entry.value.forEach(function(type) {
          return _this.transform_resource(type, true);
        });
      });
    };

    Transformations.prototype.transform_traits = function(traitProperty) {
      var traits,
        _this = this;
      traits = traitProperty.value;
      return traits.forEach(function(trait_entry) {
        return trait_entry.value.forEach(function(trait) {
          return _this.transform_method(trait[1], true);
        });
      });
    };

    Transformations.prototype.transform_named_params = function(property, allowParameterKeys, requiredByDefault) {
      var _this = this;
      if (requiredByDefault == null) {
        requiredByDefault = true;
      }
      if (util.isNull(property[1])) {
        return;
      }
      return property[1].value.forEach(function(param) {
        if (util.isNull(param[1])) {
          param[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], param[1].start_mark, param[1].end_mark);
        }
        return _this.transform_common_parameter_properties(param[0].value, param[1], allowParameterKeys, requiredByDefault);
      });
    };

    Transformations.prototype.transform_common_parameter_properties = function(parameterName, node, allowParameterKeys, requiredByDefault) {
      var _this = this;
      if (util.isSequence(node)) {
        return node.value.forEach(function(parameter) {
          return _this.transform_named_parameter(parameterName, parameter, allowParameterKeys, requiredByDefault);
        });
      } else {
        return this.transform_named_parameter(parameterName, node, allowParameterKeys, requiredByDefault);
      }
    };

    Transformations.prototype.transform_named_parameter = function(parameterName, node, allowParameterKeys, requiredByDefault) {
      var hasDisplayName, hasRequired, hasType,
        _this = this;
      hasDisplayName = false;
      hasRequired = false;
      hasType = false;
      node.value.forEach(function(childNode) {
        var canonicalPropertyName;
        if (allowParameterKeys && _this.isParameterKey(childNode)) {
          return;
        }
        canonicalPropertyName = _this.canonicalizePropertyName(childNode[0].value, allowParameterKeys);
        switch (canonicalPropertyName) {
          case "pattern":
            return _this.noop();
          case "default":
            return _this.noop();
          case "enum":
            return _this.noop();
          case "description":
            return _this.noop();
          case "example":
            return _this.noop();
          case "minLength":
            return _this.noop();
          case "maxLength":
            return _this.noop();
          case "minimum":
            return _this.noop();
          case "maximum":
            return _this.noop();
          case "repeat":
            return _this.noop();
          case "displayName":
            return hasDisplayName = true;
          case "type":
            return hasType = true;
          case "required":
            return hasRequired = true;
          default:
            return _this.noop();
        }
      });
      if (!hasDisplayName) {
        this.add_key_value_to_node(node, 'displayName', 'tag:yaml.org,2002:str', this.canonicalizePropertyName(parameterName, allowParameterKeys));
      }
      if (!hasRequired) {
        if (requiredByDefault) {
          this.add_key_value_to_node(node, 'required', 'tag:yaml.org,2002:bool', 'true');
        }
      }
      if (!hasType) {
        return this.add_key_value_to_node(node, 'type', 'tag:yaml.org,2002:str', 'string');
      }
    };

    Transformations.prototype.add_key_value_to_node = function(node, keyName, valueTag, value) {
      var propertyName, propertyValue;
      propertyName = new nodes.ScalarNode('tag:yaml.org,2002:str', keyName, node.start_mark, node.end_mark);
      propertyValue = new nodes.ScalarNode(valueTag, value, node.start_mark, node.end_mark);
      return node.value.push([propertyName, propertyValue]);
    };

    Transformations.prototype.transform_document = function(node) {
      var _this = this;
      if (node != null ? node.value : void 0) {
        return node.value.forEach(function(property) {
          var _ref;
          switch (property[0].value) {
            case "title":
              return _this.noop();
            case "securitySchemes":
              return _this.noop();
            case "schemas":
              return _this.noop();
            case "version":
              return _this.noop();
            case "documentation":
              return _this.noop();
            case "mediaType":
              return _this.noop();
            case "securedBy":
              return _this.noop();
            case "baseUri":
              return _this.noop();
            case "traits":
              return _this.transform_traits(property[1]);
            case "baseUriParameters":
              return _this.transform_named_params(property, false);
            case "resourceTypes":
              return _this.transform_types(property[1]);
            case "resources":
              return (_ref = property[1]) != null ? _ref.value.forEach(function(resource) {
                return _this.transform_resource(resource);
              }) : void 0;
            default:
              return _this.noop();
          }
        });
      }
    };

    Transformations.prototype.transform_resource = function(resource, allowParameterKeys) {
      var _this = this;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (resource.value) {
        return resource.value.forEach(function(property) {
          var canonicalKey, isKnownCommonProperty, _ref, _ref1;
          isKnownCommonProperty = _this.transform_common_properties(property, allowParameterKeys);
          if (!isKnownCommonProperty) {
            if (_this.isHttpMethod(property[0].value, allowParameterKeys)) {
              return _this.transform_method(property[1], allowParameterKeys);
            } else {
              canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
              switch (canonicalKey) {
                case "type":
                  return _this.noop();
                case "usage":
                  return _this.noop();
                case "securedBy":
                  return _this.noop();
                case "uriParameters":
                  return _this.transform_named_params(property, allowParameterKeys);
                case "baseUriParameters":
                  return _this.transform_named_params(property, allowParameterKeys);
                case "resources":
                  return (_ref = property[1]) != null ? _ref.value.forEach(function(resource) {
                    return _this.transform_resource(resource);
                  }) : void 0;
                case "methods":
                  return (_ref1 = property[1]) != null ? _ref1.value.forEach(function(method) {
                    return _this.transform_method(method, allowParameterKeys);
                  }) : void 0;
                default:
                  return _this.noop();
              }
            }
          }
        });
      }
    };

    Transformations.prototype.transform_method = function(method, allowParameterKeys) {
      var _this = this;
      if (util.isNull(method)) {
        return;
      }
      return method.value.forEach(function(property) {
        var canonicalKey;
        if (_this.transform_common_properties(property, allowParameterKeys)) {
          return;
        }
        canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
        switch (canonicalKey) {
          case "securedBy":
            return _this.noop();
          case "usage":
            return _this.noop();
          case "headers":
            return _this.transform_named_params(property, allowParameterKeys, false);
          case "queryParameters":
            return _this.transform_named_params(property, allowParameterKeys, false);
          case "baseUriParameters":
            return _this.transform_named_params(property, allowParameterKeys);
          case "body":
            return _this.transform_body(property, allowParameterKeys);
          case "responses":
            return _this.transform_responses(property, allowParameterKeys);
          default:
            return _this.noop();
        }
      });
    };

    Transformations.prototype.transform_responses = function(responses, allowParameterKeys) {
      var _this = this;
      if (util.isNull(responses[1])) {
        return;
      }
      return responses[1].value.forEach(function(response) {
        return _this.transform_response(response, allowParameterKeys);
      });
    };

    Transformations.prototype.transform_response = function(response, allowParameterKeys) {
      var _this = this;
      if (util.isMapping(response[1])) {
        return response[1].value.forEach(function(property) {
          var canonicalKey;
          canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
          switch (canonicalKey) {
            case "description":
              return _this.noop();
            case "body":
              return _this.transform_body(property, allowParameterKeys);
            case "headers":
              return _this.transform_named_params(property, allowParameterKeys, false);
            default:
              return _this.noop();
          }
        });
      }
    };

    Transformations.prototype.isContentTypeString = function(value) {
      return value != null ? value.match(/^[^\/]+\/[^\/]+$/) : void 0;
    };

    Transformations.prototype.transform_body = function(property, allowParameterKeys) {
      var _ref,
        _this = this;
      if (util.isNull(property[1])) {
        return;
      }
      return (_ref = property[1].value) != null ? _ref.forEach(function(bodyProperty) {
        var canonicalProperty;
        if (_this.isParameterKey(bodyProperty)) {
          return _this.noop();
        } else if (_this.isContentTypeString(bodyProperty[0].value)) {
          return _this.transform_body(bodyProperty, allowParameterKeys);
        } else {
          canonicalProperty = _this.canonicalizePropertyName(bodyProperty[0].value, allowParameterKeys);
          switch (canonicalProperty) {
            case "example":
              return _this.noop();
            case "schema":
              return _this.noop();
            case "formParameters":
              return _this.transform_named_params(bodyProperty, allowParameterKeys, false);
            default:
              return _this.noop();
          }
        }
      }) : void 0;
    };

    Transformations.prototype.transform_common_properties = function(property, allowParameterKeys) {
      var canonicalProperty;
      if (this.isParameterKey(property)) {
        return true;
      } else {
        canonicalProperty = this.canonicalizePropertyName(property[0].value, allowParameterKeys);
        switch (canonicalProperty) {
          case "displayName":
            return true;
          case "description":
            return true;
          case "is":
            return true;
          default:
            this.noop();
        }
      }
      return false;
    };

    return Transformations;

  })();

}).call(this);

},{"./nodes":34,"./util":47,"uritemplate":52}],47:[function(require,module,exports){
(function() {
  var __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  this.extend = function() {
    var destination, k, source, sources, v, _i, _len;
    destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        destination[k] = v;
      }
    }
    return destination;
  };

  this.is_empty = function(obj) {
    var key;
    if (Array.isArray(obj) || typeof obj === 'string') {
      return obj.length === 0;
    }
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      return false;
    }
    return true;
  };

  this.isNoop = function(node) {
    return node;
  };

  this.isMapping = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:map";
  };

  this.isNull = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:null";
  };

  this.isSequence = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:seq";
  };

  this.isString = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:str";
  };

  this.isInteger = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:int";
  };

  this.isNullableMapping = function(node) {
    return this.isMapping(node) || this.isNull(node);
  };

  this.isNullableString = function(node) {
    return this.isString(node) || this.isNull(node);
  };

  this.isNullableSequence = function(node) {
    return this.isSequence(node) || this.isNull(node);
  };

  this.isNumber = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:int' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:float';
  };

  this.isScalar = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:null' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:bool' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:int' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:float' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:binary' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:timestamp' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:str';
  };

  this.isCollection = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:omap' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:pairs' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:set' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:seq' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:map';
  };

}).call(this);

},{}],48:[function(require,module,exports){
(function() {
  var MarkedYAMLError, jsonlint, nodes, traits, uritemplate, url, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  url = require('url');

  uritemplate = require('uritemplate');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  traits = require('./traits');

  util = require('./util');

  jsonlint = require('json-lint');

  /*
  The Validator throws these.
  */


  this.ValidationError = (function(_super) {
    __extends(ValidationError, _super);

    function ValidationError() {
      _ref = ValidationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ValidationError;

  })(MarkedYAMLError);

  /*
  A collection of multiple validation errors
  */


  this.ValidationErrors = (function(_super) {
    __extends(ValidationErrors, _super);

    function ValidationErrors(validation_errors) {
      this.validation_errors = validation_errors;
    }

    ValidationErrors.prototype.get_validation_errors = function() {
      return this.validation_errors;
    };

    return ValidationErrors;

  })(MarkedYAMLError);

  /*
  The Validator class deals with validating a YAML file according to the spec
  */


  this.Validator = (function() {
    function Validator() {
      this.get_properties = __bind(this.get_properties, this);
      this.get_list_values = __bind(this.get_list_values, this);
      this.validations = [this.validate_root, this.validate_root_properties, this.validate_base_uri_parameters, this.valid_absolute_uris];
    }

    Validator.prototype.validate_document = function(node) {
      var validation, _i, _len, _ref1;
      _ref1 = this.validations;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        validation = _ref1[_i];
        validation.call(this, node);
      }
      return true;
    };

    Validator.prototype.validate_security_schemes = function(schemesProperty) {
      var scheme, scheme_entry, _i, _len, _ref1, _results;
      if (!util.isSequence(schemesProperty)) {
        throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security schemes property, it must be an array', schemesProperty.start_mark);
      }
      _ref1 = schemesProperty.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        scheme_entry = _ref1[_i];
        if (!util.isMapping(scheme_entry)) {
          throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security scheme property, it must be a map', scheme_entry.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref2, _results1;
          _ref2 = scheme_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            scheme = _ref2[_j];
            if (!util.isMapping(scheme[1])) {
              throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security scheme property, it must be a map', scheme[0].start_mark);
            }
            _results1.push(this.validate_security_scheme(scheme[1]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.trackRepeatedProperties = function(properties, key, property, section, errorMessage) {
      if (section == null) {
        section = "RAML";
      }
      if (errorMessage == null) {
        errorMessage = "a property with the same name already exists";
      }
      if (key in properties) {
        throw new exports.ValidationError("while validating " + section, null, "" + errorMessage + ": '" + key + "'", property.start_mark);
      }
      return properties[key] = property;
    };

    Validator.prototype.validate_security_scheme = function(scheme) {
      var property, schemeProperties, settings, type, _i, _len, _ref1;
      type = null;
      settings = null;
      schemeProperties = {};
      _ref1 = scheme.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(schemeProperties, property[0].value, property[0], 'while validating security scheme', "property already used in security scheme");
        switch (property[0].value) {
          case "description":
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes description must be a string', property[1].start_mark);
            }
            break;
          case "type":
            type = property[1].value;
            if (!(util.isString(property[1]) && type.match(/^(OAuth 1.0|OAuth 2.0|Basic Authentication|Digest Authentication|x-.+)$/))) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes type must be any of: "OAuth 1.0", "OAuth 2.0", "Basic Authentication", "Digest Authentication", "x-\{.+\}"', property[1].start_mark);
            }
            break;
          case "describedBy":
            this.validate_method(property, true, "security scheme");
            break;
          case "settings":
            settings = property;
            if (!util.isNullableMapping(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes settings must be a map', property[1].start_mark);
            }
            break;
          default:
            throw new exports.ValidationError('while validating security scheme', null, "property: '" + property[0].value + "' is invalid in a security scheme", property[0].start_mark);
        }
      }
      if (!type) {
        throw new exports.ValidationError('while validating security scheme', null, 'schemes type must be any of: "OAuth 1.0", "OAuth 2.0", "Basic Authentication", "Digest Authentication", "x-\{.+\}"', scheme.start_mark);
      } else if (type === "OAuth 2.0") {
        if (!settings) {
          throw new exports.ValidationError('while validating security scheme', null, 'for OAuth 2.0 settings must be a map', scheme.start_mark);
        }
        return this.validate_oauth2_settings(settings);
      } else if (type === "OAuth 1.0") {
        if (!settings) {
          throw new exports.ValidationError('while validating security scheme', null, 'for OAuth 1.0 settings must be a map', scheme.start_mark);
        }
        return this.validate_oauth1_settings(settings);
      }
    };

    Validator.prototype.validate_oauth2_settings = function(settings) {
      var property, propertyName, settingProperties, _i, _j, _len, _len1, _ref1, _ref2, _results;
      settingProperties = {};
      _ref1 = settings[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(settingProperties, property[0].value, property[0], 'while validating security scheme', "setting with the same name already exists");
        switch (property[0].value) {
          case "authorizationUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'authorizationUri must be a URL', property[0].start_mark);
            }
            break;
          case "accessTokenUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'accessTokenUri must be a URL', property[0].start_mark);
            }
        }
      }
      _ref2 = ['accessTokenUri', 'authorizationUri'];
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        propertyName = _ref2[_j];
        if (!(propertyName in settingProperties)) {
          throw new exports.ValidationError('while validating security scheme', null, "OAuth 2.0 settings must have " + propertyName + " property", settings[0].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_oauth1_settings = function(settings) {
      var property, propertyName, settingProperties, _i, _j, _len, _len1, _ref1, _ref2, _results;
      settingProperties = {};
      _ref1 = settings[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(settingProperties, property[0].value, property[0], 'while validating security scheme', "setting with the same name already exists");
        switch (property[0].value) {
          case "requestTokenUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'requestTokenUri must be a URL', property[0].start_mark);
            }
            break;
          case "authorizationUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'authorizationUri must be a URL', property[0].start_mark);
            }
            break;
          case "tokenCredentialsUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'tokenCredentialsUri must be a URL', property[0].start_mark);
            }
        }
      }
      _ref2 = ['requestTokenUri', 'authorizationUri', 'tokenCredentialsUri'];
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        propertyName = _ref2[_j];
        if (!(propertyName in settingProperties)) {
          throw new exports.ValidationError('while validating security scheme', null, "OAuth 1.0 settings must have " + propertyName + " property", settings[0].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_root_schemas = function(schemas) {
      var schema, schemaList, schemaName, _results;
      if (!util.isSequence(schemas)) {
        throw new exports.ValidationError('while validating schemas', null, 'schemas property must be an array', schemas.start_mark);
      }
      schemaList = this.get_all_schemas();
      _results = [];
      for (schemaName in schemaList) {
        schema = schemaList[schemaName];
        if (!(schema[1].tag && util.isString(schema[1]))) {
          throw new exports.ValidationError('while validating schemas', null, 'schema ' + schemaName + ' must be a string', schema[0].start_mark);
        }
        _results.push(this.validateSchema(schema[1]));
      }
      return _results;
    };

    Validator.prototype.validate_root = function(node) {
      if (!(node || util.isNull(node))) {
        throw new exports.ValidationError('while validating root', null, 'empty document', node != null ? node.start_mark : void 0);
      }
      if (!util.isMapping(node)) {
        throw new exports.ValidationError('while validating root', null, 'document must be a map', node.start_mark);
      }
    };

    Validator.prototype.validate_base_uri_parameters = function() {
      if (!this.baseUriParameters) {
        return;
      }
      if (!this.baseUri) {
        throw new exports.ValidationError('while validating uri parameters', null, 'uri parameters defined when there is no baseUri', this.baseUriParameters.start_mark);
      }
      if (!util.isNullableMapping(this.baseUriParameters)) {
        throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', this.baseUriParameters.start_mark);
      }
      return this.validate_uri_parameters(this.baseUri, this.baseUriParameters, false, false, ["version"]);
    };

    Validator.prototype.validate_uri_parameters = function(uri, uriProperty, allowParameterKeys, skipParameterUseCheck, reservedNames) {
      var err, expressions, parameterName, template, uriParameter, uriParameters, _i, _len, _ref1, _ref2, _results;
      if (reservedNames == null) {
        reservedNames = [];
      }
      try {
        template = uritemplate.parse(uri);
      } catch (_error) {
        err = _error;
        throw new exports.ValidationError('while validating uri parameters', null, err != null ? (_ref1 = err.options) != null ? _ref1.message : void 0 : void 0, uriProperty.start_mark);
      }
      expressions = template.expressions.filter(function(expr) {
        return "templateText" in expr;
      }).map(function(expression) {
        return expression.templateText;
      });
      uriParameters = {};
      if (typeof uriProperty.value === "object") {
        _ref2 = uriProperty.value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          uriParameter = _ref2[_i];
          parameterName = this.canonicalizePropertyName(uriParameter[0].value, allowParameterKeys);
          this.trackRepeatedProperties(uriParameters, parameterName, uriProperty, 'while validating URI parameters', "URI parameter with the same name already exists");
          if (__indexOf.call(reservedNames, parameterName) >= 0) {
            throw new exports.ValidationError('while validating baseUri', null, uriParameter[0].value + ' parameter not allowed here', uriParameter[0].start_mark);
          }
          if (!(util.isNullableMapping(uriParameter[1], allowParameterKeys) || util.isNullableSequence(uriParameter[1], allowParameterKeys))) {
            throw new exports.ValidationError('while validating baseUri', null, 'URI parameter must be a map', uriParameter[0].start_mark);
          }
          if (!util.isNull(uriParameter[1])) {
            this.valid_common_parameter_properties(uriParameter[1], allowParameterKeys);
          }
          if (!(skipParameterUseCheck || this.isParameterKey(uriParameter) || __indexOf.call(expressions, parameterName) >= 0)) {
            throw new exports.ValidationError('while validating baseUri', null, uriParameter[0].value + ' uri parameter unused', uriParameter[0].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_types = function(typeProperty) {
      var type, type_entry, types, _i, _len, _results;
      types = typeProperty.value;
      if (!util.isSequence(typeProperty)) {
        throw new exports.ValidationError('while validating resource types', null, 'invalid resourceTypes definition, it must be an array', typeProperty.start_mark);
      }
      _results = [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type_entry = types[_i];
        if (!util.isMapping(type_entry)) {
          throw new exports.ValidationError('while validating resource types', null, 'invalid resourceType definition, it must be a map', type_entry.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = type_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            type = _ref1[_j];
            if (this.isParameterKey(type)) {
              throw new exports.ValidationError('while validating resource types', null, 'parameter key cannot be used as a resource type name', type[0].start_mark);
            }
            if (!util.isMapping(type[1])) {
              throw new exports.ValidationError('while validating resource types', null, 'invalid resourceType definition, it must be a map', type[1].start_mark);
            }
            _results1.push(this.validate_resource(type, true, 'resource type'));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.validate_traits = function(traitProperty) {
      var trait, trait_entry, _i, _len, _results;
      traits = traitProperty.value;
      if (!Array.isArray(traits)) {
        throw new exports.ValidationError('while validating traits', null, 'invalid traits definition, it must be an array', traitProperty.start_mark);
      }
      _results = [];
      for (_i = 0, _len = traits.length; _i < _len; _i++) {
        trait_entry = traits[_i];
        if (!Array.isArray(trait_entry.value)) {
          throw new exports.ValidationError('while validating traits', null, 'invalid traits definition, it must be an array', traitProperty.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = trait_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            trait = _ref1[_j];
            if (this.isParameterKey(trait)) {
              throw new exports.ValidationError('while validating traits', null, 'parameter key cannot be used as a trait name', trait[0].start_mark);
            }
            if (!util.isMapping(trait[1])) {
              throw new exports.ValidationError('while validating traits', null, 'invalid trait definition, it must be a map', trait[1].start_mark);
            }
            _results1.push(this.valid_traits_properties(trait));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.valid_traits_properties = function(node) {
      var invalid;
      if (!node[1].value) {
        return;
      }
      if (!util.isMapping(node[1])) {
        return;
      }
      invalid = node[1].value.filter(function(childNode) {
        return childNode[0].value === "is" || childNode[0].value === "type";
      });
      if (invalid.length > 0) {
        throw new exports.ValidationError('while validating trait properties', null, "property: '" + invalid[0][0].value + "' is invalid in a trait", invalid[0][0].start_mark);
      }
      return this.validate_method(node, true, 'trait');
    };

    Validator.prototype.canonicalizePropertyName = function(propertyName, mustRemoveQuestionMark) {
      if (mustRemoveQuestionMark && propertyName.slice(-1) === '?') {
        return propertyName.slice(0, -1);
      }
      return propertyName;
    };

    Validator.prototype.valid_common_parameter_properties = function(node, allowParameterKeys) {
      var parameter, _i, _len, _ref1, _results;
      if (!node.value) {
        return;
      }
      if (util.isSequence(node)) {
        if (node.value.length === 0) {
          throw new exports.ValidationError('while validating parameter properties', null, 'named parameter needs at least one type', node.start_mark);
        }
        if (!(node.value.length > 1)) {
          throw new exports.ValidationError('while validating parameter properties', null, 'single type for variably typed parameter', node.start_mark);
        }
        _ref1 = node.value;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          parameter = _ref1[_i];
          _results.push(this.validate_named_parameter(parameter, allowParameterKeys));
        }
        return _results;
      } else {
        return this.validate_named_parameter(node, allowParameterKeys);
      }
    };

    Validator.prototype.validate_named_parameter = function(node, allowParameterKeys) {
      var booleanValues, canonicalPropertyName, childNode, enumValues, parameterProperties, parameterType, propertyName, propertyValue, unusableProperty, valid, validTypes, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
      parameterProperties = {};
      parameterType = "string";
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        childNode = _ref1[_i];
        propertyName = childNode[0].value;
        propertyValue = childNode[1].value;
        this.trackRepeatedProperties(parameterProperties, this.canonicalizePropertyName(childNode[0].value, true), childNode[0], 'while validating parameter properties', "parameter property already used");
        booleanValues = ["true", "false"];
        if (allowParameterKeys) {
          if (this.isParameterKey(childNode) || this.isParameterValue(childNode)) {
            continue;
          }
        }
        canonicalPropertyName = this.canonicalizePropertyName(propertyName, allowParameterKeys);
        valid = true;
        switch (propertyName) {
          case "displayName":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of displayName must be a scalar', childNode[1].start_mark);
            }
            break;
          case "pattern":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of pattern must be a scalar', childNode[1].start_mark);
            }
            break;
          case "default":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of default must be a scalar', childNode[1].start_mark);
            }
            break;
          case "description":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of description must be a scalar', childNode[1].start_mark);
            }
            break;
          case "example":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of example must be a scalar', childNode[1].start_mark);
            }
            break;
          case "minLength":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of minLength must be a number', childNode[1].start_mark);
            }
            break;
          case "maxLength":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of maxLength must be a number', childNode[1].start_mark);
            }
            break;
          case "minimum":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of minimum must be a number', childNode[1].start_mark);
            }
            break;
          case "maximum":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of maximum must be a number', childNode[1].start_mark);
            }
            break;
          case "type":
            parameterType = propertyValue;
            validTypes = ['string', 'number', 'integer', 'date', 'boolean', 'file'];
            if (__indexOf.call(validTypes, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'type can be either of: string, number, integer, file, date or boolean ', childNode[1].start_mark);
            }
            break;
          case "required":
            if (__indexOf.call(booleanValues, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'required can be any either true or false', childNode[1].start_mark);
            }
            break;
          case "repeat":
            if (__indexOf.call(booleanValues, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'repeat can be any either true or false', childNode[1].start_mark);
            }
            break;
          default:
            valid = false;
        }
        switch (canonicalPropertyName) {
          case "enum":
            if (!util.isNullableSequence(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of enum must be an array', childNode[1].start_mark);
            }
            if (!childNode[1].value.length) {
              throw new exports.ValidationError('while validating parameter properties', null, 'enum is empty', childNode[1].start_mark);
            }
            enumValues = this.get_list_values(childNode[1].value);
            if (this.hasDuplicates(enumValues)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'enum contains duplicated values', childNode[1].start_mark);
            }
            break;
          default:
            if (!valid) {
              throw new exports.ValidationError('while validating parameter properties', null, "unknown property " + propertyName, childNode[0].start_mark);
            }
        }
      }
      if (parameterType !== "string") {
        _ref2 = ['enum', 'pattern', 'minLength', 'maxLength'];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          unusableProperty = _ref2[_j];
          if (unusableProperty in parameterProperties) {
            throw new exports.ValidationError('while validating parameter properties', null, "property " + unusableProperty + " can only be used if type is 'string'", parameterProperties[unusableProperty].start_mark);
          }
        }
      }
      if (!(parameterType === "number" || parameterType === "integer")) {
        _ref3 = ['minimum', 'maximum'];
        _results = [];
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          unusableProperty = _ref3[_k];
          if (unusableProperty in parameterProperties) {
            throw new exports.ValidationError('while validating parameter properties', null, "property " + unusableProperty + " can only be used if type is 'number' or 'integer'", parameterProperties[unusableProperty].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.get_list_values = function(node) {
      var _this = this;
      return node.map(function(item) {
        return item.value;
      });
    };

    Validator.prototype.validate_root_properties = function(node) {
      var checkVersion, property, rootProperties, _i, _len, _ref1;
      checkVersion = false;
      rootProperties = {};
      if (node != null ? node.value : void 0) {
        _ref1 = node.value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          property = _ref1[_i];
          if (property[0].value.match(/^\//)) {
            this.trackRepeatedProperties(rootProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating root properties', "resource already declared");
          } else {
            this.trackRepeatedProperties(rootProperties, property[0].value, property[0], 'while validating root properties', 'root property already used');
          }
          switch (property[0].value) {
            case 'title':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'title must be a string', property[0].start_mark);
              }
              break;
            case 'baseUri':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'baseUri must be a string', property[0].start_mark);
              }
              this.baseUri = property[1].value;
              checkVersion = this.validate_base_uri(property[1]);
              break;
            case 'securitySchemes':
              this.validate_security_schemes(property[1]);
              break;
            case 'schemas':
              this.validate_root_schemas(property[1]);
              break;
            case 'version':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'version must be a string', property[0].start_mark);
              }
              if (!util.isNull(property[1])) {
                property[1].tag = 'tag:yaml.org,2002:str';
              }
              break;
            case 'traits':
              this.validate_traits(property[1]);
              break;
            case 'documentation':
              if (!util.isSequence(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'documentation must be an array', property[0].start_mark);
              }
              this.validate_documentation(property[1]);
              break;
            case 'mediaType':
              if (!util.isString(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'mediaType must be a scalar', property[0].start_mark);
              }
              break;
            case 'baseUriParameters':
              this.baseUriParameters = property[1];
              util.isNoop(property[1]);
              break;
            case 'resourceTypes':
              this.validate_types(property[1]);
              break;
            case 'securedBy':
              this.validate_secured_by(property);
              break;
            case 'protocols':
              this.validate_protocols_property(property);
              break;
            default:
              if (property[0].value.match(/^\//)) {
                this.validate_resource(property);
              } else {
                throw new exports.ValidationError('while validating root properties', null, "unknown property " + property[0].value, property[0].start_mark);
              }
          }
        }
      }
      if (!('title' in rootProperties)) {
        throw new exports.ValidationError('while validating root properties', null, 'missing title', node.start_mark);
      }
      if (checkVersion && !('version' in rootProperties)) {
        throw new exports.ValidationError('while validating version', null, 'missing version', node.start_mark);
      }
    };

    Validator.prototype.validate_documentation = function(documentation_property) {
      var docSection, _i, _len, _ref1, _results;
      if (!documentation_property.value.length) {
        throw new exports.ValidationError('while validating documentation section', null, 'there must be at least one document in the documentation section', documentation_property.start_mark);
      }
      _ref1 = documentation_property.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        docSection = _ref1[_i];
        _results.push(this.validate_doc_section(docSection));
      }
      return _results;
    };

    Validator.prototype.validate_doc_section = function(docSection) {
      var docProperties, property, _i, _len, _ref1;
      if (!util.isMapping(docSection)) {
        throw new exports.ValidationError('while validating documentation section', null, 'each documentation section must be a map', docSection.start_mark);
      }
      docProperties = {};
      _ref1 = docSection.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(docProperties, property[0].value, property[0], 'while validating documentation section', "property already used");
        switch (property[0].value) {
          case "title":
            if (!(util.isScalar(property[1]) && !util.isNull(property[1]))) {
              throw new exports.ValidationError('while validating documentation section', null, 'title must be a string', property[0].start_mark);
            }
            break;
          case "content":
            if (!(util.isScalar(property[1]) && !util.isNull(property[1]))) {
              throw new exports.ValidationError('while validating documentation section', null, 'content must be a string', property[0].start_mark);
            }
            break;
          default:
            throw new exports.ValidationError('while validating root properties', null, 'unknown property ' + property[0].value, property[0].start_mark);
        }
      }
      if (!("content" in docProperties)) {
        throw new exports.ValidationError('while validating documentation section', null, 'a documentation entry must have content property', docSection.start_mark);
      }
      if (!("title" in docProperties)) {
        throw new exports.ValidationError('while validating documentation section', null, 'a documentation entry must have title property', docSection.start_mark);
      }
    };

    Validator.prototype.child_resources = function(node) {
      if (node && util.isMapping(node)) {
        return node.value.filter(function(childNode) {
          return childNode[0].value.match(/^\//);
        });
      }
      return [];
    };

    Validator.prototype.validate_resource = function(resource, allowParameterKeys, context) {
      var canonicalKey, err, key, property, resourceProperties, template, valid, _i, _len, _ref1, _ref2, _results;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (context == null) {
        context = "resource";
      }
      if (!(resource[1] && util.isNullableMapping(resource[1]))) {
        throw new exports.ValidationError('while validating resources', null, 'resource is not a map', resource[1].start_mark);
      }
      if (resource[0].value) {
        try {
          template = uritemplate.parse(resource[0].value);
        } catch (_error) {
          err = _error;
          throw new exports.ValidationError('while validating resource', null, "Resource name is invalid: " + (err != null ? (_ref1 = err.options) != null ? _ref1.message : void 0 : void 0), resource[0].start_mark);
        }
      }
      if (util.isNull(resource[1])) {
        return;
      }
      if (resource[1].value) {
        resourceProperties = {};
        _ref2 = resource[1].value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          property = _ref2[_i];
          if (property[0].value.match(/^\//)) {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "resource already declared");
          } else if (this.isHttpMethod(property[0].value, allowParameterKeys)) {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "method already declared");
          } else {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "property already used");
          }
          if (!this.validate_common_properties(property, allowParameterKeys)) {
            if (property[0].value.match(/^\//)) {
              if (allowParameterKeys) {
                throw new exports.ValidationError('while validating trait properties', null, 'resource type cannot define child resources', property[0].start_mark);
              }
              _results.push(this.validate_resource(property, allowParameterKeys));
            } else if (this.isHttpMethod(property[0].value, allowParameterKeys)) {
              _results.push(this.validate_method(property, allowParameterKeys, 'method'));
            } else {
              key = property[0].value;
              canonicalKey = this.canonicalizePropertyName(key, allowParameterKeys);
              valid = true;
              switch (canonicalKey) {
                case "uriParameters":
                  if (!util.isNullableMapping(property[1])) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'uri parameters must be a map', property[0].start_mark);
                  }
                  this.validate_uri_parameters(resource[0].value, property[1], allowParameterKeys, allowParameterKeys);
                  break;
                case "baseUriParameters":
                  if (!this.baseUri) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters defined when there is no baseUri', property[0].start_mark);
                  }
                  if (!util.isNullableMapping(property[1])) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', property[0].start_mark);
                  }
                  this.validate_uri_parameters(this.baseUri, property[1], allowParameterKeys);
                  break;
                default:
                  valid = false;
              }
              switch (key) {
                case "type":
                  _results.push(this.validate_type_property(property, allowParameterKeys));
                  break;
                case "usage":
                  if (!allowParameterKeys) {
                    throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + "' is invalid in a resource", property[0].start_mark);
                  } else {
                    _results.push(void 0);
                  }
                  break;
                case "securedBy":
                  _results.push(this.validate_secured_by(property));
                  break;
                default:
                  if (!valid) {
                    throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + ("' is invalid in a " + context), property[0].start_mark);
                  } else {
                    _results.push(void 0);
                  }
              }
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_secured_by = function(property) {
      var secScheme, secSchemes, securitySchemeName, _i, _len, _ref1, _results;
      if (!util.isSequence(property[1])) {
        throw new exports.ValidationError('while validating securityScheme', null, "property 'securedBy' must be an array", property[0].start_mark);
      }
      secSchemes = this.get_list_values(property[1].value);
      if (this.hasDuplicates(secSchemes)) {
        throw new exports.ValidationError('while validating securityScheme consumption', null, 'securitySchemes can only be referenced once in a securedBy property', property[0].start_mark);
      }
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        secScheme = _ref1[_i];
        if (util.isSequence(secScheme)) {
          throw new exports.ValidationError('while validating securityScheme consumption', null, 'securityScheme reference cannot be an array', secScheme.start_mark);
        }
        if (!util.isNull(secScheme)) {
          securitySchemeName = this.key_or_value(secScheme);
          if (!this.get_security_scheme(securitySchemeName)) {
            throw new exports.ValidationError('while validating securityScheme consumption', null, 'there is no securityScheme named ' + securitySchemeName, secScheme.start_mark);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_protocols_property = function(property) {
      var protocol, _i, _len, _ref1, _ref2, _results;
      if (!util.isSequence(property[1])) {
        throw new exports.ValidationError('while validating protocols', null, 'property must be an array', property[0].start_mark);
      }
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        protocol = _ref1[_i];
        if (!util.isString(protocol)) {
          throw new exports.ValidationError('while validating protocols', null, 'value must be a string', protocol.start_mark);
        }
        if ((_ref2 = protocol.value) !== 'HTTP' && _ref2 !== 'HTTPS') {
          throw new exports.ValidationError('while validating protocols', null, 'only HTTP and HTTPS values are allowed', protocol.start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_type_property = function(property) {
      var parameter, typeName, _i, _len, _ref1, _results;
      if (!(util.isMapping(property[1]) || util.isString(property[1]))) {
        throw new exports.ValidationError('while validating resource types', null, "property 'type' must be a string or a map", property[0].start_mark);
      }
      if (util.isMapping(property[1])) {
        if (property[1].value.length > 1) {
          throw new exports.ValidationError('while validating resource types', null, 'a resource or resourceType can inherit from a single resourceType', property[0].start_mark);
        }
      }
      typeName = this.key_or_value(property[1]);
      if (!(typeName != null ? typeName.trim() : void 0)) {
        throw new exports.ValidationError('while validating resource type consumption', null, 'resource type name must be provided', property[1].start_mark);
      }
      if (!(this.isParameterKeyValue(typeName) || this.get_type(typeName))) {
        throw new exports.ValidationError('while validating resource type consumption', null, "there is no resource type named " + typeName, property[1].start_mark);
      }
      if (util.isMapping(property[1])) {
        _ref1 = property[1].value;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          parameter = _ref1[_i];
          if (!(util.isNull(parameter[1]) || util.isMapping(parameter[1]))) {
            throw new exports.ValidationError('while validating resource consumption', null, 'resource type parameters must be in a map', parameter[1].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_method = function(method, allowParameterKeys, context) {
      var canonicalKey, key, methodProperties, property, valid, _i, _len, _ref1, _results;
      if (context == null) {
        context = 'method';
      }
      if (util.isNull(method[1])) {
        return;
      }
      if (!util.isMapping(method[1])) {
        throw new exports.ValidationError('while validating methods', null, "method must be a map", method[0].start_mark);
      }
      methodProperties = {};
      _ref1 = method[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(methodProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating method', "property already used");
        if (this.validate_common_properties(property, allowParameterKeys, context)) {
          continue;
        }
        key = property[0].value;
        canonicalKey = this.canonicalizePropertyName(key, allowParameterKeys);
        valid = true;
        switch (canonicalKey) {
          case 'headers':
            this.validate_headers(property, allowParameterKeys);
            break;
          case 'queryParameters':
            this.validate_query_params(property, allowParameterKeys);
            break;
          case 'body':
            this.validate_body(property, allowParameterKeys, null, false);
            break;
          case 'responses':
            this.validate_responses(property, allowParameterKeys);
            break;
          case 'baseUriParameters':
            if (!this.baseUri) {
              throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters defined when there is no baseUri', property[0].start_mark);
            }
            if (!util.isNullableMapping(property[1])) {
              throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', property[0].start_mark);
            }
            this.validate_uri_parameters(this.baseUri, property[1], allowParameterKeys);
            break;
          case 'protocols':
            this.validate_protocols_property(property);
            break;
          default:
            valid = false;
        }
        switch (key) {
          case 'securedBy':
            _results.push(this.validate_secured_by(property));
            break;
          case 'usage':
            if (!(allowParameterKeys && context === 'trait')) {
              throw new exports.ValidationError('while validating resources', null, "property: 'usage' is invalid in a " + context, property[0].start_mark);
            } else {
              _results.push(void 0);
            }
            break;
          default:
            if (!valid) {
              throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + "' is invalid in a " + context, property[0].start_mark);
            } else {
              _results.push(void 0);
            }
        }
      }
      return _results;
    };

    Validator.prototype.validate_responses = function(responses, allowParameterKeys) {
      var response, responseValues, _i, _len, _ref1, _results;
      if (util.isNull(responses[1])) {
        return;
      }
      if (!util.isMapping(responses[1])) {
        throw new exports.ValidationError('while validating responses', null, "property: 'responses' must be a map", responses[0].start_mark);
      }
      responseValues = {};
      _ref1 = responses[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        response = _ref1[_i];
        if (!util.isNullableMapping(response[1])) {
          throw new exports.ValidationError('while validating responses', null, 'each response must be a map', response[1].start_mark);
        }
        this.trackRepeatedProperties(responseValues, this.canonicalizePropertyName(response[0].value, true), response[0], 'while validating responses', "response code already used");
        _results.push(this.validate_response(response, allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_query_params = function(property, allowParameterKeys) {
      var param, queryParameters, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating query parameters', null, "property: 'queryParameters' must be a map", property[0].start_mark);
      }
      queryParameters = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, "each query parameter must be a map", param[1].start_mark);
        }
        this.trackRepeatedProperties(queryParameters, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating query parameter', "parameter name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_form_params = function(property, allowParameterKeys) {
      var formParameters, param, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating query parameters', null, "property: 'formParameters' must be a map", property[0].start_mark);
      }
      formParameters = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, 'each form parameter must be a map', param[1].start_mark);
        }
        this.trackRepeatedProperties(formParameters, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating form parameter', "parameter name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_headers = function(property, allowParameterKeys) {
      var headerNames, param, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating headers', null, "property: 'headers' must be a map", property[0].start_mark);
      }
      headerNames = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, "each header must be a map", param[1].start_mark);
        }
        this.trackRepeatedProperties(headerNames, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating headers', "header name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_response = function(response, allowParameterKeys) {
      var canonicalKey, property, responseCode, responseProperties, valid, _i, _j, _len, _len1, _ref1, _ref2, _results;
      if (util.isSequence(response[0])) {
        if (!response[0].value.length) {
          throw new exports.ValidationError('while validating responses', null, 'there must be at least one response code', response[0].start_mark);
        }
        _ref1 = response[0].value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          responseCode = _ref1[_i];
          if (!(this.isParameterKey(responseCode) || util.isInteger(responseCode) || !isNaN(this.canonicalizePropertyName(responseCode, allowParameterKeys)))) {
            throw new exports.ValidationError('while validating responses', null, "each response key must be an integer", responseCode.start_mark);
          }
        }
      } else if (!(this.isParameterKey(response) || util.isInteger(response[0]) || !isNaN(this.canonicalizePropertyName(response[0].value, allowParameterKeys)))) {
        throw new exports.ValidationError('while validating responses', null, "each response key must be an integer", response[0].start_mark);
      }
      if (!util.isNullableMapping(response[1])) {
        throw new exports.ValidationError('while validating responses', null, "each response property must be a map", response[0].start_mark);
      }
      if (util.isMapping(response[1])) {
        responseProperties = {};
        _ref2 = response[1].value;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          property = _ref2[_j];
          canonicalKey = this.canonicalizePropertyName(property[0].value, allowParameterKeys);
          this.trackRepeatedProperties(responseProperties, canonicalKey, property[0], 'while validating responses', "property already used");
          valid = true;
          if (!this.isParameterKey(property)) {
            switch (property[0].value) {
              case "description":
                if (!util.isScalar(property[1])) {
                  throw new exports.ValidationError('while validating responses', null, 'property description must be a string', response[0].start_mark);
                }
                break;
              default:
                valid = false;
            }
            switch (canonicalKey) {
              case "body":
                _results.push(this.validate_body(property, allowParameterKeys, null, true));
                break;
              case "headers":
                if (!util.isNullableMapping(property[1])) {
                  throw new exports.ValidationError('while validating resources', null, "property 'headers' must be a map", property[0].start_mark);
                }
                _results.push(this.validate_headers(property));
                break;
              default:
                if (!valid) {
                  throw new exports.ValidationError('while validating response', null, "property: '" + property[0].value + "' is invalid in a response", property[0].start_mark);
                } else {
                  _results.push(void 0);
                }
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.isHttpMethod = function(value, allowParameterKeys) {
      var _ref1;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (value) {
        value = this.canonicalizePropertyName(value, allowParameterKeys);
        return (_ref1 = value.toLowerCase()) === 'options' || _ref1 === 'get' || _ref1 === 'head' || _ref1 === 'post' || _ref1 === 'put' || _ref1 === 'delete' || _ref1 === 'trace' || _ref1 === 'connect' || _ref1 === 'patch';
      }
      return false;
    };

    Validator.prototype.isParameterValue = function(property) {
      return this.isParameterKey(property, false);
    };

    Validator.prototype.isParameterKey = function(property, checkKey) {
      var offset;
      if (checkKey == null) {
        checkKey = true;
      }
      offset = checkKey ? 0 : 1;
      if (!(checkKey || util.isScalar(property[1]))) {
        return false;
      }
      if (this.isParameterKeyValue(property[offset].value)) {
        return true;
      } else if (property[offset].value.match(/<<\s*([^\|\s>]+)\s*\|.*\s*>>/g)) {
        throw new exports.ValidationError('while validating parameter', null, "unknown function applied to property name", property[0].start_mark);
      }
      return false;
    };

    Validator.prototype.isParameterKeyValue = function(value) {
      if (value.match(/<<\s*([^\|\s>]+)\s*>>/g) || value.match(/<<\s*([^\|\s>]+)\s*(\|\s*\!\s*(singularize|pluralize))?\s*>>/g)) {
        return true;
      }
      return false;
    };

    Validator.prototype.validate_body = function(property, allowParameterKeys, bodyMode, isResponseBody) {
      var bodyProperties, bodyProperty, canonicalProperty, implicitMode, key, start_mark, valid, _i, _len, _ref1;
      if (bodyMode == null) {
        bodyMode = null;
      }
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating body', null, "property: body specification must be a map", property[0].start_mark);
      }
      implicitMode = ["implicit", "forcedImplicit"];
      bodyProperties = {};
      _ref1 = property[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        bodyProperty = _ref1[_i];
        this.trackRepeatedProperties(bodyProperties, this.canonicalizePropertyName(bodyProperty[0].value, true), bodyProperty[0], 'while validating body', "property already used");
        if (this.isParameterKey(bodyProperty)) {
          if (!allowParameterKeys) {
            throw new exports.ValidationError('while validating body', null, "property '" + bodyProperty[0].value + "' is invalid in a resource", bodyProperty[0].start_mark);
          }
        } else if (bodyProperty[0].value.match(/^[^\/]+\/[^\/]+$/)) {
          if (bodyMode && bodyMode !== "explicit") {
            throw new exports.ValidationError('while validating body', null, "not compatible with implicit default Media Type", bodyProperty[0].start_mark);
          }
          bodyMode = "explicit";
          this.validate_body(bodyProperty, allowParameterKeys, "forcedImplicit", isResponseBody);
        } else {
          key = bodyProperty[0].value;
          canonicalProperty = this.canonicalizePropertyName(key, allowParameterKeys);
          valid = true;
          switch (canonicalProperty) {
            case "formParameters":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              this.validate_form_params(bodyProperty, allowParameterKeys);
              break;
            default:
              valid = false;
          }
          switch (key) {
            case "example":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              if (!util.isScalar(bodyProperty[1])) {
                throw new exports.ValidationError('while validating body', null, "example must be a string", bodyProperty[0].start_mark);
              }
              break;
            case "schema":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              if (!util.isScalar(bodyProperty[1])) {
                throw new exports.ValidationError('while validating body', null, "schema must be a string", bodyProperty[0].start_mark);
              }
              this.validateSchema(bodyProperty[1]);
              break;
            default:
              if (!valid) {
                throw new exports.ValidationError('while validating body', null, "property: '" + bodyProperty[0].value + "' is invalid in a body", bodyProperty[0].start_mark);
              }
          }
        }
      }
      if ("formParameters" in bodyProperties) {
        start_mark = bodyProperties.formParameters.start_mark;
        if (isResponseBody) {
          throw new exports.ValidationError('while validating body', null, "formParameters cannot be used to describe response bodies", start_mark);
        }
        if ("schema" in bodyProperties || "example" in bodyProperties) {
          throw new exports.ValidationError('while validating body', null, "formParameters cannot be used together with the example or schema properties", start_mark);
        }
      }
      if (bodyMode === "implicit") {
        if (!this.get_media_type()) {
          throw new exports.ValidationError('while validating body', null, "body tries to use default Media Type, but mediaType is null", property[0].start_mark);
        }
      }
    };

    Validator.prototype.validateSchema = function(property) {
      var error, lint, mark, schema;
      if (this.isXmlSchema(property.value)) {
        return void 0;
      } else if (this.isJsonSchema(property.value)) {
        lint = jsonlint(property.value);
        if (lint.error) {
          mark = this.create_mark(property.start_mark.line + lint.line, 0);
          if (property.end_mark.line === mark.line && property.end_mark.column === 0) {
            mark.line--;
          }
          throw new exports.ValidationError('while validating body', null, "schema is not valid JSON error: '" + lint.error + "'", mark);
        }
        try {
          return schema = JSON.parse(property.value);
        } catch (_error) {
          error = _error;
          throw new exports.ValidationError('while validating body', null, "schema is not valid JSON error: '" + error + "'", property.start_mark);
        }
      }
    };

    Validator.prototype.isJsonSchema = function(string) {
      return string != null ? string.match(/^\s*\{/) : void 0;
    };

    Validator.prototype.isXmlSchema = function(string) {
      return string != null ? string.match(/^\s*(<\?xml[^>]+>)?[\s\n]*<xs:schema/) : void 0;
    };

    Validator.prototype.validate_common_properties = function(property, allowParameterKeys, context) {
      var use, _i, _len, _ref1;
      if (this.isParameterKey(property)) {
        if (!allowParameterKeys) {
          throw new exports.ValidationError('while validating resources', null, "property '" + property[0].value + "' is invalid in a resource", property[0].start_mark);
        }
        return true;
      } else {
        switch (property[0].value) {
          case "displayName":
            if (context === 'method') {
              return false;
            }
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'displayName' must be a string", property[0].start_mark);
            }
            return true;
          case "description":
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'description' must be a string", property[0].start_mark);
            }
            return true;
          case "is":
            if (!util.isSequence(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'is' must be an array", property[0].start_mark);
            }
            _ref1 = property[1].value;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              use = _ref1[_i];
              this.validate_trait_use(use);
            }
            return true;
        }
      }
      return false;
    };

    Validator.prototype.validate_trait_use = function(node) {
      var parameter, traitName, traitValue, _i, _len, _ref1, _results;
      if (!(util.isScalar(node) || util.isMapping(node))) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait must be a string or a map', node.start_mark);
      }
      traitName = this.key_or_value(node);
      if (!(traitName != null ? traitName.trim() : void 0)) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait name must be provided', node.start_mark);
      }
      if (!(this.isParameterKeyValue(traitName) || this.get_trait(traitName))) {
        throw new exports.ValidationError('while validating trait consumption', null, "there is no trait named " + traitName, node.start_mark);
      }
      if (util.isScalar(node)) {
        return;
      }
      traitValue = node.value[0][1];
      if (!(util.isNull(traitValue) || util.isMapping(traitValue))) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait must be a map', traitValue.start_mark);
      }
      if (util.isNull(traitValue)) {
        return;
      }
      _ref1 = traitValue.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        parameter = _ref1[_i];
        if (!util.isScalar(parameter[1])) {
          throw new exports.ValidationError('while validating trait consumption', null, 'parameter value must be a scalar', parameter[1].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.child_methods = function(node) {
      var _this = this;
      if (!(node && util.isMapping(node))) {
        return [];
      }
      return node.value.filter(function(childNode) {
        return _this.isHttpMethod(childNode[0].value);
      });
    };

    Validator.prototype.has_property = function(node, property) {
      if (node && util.isMapping(node)) {
        return node.value.some(function(childNode) {
          return childNode[0].value && typeof childNode[0].value !== "object" && childNode[0].value === property;
        });
      }
      return false;
    };

    Validator.prototype.property_value = function(node, property) {
      var filteredNodes;
      filteredNodes = node.value.filter(function(childNode) {
        return typeof childNode[0].value !== "object" && childNode[0].value === property;
      });
      if (filteredNodes.length) {
        return filteredNodes[0][1].value;
      }
    };

    Validator.prototype.get_property = function(node, property) {
      var filteredNodes,
        _this = this;
      if (node && util.isMapping(node)) {
        filteredNodes = node.value.filter(function(childNode) {
          return util.isString(childNode[0]) && childNode[0].value === property;
        });
        if (filteredNodes.length > 0) {
          if (filteredNodes[0].length > 0) {
            return filteredNodes[0][1];
          }
        }
      }
      return [];
    };

    Validator.prototype.get_properties = function(node, property) {
      var prop, properties, _i, _len, _ref1;
      properties = [];
      if (node && util.isMapping(node)) {
        _ref1 = node.value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          prop = _ref1[_i];
          if (util.isString(prop[0]) && prop[0].value === property) {
            properties.push(prop);
          } else {
            properties = properties.concat(this.get_properties(prop[1], property));
          }
        }
      }
      return properties;
    };

    Validator.prototype.valid_absolute_uris = function(node) {
      var repeatedUri, uris;
      uris = this.get_absolute_uris(node);
      if (repeatedUri = this.hasDuplicatesUris(uris)) {
        throw new exports.ValidationError('while validating trait consumption', null, "two resources share same URI " + repeatedUri.uri, repeatedUri.mark);
      }
    };

    Validator.prototype.get_absolute_uris = function(node, parentPath) {
      var childResource, child_resources, response, uri, _i, _len;
      response = [];
      if (!util.isNullableMapping(node)) {
        throw new exports.ValidationError('while validating resources', null, 'resource is not a map', node.start_mark);
      }
      child_resources = this.child_resources(node);
      for (_i = 0, _len = child_resources.length; _i < _len; _i++) {
        childResource = child_resources[_i];
        if (parentPath != null) {
          uri = parentPath + childResource[0].value;
        } else {
          uri = childResource[0].value;
        }
        response.push({
          uri: uri,
          mark: childResource[0].start_mark
        });
        response = response.concat(this.get_absolute_uris(childResource[1], uri));
      }
      return response;
    };

    Validator.prototype.key_or_value = function(node) {
      var possibleKeyName, _ref1, _ref2, _ref3;
      if (node instanceof nodes.ScalarNode) {
        return node.value;
      }
      if (node instanceof nodes.MappingNode) {
        possibleKeyName = node != null ? (_ref1 = node.value) != null ? (_ref2 = _ref1[0]) != null ? (_ref3 = _ref2[0]) != null ? _ref3.value : void 0 : void 0 : void 0 : void 0;
        if (possibleKeyName) {
          return possibleKeyName;
        }
      }
      return null;
    };

    Validator.prototype.value_or_undefined = function(node) {
      if (node instanceof nodes.MappingNode) {
        return node.value;
      }
      return void 0;
    };

    Validator.prototype.validate_base_uri = function(baseUriNode) {
      var baseUri, err, expressions, protocol, template, _ref1, _ref2;
      baseUri = (_ref1 = baseUriNode.value) != null ? _ref1.trim() : void 0;
      if (!baseUri) {
        throw new exports.ValidationError('while validating baseUri', null, 'baseUri must have a value', baseUriNode.start_mark);
      }
      protocol = ((url.parse(baseUri)).protocol || 'http:').slice(0, -1).toUpperCase();
      if (protocol !== 'HTTP' && protocol !== 'HTTPS') {
        throw new exports.ValidationError('while validating baseUri', null, 'baseUri protocol must be either HTTP or HTTPS', baseUriNode.start_mark);
      }
      try {
        template = uritemplate.parse(baseUri);
      } catch (_error) {
        err = _error;
        throw new exports.ValidationError('while validating baseUri', null, err != null ? (_ref2 = err.options) != null ? _ref2.message : void 0 : void 0, baseUriNode.start_mark);
      }
      expressions = template.expressions.filter(function(expr) {
        return 'templateText' in expr;
      }).map(function(expression) {
        return expression.templateText;
      });
      if (__indexOf.call(expressions, 'version') >= 0) {
        return true;
      }
    };

    Validator.prototype.get_validation_errors = function() {
      return this.validation_errors;
    };

    Validator.prototype.is_valid = function() {
      return this.validation_errors.length === 0;
    };

    Validator.prototype.hasDuplicatesUris = function(array) {
      var item, output, _i, _len;
      output = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item.uri in output) {
          return item;
        }
        output[item.uri] = item;
      }
      return false;
    };

    Validator.prototype.hasDuplicates = function(array) {
      var item, output, _i, _len;
      output = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item in output) {
          return true;
        }
        output[item] = true;
      }
      return false;
    };

    return Validator;

  })();

}).call(this);

},{"./errors":30,"./nodes":34,"./traits":45,"./util":47,"json-lint":50,"uritemplate":52,"url":25}],49:[function(require,module,exports){
/*!
 * inflection
 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
 * MIT Licensed
 *
 * @fileoverview
 * A port of inflection-js to node.js module.
 */

( function ( root, factory ){
  if( typeof define === 'function' && define.amd ){
    define([], factory );
  }else if( typeof exports === 'object' ){
    module.exports = factory();
  }else{
    root.inflection = factory();
  }
}( this, function (){

  /**
   * @description This is a list of nouns that use the same form for both singular and plural.
   *              This list should remain entirely in lower case to correctly match Strings.
   * @private
   */
  var uncountable_words = [
    'equipment', 'information', 'rice', 'money', 'species',
    'series', 'fish', 'sheep', 'moose', 'deer', 'news'
  ];

  /**
   * @description These rules translate from the singular form of a noun to its plural form.
   * @private
   */
  var plural_rules = [

    // do not replace if its already a plural word
    [ new RegExp( '(m)en$',      'gi' )],
    [ new RegExp( '(pe)ople$',   'gi' )],
    [ new RegExp( '(child)ren$', 'gi' )],
    [ new RegExp( '([ti])a$',    'gi' )],
    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' )],
    [ new RegExp( '(hive)s$',           'gi' )],
    [ new RegExp( '(tive)s$',           'gi' )],
    [ new RegExp( '(curve)s$',          'gi' )],
    [ new RegExp( '([lr])ves$',         'gi' )],
    [ new RegExp( '([^fo])ves$',        'gi' )],
    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' )],
    [ new RegExp( '(s)eries$',          'gi' )],
    [ new RegExp( '(m)ovies$',          'gi' )],
    [ new RegExp( '(x|ch|ss|sh)es$',    'gi' )],
    [ new RegExp( '([m|l])ice$',        'gi' )],
    [ new RegExp( '(bus)es$',           'gi' )],
    [ new RegExp( '(o)es$',             'gi' )],
    [ new RegExp( '(shoe)s$',           'gi' )],
    [ new RegExp( '(cris|ax|test)es$',  'gi' )],
    [ new RegExp( '(octop|vir)i$',      'gi' )],
    [ new RegExp( '(alias|status)es$',  'gi' )],
    [ new RegExp( '^(ox)en',            'gi' )],
    [ new RegExp( '(vert|ind)ices$',    'gi' )],
    [ new RegExp( '(matr)ices$',        'gi' )],
    [ new RegExp( '(quiz)zes$',         'gi' )],

    // original rule
    [ new RegExp( '(m)an$', 'gi' ),                 '$1en' ],
    [ new RegExp( '(pe)rson$', 'gi' ),              '$1ople' ],
    [ new RegExp( '(child)$', 'gi' ),               '$1ren' ],
    [ new RegExp( '^(ox)$', 'gi' ),                 '$1en' ],
    [ new RegExp( '(ax|test)is$', 'gi' ),           '$1es' ],
    [ new RegExp( '(octop|vir)us$', 'gi' ),         '$1i' ],
    [ new RegExp( '(alias|status)$', 'gi' ),        '$1es' ],
    [ new RegExp( '(bu)s$', 'gi' ),                 '$1ses' ],
    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' ), '$1oes' ],
    [ new RegExp( '([ti])um$', 'gi' ),              '$1a' ],
    [ new RegExp( 'sis$', 'gi' ),                   'ses' ],
    [ new RegExp( '(?:([^f])fe|([lr])f)$', 'gi' ),  '$1$2ves' ],
    [ new RegExp( '(hive)$', 'gi' ),                '$1s' ],
    [ new RegExp( '([^aeiouy]|qu)y$', 'gi' ),       '$1ies' ],
    [ new RegExp( '(x|ch|ss|sh)$', 'gi' ),          '$1es' ],
    [ new RegExp( '(matr|vert|ind)ix|ex$', 'gi' ),  '$1ices' ],
    [ new RegExp( '([m|l])ouse$', 'gi' ),           '$1ice' ],
    [ new RegExp( '(quiz)$', 'gi' ),                '$1zes' ],

    [ new RegExp( 's$', 'gi' ), 's' ],
    [ new RegExp( '$', 'gi' ),  's' ]
  ];

  /**
   * @description These rules translate from the plural form of a noun to its singular form.
   * @private
   */
  var singular_rules = [

    // do not replace if its already a singular word
    [ new RegExp( '(m)an$',                 'gi' )],
    [ new RegExp( '(pe)rson$',              'gi' )],
    [ new RegExp( '(child)$',               'gi' )],
    [ new RegExp( '^(ox)$',                 'gi' )],
    [ new RegExp( '(ax|test)is$',           'gi' )],
    [ new RegExp( '(octop|vir)us$',         'gi' )],
    [ new RegExp( '(alias|status)$',        'gi' )],
    [ new RegExp( '(bu)s$',                 'gi' )],
    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' )],
    [ new RegExp( '([ti])um$',              'gi' )],
    [ new RegExp( 'sis$',                   'gi' )],
    [ new RegExp( '(?:([^f])fe|([lr])f)$',  'gi' )],
    [ new RegExp( '(hive)$',                'gi' )],
    [ new RegExp( '([^aeiouy]|qu)y$',       'gi' )],
    [ new RegExp( '(x|ch|ss|sh)$',          'gi' )],
    [ new RegExp( '(matr|vert|ind)ix|ex$',  'gi' )],
    [ new RegExp( '([m|l])ouse$',           'gi' )],
    [ new RegExp( '(quiz)$',                'gi' )],

    // original rule
    [ new RegExp( '(m)en$', 'gi' ),                                                       '$1an' ],
    [ new RegExp( '(pe)ople$', 'gi' ),                                                    '$1rson' ],
    [ new RegExp( '(child)ren$', 'gi' ),                                                  '$1' ],
    [ new RegExp( '([ti])a$', 'gi' ),                                                     '$1um' ],
    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ), '$1$2sis' ],
    [ new RegExp( '(hive)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(tive)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(curve)s$', 'gi' ),                                                    '$1' ],
    [ new RegExp( '([lr])ves$', 'gi' ),                                                   '$1f' ],
    [ new RegExp( '([^fo])ves$', 'gi' ),                                                  '$1fe' ],
    [ new RegExp( '(m)ovies$', 'gi' ),                                                    '$1ovie' ],
    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' ),                                           '$1y' ],
    [ new RegExp( '(s)eries$', 'gi' ),                                                    '$1eries' ],
    [ new RegExp( '(x|ch|ss|sh)es$', 'gi' ),                                              '$1' ],
    [ new RegExp( '([m|l])ice$', 'gi' ),                                                  '$1ouse' ],
    [ new RegExp( '(bus)es$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(o)es$', 'gi' ),                                                       '$1' ],
    [ new RegExp( '(shoe)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(cris|ax|test)es$', 'gi' ),                                            '$1is' ],
    [ new RegExp( '(octop|vir)i$', 'gi' ),                                                '$1us' ],
    [ new RegExp( '(alias|status)es$', 'gi' ),                                            '$1' ],
    [ new RegExp( '^(ox)en', 'gi' ),                                                      '$1' ],
    [ new RegExp( '(vert|ind)ices$', 'gi' ),                                              '$1ex' ],
    [ new RegExp( '(matr)ices$', 'gi' ),                                                  '$1ix' ],
    [ new RegExp( '(quiz)zes$', 'gi' ),                                                   '$1' ],
    [ new RegExp( 'ss$', 'gi' ),                                                          'ss' ],
    [ new RegExp( 's$', 'gi' ),                                                           '' ]
  ];

  /**
   * @description This is a list of words that should not be capitalized for title case.
   * @private
   */
  var non_titlecased_words = [
    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
    'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
  ];

  /**
   * @description These are regular expressions used for converting between String formats.
   * @private
   */
  var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
  var underbar          = new RegExp( '_', 'g' );
  var space_or_underbar = new RegExp( '[\ _]', 'g' );
  var uppercase         = new RegExp( '([A-Z])', 'g' );
  var underbar_prefix   = new RegExp( '^_' );

  var inflector = {

  /**
   * A helper method that applies rules based replacement to a String.
   * @private
   * @function
   * @param {String} str String to modify and return based on the passed rules.
   * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
   * @param {Array: [String]} skip Strings to skip if they match
   * @param {String} override String to return as though this method succeeded (used to conform to APIs)
   * @returns {String} Return passed String modified by passed rules.
   * @example
   *
   *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
   */
    _apply_rules : function ( str, rules, skip, override ){
      if( override ){
        str = override;
      }else{
        var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

        if( !ignore ){
          var i = 0;
          var j = rules.length;

          for( ; i < j; i++ ){
            if( str.match( rules[ i ][ 0 ])){
              if( rules[ i ][ 1 ] !== undefined ){
                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
              }
              break;
            }
          }
        }
      }

      return str;
    },



  /**
   * This lets us detect if an Array contains a given element.
   * @public
   * @function
   * @param {Array} arr The subject array.
   * @param {Object} item Object to locate in the Array.
   * @param {Number} from_index Starts checking from this position in the Array.(optional)
   * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
   * @returns {Number} Return index position in the Array of the passed item.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
   *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
   */
    indexOf : function ( arr, item, from_index, compare_func ){
      if( !from_index ){
        from_index = -1;
      }

      var index = -1;
      var i     = from_index;
      var j     = arr.length;

      for( ; i < j; i++ ){
        if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
          index = i;
          break;
        }
      }

      return index;
    },



  /**
   * This function adds pluralization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} Singular English language nouns are returned in plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.pluralize( 'person' ); // === 'people'
   *     inflection.pluralize( 'octopus' ); // === 'octopi'
   *     inflection.pluralize( 'Hat' ); // === 'Hats'
   *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
   */
    pluralize : function ( str, plural ){
      return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
    },



  /**
   * This function adds singularization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @returns {String} Plural English language nouns are returned in singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.singularize( 'people' ); // === 'person'
   *     inflection.singularize( 'octopi' ); // === 'octopus'
   *     inflection.singularize( 'Hats' ); // === 'Hat'
   *     inflection.singularize( 'guys', 'person' ); // === 'person'
   */
    singularize : function ( str, singular ){
      return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
    },



  /**
   * This function adds camelization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in camel case.
   *                  additionally '/' is translated to '::'
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
   *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
   */
    camelize : function ( str, low_first_letter ){
      var str_path = str.split( '/' );
      var i        = 0;
      var j        = str_path.length;
      var str_arr, init_x, k, l, first;

      for( ; i < j; i++ ){
        str_arr = str_path[ i ].split( '_' );
        k       = 0;
        l       = str_arr.length;

        for( ; k < l; k++ ){
          if( k !== 0 ){
            str_arr[ k ] = str_arr[ k ].toLowerCase();
          }

          first = str_arr[ k ].charAt( 0 );
          first = low_first_letter && i === 0 && k === 0
            ? first.toLowerCase() : first.toUpperCase();
          str_arr[ k ] = first + str_arr[ k ].substring( 1 );
        }

        str_path[ i ] = str_arr.join( '' );
      }

      return str_path.join( '::' );
    },



  /**
   * This function adds underscore support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
   *                  Passing true will return as entered.
   * @returns {String} Camel cased words are returned as lower cased and underscored.
   *                  additionally '::' is translated to '/'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'MP', true ); // === 'MP'
   */
    underscore : function ( str, all_upper_case ){
      if( all_upper_case && str === str.toUpperCase()) return str;

      var str_path = str.split( '::' );
      var i        = 0;
      var j        = str_path.length;

      for( ; i < j; i++ ){
        str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
        str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
      }

      return str_path.join( '/' ).toLowerCase();
    },



  /**
   * This function adds humanize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in humanized form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.humanize( 'message_properties' ); // === 'Message properties'
   *     inflection.humanize( 'message_properties', true ); // === 'message properties'
   */
    humanize : function ( str, low_first_letter ){
      str = str.toLowerCase();
      str = str.replace( id_suffix, '' );
      str = str.replace( underbar, ' ' );

      if( !low_first_letter ){
        str = inflector.capitalize( str );
      }

      return str;
    },



  /**
   * This function adds capitalization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} All characters will be lower case and the first will be upper.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
   *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
   */
    capitalize : function ( str ){
      str = str.toLowerCase();

      return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
    },



  /**
   * This function adds dasherization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Replaces all spaces or underbars with dashes.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
   *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
   */
    dasherize : function ( str ){
      return str.replace( space_or_underbar, '-' );
    },



  /**
   * This function adds titleize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Capitalizes words as you would for a book title.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
   *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
   */
    titleize : function ( str ){
      str         = str.toLowerCase().replace( underbar, ' ' );
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;
      var d, k, l;

      for( ; i < j; i++ ){
        d = str_arr[ i ].split( '-' );
        k = 0;
        l = d.length;

        for( ; k < l; k++){
          if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
            d[ k ] = inflector.capitalize( d[ k ]);
          }
        }

        str_arr[ i ] = d.join( '-' );
      }

      str = str_arr.join( ' ' );
      str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

      return str;
    },



  /**
   * This function adds demodulize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Removes module names leaving only class names.(Ruby style)
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
   */
    demodulize : function ( str ){
      var str_arr = str.split( '::' );

      return str_arr[ str_arr.length - 1 ];
    },



  /**
   * This function adds tableize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return camel cased words into their underscored plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
   */
    tableize : function ( str ){
      str = inflector.underscore( str );
      str = inflector.pluralize( str );

      return str;
    },



  /**
   * This function adds classification support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
   */
    classify : function ( str ){
      str = inflector.camelize( str );
      str = inflector.singularize( str );

      return str;
    },



  /**
   * This function adds foreign key support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                 you can pass true to skip it.(optional)
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
   *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
   */
    foreign_key : function ( str, drop_id_ubar ){
      str = inflector.demodulize( str );
      str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';

      return str;
    },



  /**
   * This function adds ordinalize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return all found numbers their sequence like '22nd'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
   */
    ordinalize : function ( str ){
      var str_arr = str.split( ' ' );
      var i       = 0;
      var j       = str_arr.length;

      for( ; i < j; i++ ){
        var k = parseInt( str_arr[ i ], 10 );

        if( !isNaN( k )){
          var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
          var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
          var suf = 'th';

          if( ltd != '11' && ltd != '12' && ltd != '13' ){
            if( ld === '1' ){
              suf = 'st';
            }else if( ld === '2' ){
              suf = 'nd';
            }else if( ld === '3' ){
              suf = 'rd';
            }
          }

          str_arr[ i ] += suf;
        }
      }

      return str_arr.join( ' ' );
    },

  /**
   * This function performs multiple inflection methods on a string
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Array} arr An array of inflection methods.
   * @returns {String}
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
   */
    transform : function ( str, arr ){
      var i = 0;
      var j = arr.length;

      for( ;i < j; i++ ){
        var method = arr[ i ];

        if( this.hasOwnProperty( method )){
          str = this[ method ]( str );
        }
      }

      return str;
    }
  };

/**
 * @public
 */
  inflector.version = '1.3.8';

  return inflector;
}));

},{}],50:[function(require,module,exports){
(function( glob, undefined ) {

var rnumber = /[0-9]/,
	rnewline = /(\r\n|\r|\n)/,
	revidence = /\r\n|\r|\n/,
	rwhitespace = /(\s|\t)/,
	rvalidsolidus = /\\("|\\|\/|b|f|n|r|t|u[0-9]{4})/,
	rE = /^(\-|\+)?[0-9]/;


// Leeeeeeerrrrroooyy Jennkkkiiinnnss
function JSONLint( json, options ) {
	var self = this;

	if ( ! ( self instanceof JSONLint ) ) {
		return new JSONLint( json, options );
	}

	// Argument handling
	self.json = json || '';
	self.options = options || {};
	self.lower = self.json.toLowerCase();

	// Allow comments by default
	if ( ! self.options.hasOwnProperty( 'comments' ) ) {
		self.options.comments = true;
	}

	// Internals
	self.c = '';
	self.i = -1;
	self.length = self.json.length;
	self.line = 1;
	self.character = 0;
	self._evidence = self.json.split( revidence );
	self.endblock = '';
	self.commabreak = false;

	try {
		self.render();
	} catch ( e ) {
		if ( typeof e != 'string' ) {
			throw e;
		}
		self.error = e;
		self.setEvidence();
	}
}


// Meta (Please change contact info for republishing with changes)
JSONLint.contact = "Corey Hart (corey@codenothing.com)";
JSONLint.version = '[VERSION]';
JSONLint.date = '[DATE]';


// Methods
JSONLint.prototype = {

	// Rendering Start
	render: function(){
		var self = this, peek = '', content = false;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( content ) {
				throw "Unknown character '" + self.c + "', expecting end of file.";
			}
			else if ( self.c == '[' ) {
				content = true;
				self.array();
			}
			else if ( self.c == '{' ) {
				content = true;
				self.object();
			}
			else {
				throw "Unknown character '" + self.c + "', expecting opening block '{' or '[', or maybe a comment";
			}
		}

		// Check for pure whitespace
		if ( ! content ) {
			throw "Invalid JSON, no content.";
		}
	},

	// Multi line comment
	multicomment: function(){
		var self = this;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.c == "*" && self.json[ self.i + 1 ] == "/" ) {
				self.i++;
				self.character++;
				break;
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
		}
	},

	// Single line comment
	comment: function(){
		var self = this;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
				break;
			}
		}
	},

	// Array Block
	array: function(){
		// Keep reference of current endblock
		var self = this,
			_endblock = self.endblock,
			_commabreak = self.commabreak,
			ended = false;

		self.endblock = ']';
		self.commabreak = false;
		while ( ( ended = self.value() ) !== true && self.i < self.length ) {
			// Do nothing, just wait for array values to finish
		}

		if ( ! ended ) {
			throw "EOF Error. Expecting closing ']'";
		}

		// Reset previous endblock
		self.endblock = _endblock;
		self.commabreak = _commabreak;
	},

	// Object Block
	object: function(){
		// Keep reference of current endblock
		var self = this,
			_endblock = self.endblock,
			_commabreak = self.commabreak,
			found = false, peek = '', empty = true;

		self.endblock = '}';
		self.commabreak = false;
		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == '"' ) {
				empty = false;
				if ( self.key() === true ) {
					// Reset old endblock
					self.endblock = _endblock;
					self.commabreak = _commabreak;
					found = true;
					break;
				}
			}
			else if ( empty && self.c == '}' ) {
				self.endblock = _endblock;
				self.commabreak = _commabreak;
				found = true;
				break;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a string for key statement.";
			}
		}

		if ( ! found ) {
			throw "EOF Error, expecting closing '}'.";
		}
	},

	// Key Statement
	key: function(){
		var self = this;
		self.string();

		for ( var peek = ''; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == ":" ) {
				return self.value();
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a semicolon.";
			}
		}
	},

	// Value statement
	value: function(){
		var self = this, peek = '';

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == '{' ) {
				self.object();
				return self.endval();
			}
			else if ( self.c == '[' ) {
				self.array();
				return self.endval();
			}
			else if ( self.c == '"' ) {
				self.string();
				return self.endval();
			}
			else if ( self.json.indexOf( 'true', self.i ) === self.i ) {
				self.i += 3;
				self.character += 3;
				return self.endval();
			}
			else if ( self.json.indexOf( 'false', self.i ) === self.i ) {
				self.i += 4;
				self.character += 4;
				return self.endval();
			}
			else if ( self.json.indexOf( 'null', self.i ) === self.i ) {
				self.i += 3;
				self.character += 3;
				return self.endval();
			}
			else if ( self.c == '-' || rnumber.exec( self.c ) ) {
				return self.numeric();
			}
			else if ( self.c == ']' && self.endblock == ']' ) {
				if ( self.commabreak ) {
					throw "Unexpected End Of Array Error. Expecting a value statement.";
				}
				return true;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a value.";
			}
		}
	},

	// String statement
	string: function(){
		var self = this, found = false, m;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.c == "\\" ) {
				if ( ( m = rvalidsolidus.exec( self.json.substr( self.i ) ) ) && m.index === 0 ) {
					self.i += m[ 1 ].length;
					self.character += m[ 1 ].length;
				}
				else {
					throw "Invalid Reverse Solidus '\\' declaration.";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( self.c == '"' ) {
				found = true;
				break;
			}
		}

		// Make sure close string is found
		if ( ! found ) {
			throw "EOF: No close string '\"' found.";
		}
	},

	// Numeric Value
	numeric: function(){
		var self = this,
			negative = true,
			decimal = null,
			e = null,
			peek = '';

		// We need to jump back a character to catch the whole number
		self.i--;
		self.character--;
		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			// Handle initial negative sign
			if ( negative ) {
				negative = false;
				if ( self.c == '-' ) {
					if ( ! rnumber.exec( self.json[ self.i + 1 ] ) ) {
						throw "Unknown Character '" + self.c + "' following a negative, expecting a numeric value.";
					}
					continue;
				}
			}

			// Only a single decimal is allowed in a numeric value
			if ( decimal && self.c == '.' ) {
				decimal = false;
				e = true;
				continue;
			}
			// Only a single e notation is allowed in a numeric value
			else if ( e && self.c.toLowerCase() == 'e' ) {
				e = false;
				negative = true;
				if ( rE.exec( self.json.substr( self.i + 1, 2 ) ) ) {
					self.character++;
					self.i++;
				}
				else {
					self.character++;
					throw "Unknown Character '" + self.json[ self.i + 1 ] + "' following e notation, expecting a numeric value.";
				}
			}
			// Normal Digit
			else if ( rnumber.exec( self.c ) ) {
				if ( decimal === null ) {
					decimal = true;
				}
			}
			// Assume end of number, and allow endval to handle it
			else {
				// Jump back a character to include the current one
				self.i--;
				self.character--;
				return self.endval();
			}
		}
	},

	// Ending a value statement
	endval: function(){
		var self = this, peek = '';
		self.commabreak = false;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == ',' ) {
				self.commabreak = true;
				break;
			}
			else if ( self.c == self.endblock ) {
				return true;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a comma or a closing '" + self.endblock + "'";
			}
		}
	},

	// Expose line of the error
	setEvidence: function(){
		var self = this, start = self.line - 5, end = start + 8, evidence = '';

		// Min start
		if ( start < 0 ) {
			start = 0;
			end = 8;
		}

		// Max end
		if ( end >= self._evidence.length ) {
			end = self._evidence.length;
		}

		// Evidence display
		for ( ; start < end; start++ ) {
			evidence += ( start === ( self.line - 1 ) ? "-> " : "   " ) +
				( start + 1 ) + '| ' +
				self._evidence[ start ] + "\n";
		}

		// Set the evidence display
		self.evidence = evidence;
	}
};


// Check for nodejs module system
if ( typeof exports == 'object' && typeof module == 'object' ) {
	module.exports = JSONLint;
}
// In a browser
else {
	glob.JSONLint = JSONLint;
}

})( this );

},{}],51:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this does have the nice side-effect of reducing the size
// of the code by reducing x.call() to merely x(), eliminating many
// hard-to-minify characters.
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
// engine that has a deployed base of browsers that support generators.
// However, SM's generators use the Python-inspired semantics of
// outdated ES6 drafts.  We would like to support ES6, but we'd also
// like to make it possible to use generators in deployed browsers, so
// we also support Python-style generators.  At some point we can remove
// this block.
var hasES6Generators;
try {
    /* jshint evil: true, nonew: false */
    new Function("(function* (){ yield 1; })");
    hasES6Generators = true;
} catch (e) {
    hasES6Generators = false;
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = deprecate(function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    }, "valueOf", "inspect");

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become fulfilled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be fulfilled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = deprecate(function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        });
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return isObject(object) &&
        typeof object.promiseDispatch === "function" &&
        typeof object.inspect === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var unhandledReasonsDisplayed = false;
var trackUnhandledRejections = true;
function displayUnhandledReasons() {
    if (
        !unhandledReasonsDisplayed &&
        typeof window !== "undefined" &&
        !window.Touch &&
        window.console
    ) {
        console.warn("[Q] Unhandled rejection reasons (should be empty):",
                     unhandledReasons);
    }

    unhandledReasonsDisplayed = true;
}

function logUnhandledReasons() {
    for (var i = 0; i < unhandledReasons.length; i++) {
        var reason = unhandledReasons[i];
        console.warn("Unhandled rejection reason:", reason);
    }
}

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;
    unhandledReasonsDisplayed = false;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;

        // Show unhandled rejection reasons if Node exits without handling an
        // outstanding rejection.  (Note that Browserify presently produces a
        // `process` global without the `EventEmitter` `on` method.)
        if (typeof process !== "undefined" && process.on) {
            process.on("exit", logUnhandledReasons);
        }
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
    displayUnhandledReasons();
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    if (typeof process !== "undefined" && process.on) {
        process.removeListener("exit", logUnhandledReasons);
    }
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;
            if (hasES6Generators) {
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return result.value;
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return exception.value;
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {String} custom error message (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, message) {
    return Q(object).timeout(ms, message);
};

Promise.prototype.timeout = function (ms, message) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require("/Users/aanand/IdeaProjects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/aanand/IdeaProjects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":9}],52:[function(require,module,exports){
(function (global){
/*global unescape, module, define, window, global*/

/*
 UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.
 Available via the MIT license.
*/

(function (exportCallback) {
    "use strict";

var UriTemplateError = (function () {

    function UriTemplateError (options) {
        this.options = options;
    }

    UriTemplateError.prototype.toString = function () {
        if (JSON && JSON.stringify) {
            return JSON.stringify(this.options);
        }
        else {
            return this.options;
        }
    };

    return UriTemplateError;
}());

var objectHelper = (function () {
    function isArray (value) {
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    function isString (value) {
        return Object.prototype.toString.apply(value) === '[object String]';
    }
    
    function isNumber (value) {
        return Object.prototype.toString.apply(value) === '[object Number]';
    }
    
    function isBoolean (value) {
        return Object.prototype.toString.apply(value) === '[object Boolean]';
    }
    
    function join (arr, separator) {
        var
            result = '',
            first = true,
            index;
        for (index = 0; index < arr.length; index += 1) {
            if (first) {
                first = false;
            }
            else {
                result += separator;
            }
            result += arr[index];
        }
        return result;
    }

    function map (arr, mapper) {
        var
            result = [],
            index = 0;
        for (; index < arr.length; index += 1) {
            result.push(mapper(arr[index]));
        }
        return result;
    }

    function filter (arr, predicate) {
        var
            result = [],
            index = 0;
        for (; index < arr.length; index += 1) {
            if (predicate(arr[index])) {
                result.push(arr[index]);
            }
        }
        return result;
    }

    function deepFreezeUsingObjectFreeze (object) {
        if (typeof object !== "object" || object === null) {
            return object;
        }
        Object.freeze(object);
        var property, propertyName;
        for (propertyName in object) {
            if (object.hasOwnProperty(propertyName)) {
                property = object[propertyName];
                // be aware, arrays are 'object', too
                if (typeof property === "object") {
                    deepFreeze(property);
                }
            }
        }
        return object;
    }

    function deepFreeze (object) {
        if (typeof Object.freeze === 'function') {
            return deepFreezeUsingObjectFreeze(object);
        }
        return object;
    }


    return {
        isArray: isArray,
        isString: isString,
        isNumber: isNumber,
        isBoolean: isBoolean,
        join: join,
        map: map,
        filter: filter,
        deepFreeze: deepFreeze
    };
}());

var charHelper = (function () {

    function isAlpha (chr) {
        return (chr >= 'a' && chr <= 'z') || ((chr >= 'A' && chr <= 'Z'));
    }

    function isDigit (chr) {
        return chr >= '0' && chr <= '9';
    }

    function isHexDigit (chr) {
        return isDigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');
    }

    return {
        isAlpha: isAlpha,
        isDigit: isDigit,
        isHexDigit: isHexDigit
    };
}());

var pctEncoder = (function () {
    var utf8 = {
        encode: function (chr) {
            // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html
            return unescape(encodeURIComponent(chr));
        },
        numBytes: function (firstCharCode) {
            if (firstCharCode <= 0x7F) {
                return 1;
            }
            else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {
                return 2;
            }
            else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {
                return 3;
            }
            else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {
                return 4;
            }
            // no valid first octet
            return 0;
        },
        isValidFollowingCharCode: function (charCode) {
            return 0x80 <= charCode && charCode <= 0xBF;
        }
    };

    /**
     * encodes a character, if needed or not.
     * @param chr
     * @return pct-encoded character
     */
    function encodeCharacter (chr) {
        var
            result = '',
            octets = utf8.encode(chr),
            octet,
            index;
        for (index = 0; index < octets.length; index += 1) {
            octet = octets.charCodeAt(index);
            result += '%' + (octet < 0x10 ? '0' : '') + octet.toString(16).toUpperCase();
        }
        return result;
    }

    /**
     * Returns, whether the given text at start is in the form 'percent hex-digit hex-digit', like '%3F'
     * @param text
     * @param start
     * @return {boolean|*|*}
     */
    function isPercentDigitDigit (text, start) {
        return text.charAt(start) === '%' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));
    }

    /**
     * Parses a hex number from start with length 2.
     * @param text a string
     * @param start the start index of the 2-digit hex number
     * @return {Number}
     */
    function parseHex2 (text, start) {
        return parseInt(text.substr(start, 2), 16);
    }

    /**
     * Returns whether or not the given char sequence is a correctly pct-encoded sequence.
     * @param chr
     * @return {boolean}
     */
    function isPctEncoded (chr) {
        if (!isPercentDigitDigit(chr, 0)) {
            return false;
        }
        var firstCharCode = parseHex2(chr, 1);
        var numBytes = utf8.numBytes(firstCharCode);
        if (numBytes === 0) {
            return false;
        }
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
            if (!isPercentDigitDigit(chr, 3*byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3*byteNumber + 1))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Reads as much as needed from the text, e.g. '%20' or '%C3%B6'. It does not decode!
     * @param text
     * @param startIndex
     * @return the character or pct-string of the text at startIndex
     */
    function pctCharAt(text, startIndex) {
        var chr = text.charAt(startIndex);
        if (!isPercentDigitDigit(text, startIndex)) {
            return chr;
        }
        var utf8CharCode = parseHex2(text, startIndex + 1);
        var numBytes = utf8.numBytes(utf8CharCode);
        if (numBytes === 0) {
            return chr;
        }
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
            if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {
                return chr;
            }
        }
        return text.substr(startIndex, 3 * numBytes);
    }

    return {
        encodeCharacter: encodeCharacter,
        isPctEncoded: isPctEncoded,
        pctCharAt: pctCharAt
    };
}());

var rfcCharHelper = (function () {

    /**
     * Returns if an character is an varchar character according 2.3 of rfc 6570
     * @param chr
     * @return (Boolean)
     */
    function isVarchar (chr) {
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '_' || pctEncoder.isPctEncoded(chr);
    }

    /**
     * Returns if chr is an unreserved character according 1.5 of rfc 6570
     * @param chr
     * @return {Boolean}
     */
    function isUnreserved (chr) {
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '-' || chr === '.' || chr === '_' || chr === '~';
    }

    /**
     * Returns if chr is an reserved character according 1.5 of rfc 6570
     * or the percent character mentioned in 3.2.1.
     * @param chr
     * @return {Boolean}
     */
    function isReserved (chr) {
        return chr === ':' || chr === '/' || chr === '?' || chr === '#' || chr === '[' || chr === ']' || chr === '@' || chr === '!' || chr === '$' || chr === '&' || chr === '(' ||
            chr === ')' || chr === '*' || chr === '+' || chr === ',' || chr === ';' || chr === '=' || chr === "'";
    }

    return {
        isVarchar: isVarchar,
        isUnreserved: isUnreserved,
        isReserved: isReserved
    };

}());

/**
 * encoding of rfc 6570
 */
var encodingHelper = (function () {

    function encode (text, passReserved) {
        var
            result = '',
            index,
            chr = '';
        if (typeof text === "number" || typeof text === "boolean") {
            text = text.toString();
        }
        for (index = 0; index < text.length; index += chr.length) {
            chr = text.charAt(index);
            result += rfcCharHelper.isUnreserved(chr) || (passReserved && rfcCharHelper.isReserved(chr)) ? chr : pctEncoder.encodeCharacter(chr);
        }
        return result;
    }

    function encodePassReserved (text) {
        return encode(text, true);
    }

    function encodeLiteralCharacter (literal, index) {
        var chr = pctEncoder.pctCharAt(literal, index);
        if (chr.length > 1) {
            return chr;
        }
        else {
            return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
        }
    }

    function encodeLiteral (literal) {
        var
            result = '',
            index,
            chr = '';
        for (index = 0; index < literal.length; index += chr.length) {
            chr = pctEncoder.pctCharAt(literal, index);
            if (chr.length > 1) {
                result += chr;
            }
            else {
                result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
            }
        }
        return result;
    }

    return {
        encode: encode,
        encodePassReserved: encodePassReserved,
        encodeLiteral: encodeLiteral,
        encodeLiteralCharacter: encodeLiteralCharacter
    };

}());


// the operators defined by rfc 6570
var operators = (function () {

    var
        bySymbol = {};

    function create (symbol) {
        bySymbol[symbol] = {
            symbol: symbol,
            separator: (symbol === '?') ? '&' : (symbol === '' || symbol === '+' || symbol === '#') ? ',' : symbol,
            named: symbol === ';' || symbol === '&' || symbol === '?',
            ifEmpty: (symbol === '&' || symbol === '?') ? '=' : '',
            first: (symbol === '+' ) ? '' : symbol,
            encode: (symbol === '+' || symbol === '#') ? encodingHelper.encodePassReserved : encodingHelper.encode,
            toString: function () {
                return this.symbol;
            }
        };
    }

    create('');
    create('+');
    create('#');
    create('.');
    create('/');
    create(';');
    create('?');
    create('&');
    return {
        valueOf: function (chr) {
            if (bySymbol[chr]) {
                return bySymbol[chr];
            }
            if ("=,!@|".indexOf(chr) >= 0) {
                return null;
            }
            return bySymbol[''];
        }
    };
}());


/**
 * Detects, whether a given element is defined in the sense of rfc 6570
 * Section 2.3 of the RFC makes clear defintions:
 * * undefined and null are not defined.
 * * the empty string is defined
 * * an array ("list") is defined, if it is not empty (even if all elements are not defined)
 * * an object ("map") is defined, if it contains at least one property with defined value
 * @param object
 * @return {Boolean}
 */
function isDefined (object) {
    var
        propertyName;
    if (object === null || object === undefined) {
        return false;
    }
    if (objectHelper.isArray(object)) {
        // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members
        return object.length > 0;
    }
    if (typeof object === "string" || typeof object === "number" || typeof object === "boolean") {
        // falsy values like empty strings, false or 0 are "defined"
        return true;
    }
    // else Object
    for (propertyName in object) {
        if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {
            return true;
        }
    }
    return false;
}

var LiteralExpression = (function () {
    function LiteralExpression (literal) {
        this.literal = encodingHelper.encodeLiteral(literal);
    }

    LiteralExpression.prototype.expand = function () {
        return this.literal;
    };

    LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;

    return LiteralExpression;
}());

var parse = (function () {

    function parseExpression (expressionText) {
        var
            operator,
            varspecs = [],
            varspec = null,
            varnameStart = null,
            maxLengthStart = null,
            index,
            chr = '';

        function closeVarname () {
            var varname = expressionText.substring(varnameStart, index);
            if (varname.length === 0) {
                throw new UriTemplateError({expressionText: expressionText, message: "a varname must be specified", position: index});
            }
            varspec = {varname: varname, exploded: false, maxLength: null};
            varnameStart = null;
        }

        function closeMaxLength () {
            if (maxLengthStart === index) {
                throw new UriTemplateError({expressionText: expressionText, message: "after a ':' you have to specify the length", position: index});
            }
            varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);
            maxLengthStart = null;
        }

        operator = (function (operatorText) {
            var op = operators.valueOf(operatorText);
            if (op === null) {
                throw new UriTemplateError({expressionText: expressionText, message: "illegal use of reserved operator", position: index, operator: operatorText});
            }
            return op;
        }(expressionText.charAt(0)));
        index = operator.symbol.length;

        varnameStart = index;

        for (; index < expressionText.length; index += chr.length) {
            chr = pctEncoder.pctCharAt(expressionText, index);

            if (varnameStart !== null) {
                // the spec says: varname =  varchar *( ["."] varchar )
                // so a dot is allowed except for the first char
                if (chr === '.') {
                    if (varnameStart === index) {
                        throw new UriTemplateError({expressionText: expressionText, message: "a varname MUST NOT start with a dot", position: index});
                    }
                    continue;
                }
                if (rfcCharHelper.isVarchar(chr)) {
                    continue;
                }
                closeVarname();
            }
            if (maxLengthStart !== null) {
                if (index === maxLengthStart && chr === '0') {
                    throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must not start with digit 0", position: index});
                }
                if (charHelper.isDigit(chr)) {
                    if (index - maxLengthStart >= 4) {
                        throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must have max 4 digits", position: index});
                    }
                    continue;
                }
                closeMaxLength();
            }
            if (chr === ':') {
                if (varspec.maxLength !== null) {
                    throw new UriTemplateError({expressionText: expressionText, message: "only one :maxLength is allowed per varspec", position: index});
                }
                if (varspec.exploded) {
                    throw new UriTemplateError({expressionText: expressionText, message: "an exploeded varspec MUST NOT be varspeced", position: index});
                }
                maxLengthStart = index + 1;
                continue;
            }
            if (chr === '*') {
                if (varspec === null) {
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded without varspec", position: index});
                }
                if (varspec.exploded) {
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded twice", position: index});
                }
                if (varspec.maxLength) {
                    throw new UriTemplateError({expressionText: expressionText, message: "an explode (*) MUST NOT follow to a prefix", position: index});
                }
                varspec.exploded = true;
                continue;
            }
            // the only legal character now is the comma
            if (chr === ',') {
                varspecs.push(varspec);
                varspec = null;
                varnameStart = index + 1;
                continue;
            }
            throw new UriTemplateError({expressionText: expressionText, message: "illegal character", character: chr, position: index});
        } // for chr
        if (varnameStart !== null) {
            closeVarname();
        }
        if (maxLengthStart !== null) {
            closeMaxLength();
        }
        varspecs.push(varspec);
        return new VariableExpression(expressionText, operator, varspecs);
    }

    function parse (uriTemplateText) {
        // assert filled string
        var
            index,
            chr,
            expressions = [],
            braceOpenIndex = null,
            literalStart = 0;
        for (index = 0; index < uriTemplateText.length; index += 1) {
            chr = uriTemplateText.charAt(index);
            if (literalStart !== null) {
                if (chr === '}') {
                    throw new UriTemplateError({templateText: uriTemplateText, message: "unopened brace closed", position: index});
                }
                if (chr === '{') {
                    if (literalStart < index) {
                        expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));
                    }
                    literalStart = null;
                    braceOpenIndex = index;
                }
                continue;
            }

            if (braceOpenIndex !== null) {
                // here just { is forbidden
                if (chr === '{') {
                    throw new UriTemplateError({templateText: uriTemplateText, message: "brace already opened", position: index});
                }
                if (chr === '}') {
                    if (braceOpenIndex + 1 === index) {
                        throw new UriTemplateError({templateText: uriTemplateText, message: "empty braces", position: braceOpenIndex});
                    }
                    try {
                        expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));
                    }
                    catch (error) {
                        if (error.prototype === UriTemplateError.prototype) {
                            throw new UriTemplateError({templateText: uriTemplateText, message: error.options.message, position: braceOpenIndex + error.options.position, details: error.options});
                        }
                        throw error;
                    }
                    braceOpenIndex = null;
                    literalStart = index + 1;
                }
                continue;
            }
            throw new Error('reached unreachable code');
        }
        if (braceOpenIndex !== null) {
            throw new UriTemplateError({templateText: uriTemplateText, message: "unclosed brace", position: braceOpenIndex});
        }
        if (literalStart < uriTemplateText.length) {
            expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));
        }
        return new UriTemplate(uriTemplateText, expressions);
    }

    return parse;
}());

var VariableExpression = (function () {
    // helper function if JSON is not available
    function prettyPrint (value) {
        return (JSON && JSON.stringify) ? JSON.stringify(value) : value;
    }

    function isEmpty (value) {
        if (!isDefined(value)) {
            return true;
        }
        if (objectHelper.isString(value)) {
            return value === '';
        }
        if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {
            return false;
        }
        if (objectHelper.isArray(value)) {
            return value.length === 0;
        }
        for (var propertyName in value) {
            if (value.hasOwnProperty(propertyName)) {
                return false;
            }
        }
        return true;
    }

    function propertyArray (object) {
        var
            result = [],
            propertyName;
        for (propertyName in object) {
            if (object.hasOwnProperty(propertyName)) {
                result.push({name: propertyName, value: object[propertyName]});
            }
        }
        return result;
    }

    function VariableExpression (templateText, operator, varspecs) {
        this.templateText = templateText;
        this.operator = operator;
        this.varspecs = varspecs;
    }

    VariableExpression.prototype.toString = function () {
        return this.templateText;
    };

    function expandSimpleValue(varspec, operator, value) {
        var result = '';
        value = value.toString();
        if (operator.named) {
            result += encodingHelper.encodeLiteral(varspec.varname);
            if (value === '') {
                result += operator.ifEmpty;
                return result;
            }
            result += '=';
        }
        if (varspec.maxLength !== null) {
            value = value.substr(0, varspec.maxLength);
        }
        result += operator.encode(value);
        return result;
    }

    function valueDefined (nameValue) {
        return isDefined(nameValue.value);
    }

    function expandNotExploded(varspec, operator, value) {
        var
            arr = [],
            result = '';
        if (operator.named) {
            result += encodingHelper.encodeLiteral(varspec.varname);
            if (isEmpty(value)) {
                result += operator.ifEmpty;
                return result;
            }
            result += '=';
        }
        if (objectHelper.isArray(value)) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, operator.encode);
            result += objectHelper.join(arr, ',');
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, valueDefined);
            arr = objectHelper.map(arr, function (nameValue) {
                return operator.encode(nameValue.name) + ',' + operator.encode(nameValue.value);
            });
            result += objectHelper.join(arr, ',');
        }
        return result;
    }

    function expandExplodedNamed (varspec, operator, value) {
        var
            isArray = objectHelper.isArray(value),
            arr = [];
        if (isArray) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, function (listElement) {
                var tmp = encodingHelper.encodeLiteral(varspec.varname);
                if (isEmpty(listElement)) {
                    tmp += operator.ifEmpty;
                }
                else {
                    tmp += '=' + operator.encode(listElement);
                }
                return tmp;
            });
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, valueDefined);
            arr = objectHelper.map(arr, function (nameValue) {
                var tmp = encodingHelper.encodeLiteral(nameValue.name);
                if (isEmpty(nameValue.value)) {
                    tmp += operator.ifEmpty;
                }
                else {
                    tmp += '=' + operator.encode(nameValue.value);
                }
                return tmp;
            });
        }
        return objectHelper.join(arr, operator.separator);
    }

    function expandExplodedUnnamed (operator, value) {
        var
            arr = [],
            result = '';
        if (objectHelper.isArray(value)) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, operator.encode);
            result += objectHelper.join(arr, operator.separator);
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, function (nameValue) {
                return isDefined(nameValue.value);
            });
            arr = objectHelper.map(arr, function (nameValue) {
                return operator.encode(nameValue.name) + '=' + operator.encode(nameValue.value);
            });
            result += objectHelper.join(arr, operator.separator);
        }
        return result;
    }


    VariableExpression.prototype.expand = function (variables) {
        var
            expanded = [],
            index,
            varspec,
            value,
            valueIsArr,
            oneExploded = false,
            operator = this.operator;

        // expand each varspec and join with operator's separator
        for (index = 0; index < this.varspecs.length; index += 1) {
            varspec = this.varspecs[index];
            value = variables[varspec.varname];
            // if (!isDefined(value)) {
            // if (variables.hasOwnProperty(varspec.name)) {
            if (value === null || value === undefined) {
                continue;
            }
            if (varspec.exploded) {
                oneExploded = true;
            }
            valueIsArr = objectHelper.isArray(value);
            if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                expanded.push(expandSimpleValue(varspec, operator, value));
            }
            else if (varspec.maxLength && isDefined(value)) {
                // 2.4.1 of the spec says: "Prefix modifiers are not applicable to variables that have composite values."
                throw new Error('Prefix modifiers are not applicable to variables that have composite values. You tried to expand ' + this + " with " + prettyPrint(value));
            }
            else if (!varspec.exploded) {
                if (operator.named || !isEmpty(value)) {
                    expanded.push(expandNotExploded(varspec, operator, value));
                }
            }
            else if (isDefined(value)) {
                if (operator.named) {
                    expanded.push(expandExplodedNamed(varspec, operator, value));
                }
                else {
                    expanded.push(expandExplodedUnnamed(operator, value));
                }
            }
        }

        if (expanded.length === 0) {
            return "";
        }
        else {
            return operator.first + objectHelper.join(expanded, operator.separator);
        }
    };

    return VariableExpression;
}());

var UriTemplate = (function () {
    function UriTemplate (templateText, expressions) {
        this.templateText = templateText;
        this.expressions = expressions;
        objectHelper.deepFreeze(this);
    }

    UriTemplate.prototype.toString = function () {
        return this.templateText;
    };

    UriTemplate.prototype.expand = function (variables) {
        // this.expressions.map(function (expression) {return expression.expand(variables);}).join('');
        var
            index,
            result = '';
        for (index = 0; index < this.expressions.length; index += 1) {
            result += this.expressions[index].expand(variables);
        }
        return result;
    };

    UriTemplate.parse = parse;
    UriTemplate.UriTemplateError = UriTemplateError;
    return UriTemplate;
}());

    exportCallback(UriTemplate);

}(function (UriTemplate) {
        "use strict";
        // export UriTemplate, when module is present, or pass it to window or global
        if (typeof module !== "undefined") {
            module.exports = UriTemplate;
        }
        else if (typeof define === "function") {
            define([],function() {
                return UriTemplate;
            });
        }
        else if (typeof window !== "undefined") {
            window.UriTemplate = UriTemplate;
        }
        else {
            global.UriTemplate = UriTemplate;
        }
    }
));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],53:[function(require,module,exports){
(function (process,Buffer){
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var Url = require("url")
  , spawn = require("child_process").spawn
  , fs = require('fs');

exports.XMLHttpRequest = function() {
  /**
   * Private variables
   */
  var self = this;
  var http = require('http');
  var https = require('https');

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  };

  var headers = defaultHeaders;

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw "SecurityError: Request method not allowed";
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN";
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn('Refused to set unsafe header "' + header + '"');
      return;
    }
    if (sendFlag) {
      throw "INVALID_STATE_ERR: send flag is true";
    }
    headers[header] = value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    // @TODO Make this case insensitive
    if (typeof name === "string" && headers[name]) {
      return headers[name];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: connection must be opened before send() is called";
    }

    if (sendFlag) {
      throw "INVALID_STATE_ERR: send has already been called";
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case 'https:':
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case 'http:':
        host = url.hostname;
        break;

      case 'file:':
        local = true;
        break;

      case undefined:
      case '':
        host = "localhost";
        break;

      default:
        throw "Protocol not supported.";
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw "XMLHttpRequest: Only GET method is supported";
      }

      if (settings.async) {
        fs.readFile(url.pathname, 'utf8', function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, 'utf8');
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : '');

    // Set the Host header or the server may reject the request
    headers["Host"] = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers["Host"] += ':' + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password == "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers["Authorization"] = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? 'GET' : settings.method,
            headers: headers
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on('error', errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on('data', function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on('end', function() {
          if (sendFlag) {
            // Discard the 'end' event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on('error', function(error) {
          self.handleError(error);
        });
      }

      // Error handler for the request
      function errorHandler(error) {
        self.handleError(error);
      }

      // Create the request
      request = doRequest(options, responseHandler).on('error', errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + data.replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      var statusText;
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      self.responseText = fs.readFileSync(contentFile, 'utf8');
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);
      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
        // If the file returned an error, handle it
        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, "");
        self.handleError(errorObj);
      } else {
        // If the file returned okay, parse its data and move to the DONE state
        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1");
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 503;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};

}).call(this,require("/Users/aanand/IdeaProjects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),require("buffer").Buffer)
},{"child_process":1,"fs":1,"http":3,"https":7,"url":25}],54:[function(require,module,exports){
/**
 * Accepts an array of strings that represent a reference to a value on an
 * object. Supports passing an optional setter, to set the value.
 *
 * @param  {Object} object
 * @param  {Array}  path
 * @param  {*}      [setter]
 * @return {*}
 */
module.exports = function (object, path, setter) {
  var isSetter = arguments.length > 2;

  for (var i = 0; i < path.length; i++) {
    var prop = path[i];

    if (isSetter) {
      if (i === path.length - 1) {
        object[prop] = setter;
      } else if (!(prop in object)) {
        object[prop] = {};
      }
    }

    object = object[prop];
  }

  // Return the updated object reference.
  return object;
};

},{}],55:[function(require,module,exports){
/* global App */
var _        = App.Library._;
var async    = App.Library.async;
var template = require('./client-generator/template');

/**
 * Map authentication types to automatic preference.
 *
 * @type {Array}
 */
var ORDER_PREFERENCE = ['OAuth 2.0', 'OAuth 1.0', 'Basic Authentication'];

/**
 * Required authentication keys used to check the options object.
 *
 * @type {Object}
 */
var DEFAULT_REQUIRED_FIELDS = {
  'OAuth 1.0': {
    consumerKey:    true,
    consumerSecret: true
  },
  'OAuth 2.0': {
    clientId:     true,
    clientSecret: true
  },
  'Basic Authentication': {
    username: true,
    password: true
  }
};

/**
 * Possible tokens to be filled out by the user.
 *
 * @type {Object}
 */
var DEFAULT_POSSIBLE_FIELDS = {
  'OAuth 1.0':            ['consumerKey', 'consumerSecret'],
  'OAuth 2.0':            ['clientId', 'clientSecret', 'scopes'],
  'Basic Authentication': ['username', 'password']
};

/**
 * Default authentication prompt titles.
 *
 * @type {Object}
 */
var DEFAULT_PROMPT_TITLES = {
  'OAuth 1.0':            'Please Enter Your OAuth 1.0 Keys',
  'OAuth 2.0':            'Please Enter Your OAuth 2.0 Keys',
  'Basic Authentication': 'Please Enter Your Username and Password'
};

/**
 * Map of object keys to their readable names.
 *
 * @type {Object}
 */
var DEFAULT_FIELD_NAMES = {
  consumerKey:    'Consumer Key',
  consumerSecret: 'Consumer Secret',
  clientId:       'Client ID',
  clientSecret:   'Client Secret',
  scopes:         'Permissions',
  username:       'Username',
  password:       'Password'
};

/**
 * These fields must be hidden in the UI.
 *
 * @type {Object}
 */
var SECRET_FIELDS = {
  clientSecret: true,
  consumerSecret: true,
  password: true
};

/**
 * Returns an object of available keys and whether they are required.
 *
 * @param  {Object} scheme
 * @return {Object}
 */
var requiredTokens = function (scheme) {
  var keys = _.extend({}, DEFAULT_REQUIRED_FIELDS[scheme.type]);

  // Special case is required for OAuth2 implicit auth flow.
  if (scheme.type === 'OAuth 2.0') {
    keys.clientSecret = !_.contains(
      scheme.settings.authorizationGrants, 'token'
    );
  }

  return keys;
};

/**
 * Sanitize scopes to be an array.
 *
 * @param  {*}     scopes
 * @return {Array}
 */
var sanitizeScope = function (scopes) {
  if (_.isString(scopes)) {
    return scopes.split(' ');
  }

  if (!Array.isArray(scopes)) {
    return [];
  }

  return scopes;
};

/**
 * Check the tokens object against the required tokens.
 *
 * @param  {Object}  scheme
 * @param  {Object}  tokens
 * @return {Boolean}
 */
var hasRequiredTokens = function (scheme, tokens) {
  // Iterate over the required tokens and check that the token is defined.
  return _.every(requiredTokens(scheme), function (value, key) {
    return value ? tokens[key] : true;
  });
};

/**
 * Prompt the user for authentication tokens based on a scheme. We can pass in
 * the current options object to help decide what data to display to the user.
 *
 * @param {Object}   scheme
 * @param {Object}   options
 * @param {Function} done
 */
var promptTokens = function (scheme, options, done) {
  var cancelled   = true;
  var needsTokens = requiredTokens(scheme);

  // Generate an array of the tokens to use with our prompt and filter
  // explicitly not required tokens.
  var possibleTokens = _.filter(
    DEFAULT_POSSIBLE_FIELDS[scheme.type],
    function (token) {
      return needsTokens[token] !== false;
    }
  );

  // Multiple ways of setting the scope option.
  options.scopes = sanitizeScope(options.scope || options.scopes);
  delete options.scope;

  // Generate the form to prompt the user with.
  var promptForm = _.map(possibleTokens, function (key) {
    if (key === 'scopes') {
      var scopes = sanitizeScope(scheme.settings.scopes);

      // Ignore the scopes selection when nothing is available for selection.
      if (!scopes.length) {
        return '';
      }

      // Map scopes to checkbox selections.
      var scopeOptions = _.map(scopes, function (scope) {
        // Check if the scope is already in the selected scopes. If there is
        // only one possible scope, just select it by default anyway.
        var hasScope = _.contains(options.scopes, scope) || scopes.length === 1;

        return [
          '<div class="checkbox">',
          '<label>',
          '<input type="checkbox" id="scopes" value="' + scope + '" ' +
            (hasScope ? 'checked' : '') + '>',
          scope,
          '</label>',
          '</div>'
        ].join('');
      }).join('\n');

      return [
        '<div class="form-group">',
        '<label class="form-label">' + DEFAULT_FIELD_NAMES[key] + '</label>',
        '<div class="form-content">' + scopeOptions + '</div>',
        '</div>'
      ].join('\n');
    }

    // By default we show the user an input field to input their keys.
    return [
      '<div class="form-group">',
      '<label for="' + key + '" class="form-label">',
      DEFAULT_FIELD_NAMES[key],
      '</label>',
      '<div class="form-content">',
      '<input id="' + key + '" value="' + (options[key] || '') + '"' +
        (SECRET_FIELDS[key] ? ' type="password"' : '') + '>',
      '</div>',
      '</div>'
    ].join('');
  }).join('\n');

  return App.middleware.trigger('ui:modal', {
    title: DEFAULT_PROMPT_TITLES[scheme.type],
    content: [
      '<p>',
      'This API requires authentication. Please enter your application keys.',
      '</p>',
      '<p><em>We do not store your keys.</em></p>',
      '<form>',
      promptForm,
      '<div class="form-footer">',
      '<button type="submit" class="btn btn-primary">Submit</button>',
      '</div>',
      '</form>'
    ].join('\n'),
    show: function (modal) {
      modal.el.querySelector('form')
        .addEventListener('submit', function (e) {
          e.preventDefault();

          _.each(this.querySelectorAll('input'), function (el) {
            var name = el.getAttribute('id');

            if (name === 'scopes') {
              var indexOf = _.indexOf(options.scopes, el.value);

              if (el.checked) {
                if (indexOf < 0) {
                  options.scopes.push(el.value);
                }
              } else {
                if (indexOf > -1) {
                  options.scopes.splice(indexOf, 1);
                }
              }
            } else {
              options[name] = el.value.trim();
            }
          });

          cancelled = false;
          modal.close();
        });
    }
  }, function (err) {
    return done(err || (cancelled ? new Error('Modal closed') : null), options);
  });
};

/**
 * Authenticate using an authentication scheme and passed in options.
 *
 * @param  {Object}   scheme
 * @param  {Object}   options
 * @param  {Function} done
 */
var authenticate = function (scheme, options, done) {
  var opts = _.defaults({
    type: scheme.type
  }, options, scheme.settings);

  // Interpolate all uri parameters.
  _.each([
    'accessTokenUri',
    'authorizationUri',
    'requestTokenUri',
    'authorizationUri',
    'tokenCredentialsUri'
  ], function (param) {
    opts[param] = template(opts[param], opts.baseUriParameters);
  });

  // Trigger the authentication flow.
  App.middleware.trigger('authenticate', opts, function (err, tokens) {
    if (err) {
      return done(err);
    }

    if (!tokens) {
      return done(new Error('Authentication failed'));
    }

    return done(null, scheme, options, tokens);
  }, true);
};

/**
 * Request authentication credentials from a third-party source.
 *
 * @param {Object}   scheme
 * @param {Object}   options
 * @param {Function} done
 */
var requestTokens = function (scheme, options, done) {
  var cb = function (err, tokens) {
    return done(err, _.extend({}, tokens, options));
  };

  return App.middleware.trigger('ramlClient:token', scheme, cb, true);
};

/**
 * Return the preferred scheme option from an object of every scheme.
 *
 * @param  {Object} schemes
 * @return {Object}
 */
var preferredScheme = function (schemes) {
  // Fix `undefined` schemes issues.
  if (!schemes || !Object.keys(schemes).length) {
    return;
  }

  var method = _.intersection(ORDER_PREFERENCE, _.pluck(schemes, 'type'))[0];

  // Return an essentially random but consistent scheme.
  if (!method) {
    return schemes[_.keys(schemes)[0]];
  }

  // Find the scheme that matched our preferred method.
  return _.find(schemes, function (scheme) {
    return scheme.type === method;
  });
};

/**
 * Retrieve authentication tokens and method any way possible. It will attempt
 * to resolve automatically. If that is not possible, it will defer to
 * prompting the user.
 *
 * @param {Object}   schemes
 * @param {Object}   options
 * @param {Function} done
 */
var retrieveTokens = function (schemes, options, done) {
  var tokens;

  // Attempt to get the first resolving set of access tokens.
  async.detectSeries(_.map(schemes, function (secured, method) {
    return schemes[method];
  }), function (scheme, cb) {
    return requestTokens(scheme, options, function (err, data) {
      if (err || !data || !hasRequiredTokens(scheme, data)) {
        return cb(false);
      }

      return cb(tokens = data);
    });
  }, function (scheme) {
    if (!scheme) {
      scheme = preferredScheme(schemes);

      if (!scheme) {
        return done(new Error('No schemes available'));
      }

      return promptTokens(scheme, options, function (err, tokens) {
        return done(err, scheme, tokens);
      });
    }

    return done(null, scheme, tokens);
  });
};

/**
 * Attempt to magically resolve to the first working authentication method. If
 * we fail, we need to fall back to manual authentication options with the
 * optimal authentication scheme available.
 *
 * @param {Object}   schemes
 * @param {Object}   options
 * @param {Function} done
 */
var resolveScheme = function (schemes, options, done) {
  return retrieveTokens(schemes, options, function (err, scheme, tokens) {
    if (err) { return done(err); }

    return authenticate(scheme, tokens, done);
  });
};

/**
 * Export a function that will contain all the logic for automagically
 * selecting an appropriate authentication method and prompting the user
 * for the following steps.
 *
 * @param {Object}   schemes
 * @param {String}   method
 * @param {Object}   options
 * @param {Function} done
 */
exports = module.exports = function (schemes, method, options, done) {
  var auth = _.extend({}, options);

  // If no authentication method has been passed in, attempt to pick our own.
  if (!method) {
    return resolveScheme(schemes, auth, done);
  }

  // Ensure we are attempting to authenticate with a valid method.
  if (!Object.prototype.hasOwnProperty.call(schemes, method)) {
    return done(new Error(
      'The only available authentication methods are: ' +
      _.keys(schemes).map(JSON.stringify).join(', ')
    ));
  }

  var scheme = schemes[method];

  // If we don't have all the required tokens available, prompt the user to
  // input tokens and continue authenticating.
  if (!hasRequiredTokens(scheme, auth)) {
    return requestTokens(scheme, auth, function (err, data) {
      if (err) { return done(err); }

      // Don't prompt for the tokens if we managed to retrieve them anyway.
      if (hasRequiredTokens(scheme, _.defaults(auth, data))) {
        return authenticate(scheme, auth, done);
      }

      return promptTokens(scheme, auth, function (err, tokens) {
        if (err) { return done(err); }

        return authenticate(scheme, tokens, done);
      });
    });
  }

  // Finally we have everything we need and can initiate authentication.
  return authenticate(scheme, auth, done);
};

/**
 * Expose secret field names.
 */
exports.SECRET_FIELDS = SECRET_FIELDS;

},{"./client-generator/template":58}],56:[function(require,module,exports){
/* global App */
var _           = App.Library._;
var qs          = App.Library.qs;
var template    = require('./template');
var sanitizeAST = require('./sanitize-ast');

var CONFIG_PROPERTY = '!config';
var CLIENT_PROPERTY = '!client';

var JSON_REGEXP = /^application\/([\w!#\$%&\*`\-\.\^~]*\+)?json$/i;

var HTTP_METHODS         = ['get', 'head', 'put', 'post', 'patch', 'delete'];
var RETURN_PROPERTY      = '!return';
var DESCRIPTION_PROPERTY = '!description';
var CONFIG_OPTIONS       = [
  'body',
  'proxy',
  'uriParameters',
  'baseUri',
  'baseUriParameters',
  'headers',
  'query',
  'beforeSend'
];
var OVERRIDABLE_CONFIG_OPTIONS = _.object(
  ['body', 'proxy', 'baseUri', 'beforeSend'], true
);

/**
 * Static description of the media type extension function.
 *
 * @type {Object}
 */
var EXTENSION_DESCRIPTION = {
  '!type': 'fn(extension)',
  '!args': [{
    '!type': 'string',
    '!doc':  'Set the file extension with relevant `Accept` header.'
  }],
  '!doc': [
    'Set the path extension and corresponding accept header.'
  ].join(' ')
};

/**
 * Static description of the client object.
 *
 * @type {Object}
 */
var CLIENT_DESCRIPTION = {
  '!type': 'fn(url, data?)',
  '!args': [{
    '!type': 'string',
    '!doc':  'Provide a url relative to the base uri.'
  }, {
    '!type': 'object',
    '!doc':  'Provide a data object to replace template tags in the `url`.'
  }],
  '!doc': [
    'Make an API request to a custom URL.'
  ].join(' ')
};

/**
 * Map the supported auth types to the known triggers.
 *
 * @type {Object}
 */
var authMap = {
  'OAuth 1.0':            'oauth1',
  'OAuth 2.0':            'oauth2',
  'Basic Authentication': 'basicAuth'
};

/**
 * Transform a data object into a form data instance.
 *
 * @param  {Object}   data
 * @return {FormData}
 */
var toFormData = function (data) {
  var form = new FormData();

  // Iterate over every piece of data and append to the form data object.
  _.each(data, function (value, key) {
    form.append(key, value);
  });

  return form;
};

/**
 * Map mime types to their parsers.
 *
 * @type {Object}
 */
var parse = [
  [JSON_REGEXP, JSON.parse],
  ['application/x-www-form-urlencoded', qs.parse]
];

/**
 * Map mime types to their serializers.
 *
 * @type {Object}
 */
var serialize = [
  [JSON_REGEXP, JSON.stringify],
  ['application/x-www-form-urlencoded', qs.stringify],
  ['multipart/form-data', toFormData]
];

/**
 * Iterate over an array of match and result values, and return the
 * first matching value.
 *
 * @param  {Array}    array
 * @param  {String}   test
 * @return {Function}
 */
var getMatch = function (array, test) {
  var match = _.find(array, function (value) {
    var check = value[0];

    if (_.isRegExp(check)) {
      return check.test(test);
    }

    return check === test;
  });

  return match && match[1];
};

/**
 * Sort mimes by preference.
 *
 * @param  {String} mime
 * @return {Number}
 */
var mimePreference = function (mime) {
  return getMatch([
    [JSON_REGEXP, 3],
    ['application/x-www-form-urlencoded', 2],
    ['multipart/form-data', 1]
  ], mime) || 0;
};

/**
 * Turn a string into inline code.
 *
 * @param  {String} str
 * @return {String}
 */
var codifyMarkdown = function (str) {
  return '`' + str + '`';
};

/**
 * Convert a raml body object to a markdown documentation string.
 *
 * @param  {Object} body
 * @return {String}
 */
var ramlBodyToMarkdown = function (body) {
  var mimes         = _.keys(body).sort(mimePreference);
  var documentation = [];

  // If multiple mime types are supported, add a default mime type usage note.
  if (mimes.length > 1) {
    documentation.push(
      'The body for this resource supports multiple content types. By ' +
      'default, ' + codifyMarkdown(mimes[0]) + ' will be used. However, you ' +
      'can easily specify another `Content-Type` to be used.'
    );
  }

  // Iterate over each mime type and append documentation.
  _.each(mimes, function (mime) {
    var contentType = body[mime];

    // Avoid building documentation if it's not an object.
    if (!_.isObject(contentType)) {
      return;
    }

    // If there are multiple available mime types, we need to prefix each
    // definition with some text about the current mime type.
    if (mimes.length > 1) {
      documentation.push(
        'When the content type is ' + codifyMarkdown(mime) + ':'
      );
    }

    // Append the available form parameters to the markdown content.
    if (contentType.formParameters) {
      // Iterate over each form parameter and generate basic documentation.
      _.each(contentType.formParameters, function (param, key) {
        documentation.push(
          '* **' + key + (param.required ? '' : '?') + ':** ' +
          '*' + param.type + '* ' + param.description
        );
      });
    }

    // Push the example onto the description for reference.
    if (contentType.example) {
      documentation.push(
        '**Example:**',
        '```\n' + contentType.example + '\n```'
      );
    }

    // Push the schema onto the description for reference.
    if (contentType.schema) {
      documentation.push(
        '**Schema:**',
        '```\n' + contentType.schema + '\n```'
      );
    }
  });

  return documentation.join('\n\n');
};

/**
 * Check if a method is a query method (not a body as the argument).
 *
 * @param  {String}  method
 * @return {Boolean}
 */
var isQueryMethod = function (method) {
  return method === 'get' || method === 'head';
};

/**
 * Map of methods to their tooltip description objects.
 *
 * @type {Object}
 */
var METHOD_DESCRIPTION = _.object(_.map(HTTP_METHODS, function (method) {
  var body = isQueryMethod(method) ? 'query?' : 'body?';

  return [method, {
    '!type': 'fn(' + body + ', options?, async?)'
  }];
}));

/**
 * Convert a raml object into a documentation object.
 *
 * @param  {Object} object
 * @return {Object}
 */
var ramlToDocumentationFormat = function (object) {
  var documentation = {};

  // Iterate over each key and wipe out wipe a clean documentation object.
  _.each(object, function (object, key) {
    documentation[key] = {
      '!doc':      object.description,
      '!type':     object.type,
      '!required': object.required
    };
  });

  return documentation;
};

/**
 * Transform a RAML method object into a tooltip documentation object.
 *
 * @param  {Array}  nodes
 * @param  {Object} method
 * @return {Object}
 */
var toMethodDescription = function (nodes, method) {
  var isQuery       = isQueryMethod(method.method);
  var configOptions = { '!type': 'object' };
  var bodyOptions   = { '!type': 'object' };

  var callbackOptions = {
    '!doc':  'Pass a function to make the request execute asynchonously.',
    '!type': 'fn(error, response)'
  };

  // Add documentation on the proxy.
  configOptions.proxy = {
    '!type': 'string|boolean',
    '!doc':  'Disable or set a custom proxy url for the current request.'
  };

  // Document the `beforeSend` ability.
  configOptions.beforeSend = {
    '!type': 'fn(xhr)',
    '!doc':  'Modify the `XMLHttpRequest` before it gets sent.'
  };

  // Add documentation on header parameters.
  configOptions.headers = _.extend({
    '!type': 'object'
  }, ramlToDocumentationFormat(method.headers));

  // If the method is a query method (GET/HEAD), set the body as a config option
  // and vise versa.
  if (isQuery) {
    _.extend(bodyOptions, ramlToDocumentationFormat(method.queryParameters));

    configOptions.body = {
      '!type': 'object',
      '!doc':  ramlBodyToMarkdown(method.body)
    };
  } else {
    bodyOptions = {
      '!type': 'object|string',
      '!doc':  ramlBodyToMarkdown(method.body),
    };

    configOptions.query = _.extend({
      '!type': 'object'
    }, ramlToDocumentationFormat(method.queryParameters));
  }

  // If the current node has baseUriParameters, show it in the documentation.
  if (nodes.client.baseUriParameters) {
    configOptions.baseUriParameters = _.extend({
      '!type': 'object'
    }, ramlToDocumentationFormat(nodes.client.baseUriParameters));
  }

  return _.extend({
    '!doc':  method.description,
    '!args': [bodyOptions, configOptions, callbackOptions]
  }, METHOD_DESCRIPTION[method.method]);
};

/**
 * List of all plain HTTP methods in the format from the AST.
 *
 * @type {Object}
 */
var allHttpMethods = _.chain(HTTP_METHODS).map(function (method) {
    return [method, {
      method: method
    }];
  }).object().value();

/**
 * Parse an XHR request for response headers and return as an object. Pass an
 * additional flag to filter any potential duplicate headers (E.g. different
 * cases).
 *
 * @param  {Object} xhr
 * @return {Object}
 */
var getAllReponseHeaders = function (xhr) {
  var responseHeaders = {};

  _.each(xhr.getAllResponseHeaders().split('\n'), function (header) {
    header = header.split(':');

    // Make sure we have both parts of the header.
    if (header.length > 1) {
      var name  = header.shift();
      var value = header.join(':').trim();

      responseHeaders[name.toLowerCase()] = value;
    }
  });

  return responseHeaders;
};

/**
 * Return the xhr response mime type.
 *
 * @param  {String} contentType
 * @return {String}
 */
var getMime = function (contentType) {
  return contentType == null ? null : String(contentType).split(';')[0];
};

/**
 * Check if an object is a host object and avoid serializing.
 *
 * @param  {Object}  obj
 * @return {Boolean}
 */
var isHost = function (obj) {
  var str = Object.prototype.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object String]':
    case '[object Number]':
    case '[object Boolean]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
};

/**
 * Sanitize a specific configuration option.
 *
 * @type {Object}
 */
var sanitizeOption = {
  query: function (query) {
    if (_.isString(query)) {
      return qs.parse(query);
    }

    return query;
  }
};

/**
 * Gets a header from the header object.
 *
 * @param  {Object}  headers
 * @param  {String}  header
 * @return {Boolean}
 */
var findHeader = function (headers, header) {
  header = header.toLowerCase();

  return _.find(headers, function (value, name) {
    return name.toLowerCase() === header;
  });
};

/**
 * Sanitize the XHR request into the desired format.
 *
 * @param  {XMLHttpRequest} xhr
 * @return {Object}
 */
var sanitizeXHR = function (xhr) {
  if (!xhr) { return xhr; }

  var mime    = getMime(xhr.getResponseHeader('Content-Type'));
  var body    = xhr.responseText.trim();
  var headers = getAllReponseHeaders(xhr);

  // Automatically parse all response bodies. Only parse when we have response
  // body content. Errors that occur parsing will be propagated to the client.
  body = body ? (getMatch(parse, mime) || _.identity)(body) : undefined;

  return {
    body:    body,
    status:  xhr.status,
    headers: headers
  };
};

/**
 * Returns a function that can be used to make ajax requests.
 *
 * @param  {String}   url
 * @return {Function}
 */
var httpRequest = function (nodes, method) {
  return function (body, config, done) {
    // Allow config to be omitted from arguments.
    if (_.isFunction(arguments[1])) {
      done   = arguments[1];
      config = null;
    }

    config = config || {};

    // Map configuration options and merge with the passed in object.
    config = _.object(CONFIG_OPTIONS, _.map(CONFIG_OPTIONS, function (option) {
      if (_.has(OVERRIDABLE_CONFIG_OPTIONS, option)) {
        return _.has(config, option) ? config[option] : nodes.config[option];
      }

      var nodeOption   = nodes.config[option];
      var configOption = config && config[option];
      var sanitize     = sanitizeOption[option] || _.identity;

      return _.extend({}, sanitize(nodeOption), sanitize(configOption));
    }));

    var async   = !!done;
    var request = 'ajax';
    var mime    = getMime(findHeader(config.headers, 'Content-Type'));
    var baseUri = template(config.baseUri, config.baseUriParameters);
    var fullUri = baseUri.replace(/\/+$/, '') + '/' + nodes.join('/');

    // If the request is async, set the relevant function callbacks.
    if (async) {
      App._executeContext.timeout(Infinity);

      if (!_.isFunction(done)) {
        done = App._executeContext.async();
      }
    } else {
      // Synchronous error and response handling.
      done = function (err, res) {
        if (err) {
          throw err;
        }

        return res;
      };
    }

    // GET and HEAD requests accept the query string as the first argument.
    if (isQueryMethod(method.method)) {
      _.extend(config.query, sanitizeOption.query(body));
      body = null;
    }

    // Set the config object body to the passed in body.
    if (body != null) {
      config.body = body;
    }

    // Append the query string if one is available.
    if (_.keys(config.query).length) {
      fullUri += '?' + qs.stringify(config.query);
    }

    // If we have no accept header set already, default to accepting
    // everything. This is required because Firefox sets the base accept
    // header to essentially be `html/xml`.
    if (!findHeader(config.headers, 'accept')) {
      config.headers.accept = '*/*';
    }

    // If we were passed in data, attempt to sanitize it to the correct type.
    if (!isHost(config.body)) {
      // Set the correct `Content-Type` header, if none exists. Kind of random
      // if more than one exists - I would suggest setting it yourself.
      if (mime == null) {
        // If we have a method body object, sort the method types by most
        // desirable and fallback to a random content type.
        if (typeof method.body === 'object') {
          mime = _.keys(method.body).sort(mimePreference).pop();
        }

        // Set the config to the updated mime type header. If none exists, use
        // `application/json` by default.
        config.headers['Content-Type'] = mime = mime || 'application/json';
      }

      // Automatically attempt to serialize the body.
      var serializer = getMatch(serialize, mime);

      if (!serializer) {
        return done(
          new TypeError('Can not serialize content type of "' + mime + '"')
        );
      }

      try {
        config.body = serializer(config.body);
      } catch (e) {
        return done(new TypeError('Could not serialize body: ' + e.message));
      }
    }

    var options = {
      url:        fullUri,
      data:       config.body,
      async:      async,
      proxy:      config.proxy,
      method:     method.method,
      headers:    config.headers,
      beforeSend: config.beforeSend
    };

    // Iterate through `securedBy` methods and accept the first one we are
    // already authenticated for.
    _.some(method.securedBy || nodes.client.securedBy, function (secured, key) {
      var scheme = nodes.client.securitySchemes[key];

      // Scheme is not documented in the RAML security schemes.
      if (!scheme) {
        return;
      }

      var authenticated = nodes.client.authentication[scheme.type];
      var authType      = authMap[scheme.type];

      if (authenticated) {
        options[authType] = authenticated;

        return (request = 'ajax:' + authType);
      }
    });

    // Awkward sync and async code mixing.
    var response, error;

    // Trigger the ajax middleware so plugins can hook onto the requests. If
    // the function is async we need to register a callback for the middleware.
    App.middleware.trigger(request, options, function (err, xhr) {
      error = err;

      if (!error) {
        try {
          response = sanitizeXHR(xhr);
        } catch (e) {
          error = new TypeError('Could not parse response: ' + e.message);
        }
      }

      return async && done(error, response);
    });

    // If the request was synchronous, return the sanitized XHR response data.
    if (!async) {
      return done(error, response);
    }
  };
};

/**
 * Attaches XHR request methods to the context object for each available method.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} methods
 * @return {Object}
 */
var attachMethods = function (nodes, context, methods) {
  // Attach the available methods to the current context.
  _.each(methods, function (method, verb) {
    context[verb] = httpRequest(nodes, method);
    context[verb][DESCRIPTION_PROPERTY] = toMethodDescription(nodes, method);
  });

  return context;
};

/**
 * Attach a special media extension handler.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} resource
 * @return {Object}
 */
var attachMediaTypeExtension = function (nodes, context, resource) {
  /**
   * Push the extension onto the current route and set relevant headers.
   *
   * @param  {String} extension
   * @return {Object}
   */
  context.extension = function (extension) {
    extension = extension == null ? '' : String(extension);

    // Prepend a period to the extension before adding to the route.
    if (extension && extension.charAt(0) !== '.') {
      extension = '.' + extension;
    }

    var newContext = {};
    var routeNodes = _.extend([], nodes);

    // Append the extension to the current route.
    routeNodes[routeNodes.length - 1] += extension;

    attachMethods(routeNodes, newContext, resource.methods);
    attachResources(routeNodes, newContext, resource.resources);

    return newContext;
  };

  // Attach a description and return property.
  context.extension[RETURN_PROPERTY]      = context.extension('');
  context.extension[DESCRIPTION_PROPERTY] = EXTENSION_DESCRIPTION;

  // If the media type extension is not required, allow direct invocation of
  // the request method.
  if (resource.uriParameters.mediaTypeExtension.required === false) {
    attachMethods(nodes, context, resource.methods);
  }

  // Iterate over the enum options and automatically attach to the context.
  _.each(resource.uriParameters.mediaTypeExtension.enum, function (extension) {
    if (extension.charAt(0) === '.') {
      extension = extension.substr(1);
    }

    context[extension] = context.extension(extension);
  });

  return context;
};

/**
 * Generate a context or attach methods and resources to an existing context.
 *
 * @param  {Array}   nodes
 * @param  {Object}  resource
 * @param  {Boolean} hasMediaExtension
 * @param  {Object}  context
 * @return {Object}
 */
var newContext = function (nodes, resource, hasMediaExtension, context) {
  context = context || {};

  if (hasMediaExtension) {
    attachMediaTypeExtension(nodes, context, resource);
  } else {
    attachMethods(nodes, context, resource.methods);
    attachResources(nodes, context, resource.resources);
  }

  return context;
};

/**
 * Recurses through a resource object in the RAML AST, generating a dynamic
 * DSL that only allows methods that were defined in the RAML spec.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} resources
 * @return {Object}
 */

/* jshint -W003 */
var attachResources = function (nodes, context, resources) {
  _.each(resources, function (resource, route) {
    var routeNodes        = _.extend([], nodes);
    var routeName         = route;
    var hasMediaExtension = route.substr(-20) === '{mediaTypeExtension}';

    // Ignore media type extensions in route generation.
    if (hasMediaExtension) {
      route = routeName = route.slice(0, -20);
    }

    // Check the route against our valid uri parameters.
    var templateTags = route.match(template.REGEXP);

    // Push the current route into the route array.
    routeNodes.push(route);

    // If we have template tags available, attach a dynamic route.
    if (templateTags) {
      var routeSuffix = templateTags.join('');

      // The route must end with the chained template tags and have no
      // text between tags.
      if (route.substr(-routeSuffix.length) !== routeSuffix) {
        return false;
      }

      // If the route is only a template tag with no static text, use the
      // template tag text as the method name.
      if (templateTags.length === 1 && route === templateTags[0]) {
        routeName = templateTags[0].slice(1, -1);
      } else {
        routeName = route.substr(0, route.indexOf('{'));
      }

      // Avoid adding empty route name cases. This can occur when we have
      // multiple tag names and no front text. For example, `{this}{that}`.
      // This could also occur if for some reason we are passing in a route that
      // isn't dynamic.
      if (!routeName) {
        return false;
      }

      // Get the ordered tag names for completion.
      var tags = _.map(templateTags, function (param) {
        return resource.uriParameters[param.slice(1, -1)];
      });

      // The route is dynamic, so we set the route name to be a function
      // which accepts the template arguments and updates the path fragment.
      // We'll extend any route already at the same namespace so we can do
      // things like use both `/{route}` and `/route`, if needed.
      context[routeName] = _.extend(function () {
        var args = arguments;

        // Map the tags to the arguments or default arguments.
        var parts = _.map(tags, function (tag, index) {
          // Inject enum parameters if there is only one available enum.
          // TODO: When/if we add validation back, have these routes
          // be generated instead of typed out.
          if (args[index] == null && tag.enum && tag.enum.length === 1) {
            return tag.enum[0];
          }

          // Use any passed in argument - even it's falsy.
          if (index in args) {
            return args[index];
          }

          var param = templateTags[index].slice(1, -1);

          // Fallback to injecting the fallback configuration uri parameter.
          return routeNodes.config && routeNodes.config.uriParameters[param];
        });

        // Change the last path fragment to the proper template text.
        routeNodes[routeNodes.length - 1] = template(route, parts);

        return newContext(routeNodes, resource, hasMediaExtension);
      }, context[routeName]);

      // Generate the description object for helping tooltip display.
      context[routeName][DESCRIPTION_PROPERTY] = {
        '!type': 'fn(' + _.map(tags, function (param) {
          return param.displayName + (param.required ? '' : '?');
        }).join(', ') + ')',
        '!args': _.map(tags, function (param) {
          return {
            '!type': param.type,
            '!doc':  param.description
          };
        }),
        '!doc': 'Dynamically inject variables into the request path.'
      };

      // Generate the return property for helping autocompletion.
      context[routeName][RETURN_PROPERTY] = newContext(
        routeNodes, resource, hasMediaExtension
      );

      return context[routeName];
    }

    // Handle root `/` resources.
    if (!routeName) {
      context = newContext(routeNodes, resource, hasMediaExtension, context);
    } else {
      context[routeName] = newContext(
        routeNodes, resource, hasMediaExtension, context[routeName]
      );
    }
  });

  return context;
};
/* jshint +W003 */

/**
 * Generate the client object from a sanitized AST object.
 *
 * @param  {Object} ast Passed through `sanitizeAST`
 * @return {Object}
 */
var generateClient = function (ast, config) {
  // Generate the base uri parameters and defaults.
  var baseUriParameters = _.extend(
    {}, _.pick(ast, 'version'), config.baseUriParameters
  );

  // Generate the root node array. Set properties directly on this array to be
  // copied to the next execution part. We have a global configuration object
  // which can be altered externally at any point, as well as when we finally
  // make a request. For this reason, it's important that we use objects which
  // are passed by reference.
  var nodes = _.extend([], {
    config: _.extend({
      baseUri: ast.baseUri
    }, config, {
      baseUriParameters: baseUriParameters
    }),
    client: {
      securedBy:         ast.securedBy,
      authentication:    {},
      securitySchemes:   ast.securitySchemes,
      baseUriParameters: ast.baseUriParameters
    }
  });

  // Throw an error if the baseUri string is missing.
  if (!_.isString(nodes.config.baseUri)) {
    throw new Error('A "baseUri" string is required');
  }

  /**
   * The root client implementation is simply a function. This allows us to
   * enter a custom path that may not be supported by the DSL and run any
   * method regardless of whether it was defined in the spec.
   *
   * @param  {String} path
   * @param  {Object} context
   * @return {Object}
   */
  var client = function (path, context) {
    var route = template(
      path || '', context || {}
    ).replace(/^\/+/, '').split('/');

    return attachMethods(_.extend([], nodes, route), {}, allHttpMethods);
  };

  client[CONFIG_PROPERTY]      = nodes.config;
  client[CLIENT_PROPERTY]      = nodes.client;
  client[DESCRIPTION_PROPERTY] = CLIENT_DESCRIPTION;
  client[RETURN_PROPERTY]      = attachMethods(nodes, {}, allHttpMethods);

  attachResources(nodes, client, ast.resources);

  return client;
};

/**
 * Exports the client generator, which accepts the AST of a RAML document.
 *
 * @return {Object} Dynamic object for constructing API requests from the AST.
 */
module.exports = function (ast, config) {
  return generateClient(sanitizeAST(ast), config);
};

},{"./sanitize-ast":57,"./template":58}],57:[function(require,module,exports){
/* global App */
var _ = App.Library._;

/**
 * Sanitize the secured by into an object.
 *
 * @param  {Array}  secured
 * @return {Object}
 */
var sanitizeSecuredBy = function (secured) {
  if (!Array.isArray(secured)) {
    return null;
  }

  var securedBy = {};

  // Since `securedBy` can either be an array of strings or array of objects
  // with only a single key, we merge it down to an object.
  _.each(secured, function (value) {
    if (value == null) {
      return; // Ignore `null` array values, shouldn't be useful to me.
    }

    if (_.isString(value)) {
      return securedBy[value] = true;
    }

    return _.extend(securedBy, value);
  });

  return securedBy;
};

/**
 * Sanitize the AST from the RAML parser into something easier to work with.
 *
 * @param  {Object} ast
 * @return {Object}
 */
module.exports = function (ast) {
  // Create the base sanitized ast with only the properties we want.
  var sanitizedAst = _.pick(ast, [
    'title',
    'version',
    'baseUri',
    'baseUriParameters'
  ]);

  // Merge an array of objects into a single object using `_.extend` and
  // `apply` (since `_.extend` accepts unlimited number of arguments).
  if (ast.securitySchemes) {
    sanitizedAst.securitySchemes = _.extend.apply(_, ast.securitySchemes);
  }

  // Sanitize secured by which is a bit more complicated than extending.
  if (ast.securedBy) {
    sanitizedAst.securedBy = sanitizeSecuredBy(ast.securedBy);
  }

  // Recurse through the resources and move URIs to be the key names.
  sanitizedAst.resources = (function flattenResources (resources) {
    var map = {};

    // Resources are provided as an array, we'll move them to be an object.
    _.each(resources, function (resource) {
      var sanitizedResource = {};

      // Methods are implemented as arrays of objects too, but not recursively.
      // TODO: If the endpoint is the final route and has no methods, implement
      // backtracking and remove access to it from the AST.
      if (resource.methods) {
        sanitizedResource.methods = _.object(
          _.pluck(resource.methods, 'method'),
          _.map(resource.methods, function (method) {
            // Create the sanitized method by including the properties we want.
            var sanitizedMethod = _.pick(method, [
              'method',
              'body',
              'headers',
              'description',
              'queryParameters'
            ]);

            // Sanitize the `securedBy` method.
            if (method.securedBy) {
              sanitizedMethod.securedBy = sanitizeSecuredBy(method.securedBy);
            }

            return sanitizedMethod;
          })
        );
      }

      if (resource.resources) {
        sanitizedResource.resources = flattenResources(resource.resources);
      }

      (function attachResource (map, segments) {
        var segment = segments.shift();
        var part    = map[segment] = map[segment] || {};

        // Currently on the last url segment, embed the full resource.
        if (!segments.length) {
          part = map[segment] = sanitizedResource;
        }

        // Pull any possible tags out of the relative uri part.
        var tags = _.map(segment.match(/\{([^\}]+)\}/g), function (tag) {
          return tag.slice(1, -1);
        });

        // Add only the used tags to the current resource segment.
        if (tags.length) {
          part.uriParameters = _.pick(resource.uriParameters, tags);
        }

        // If we have more segment parts left, recursively embed resources.
        if (segments.length) {
          part.resources = part.resources || {};

          return attachResource(part.resources, segments);
        }
      })(map, resource.relativeUri.substr(1).split('/'));
    });

    return map;
  })(ast.resources);

  return sanitizedAst;
};

},{}],58:[function(require,module,exports){
/* global App */
var _ = App.Library._;

/**
 * Match raml uri parameters in a uri.
 *
 * @type {RegExp}
 */
var URI_PARAM_REGEXP = /{[^}]+}/g;

/**
 * Simple "template" function for working with the uri param variables.
 *
 * @param  {String}         template
 * @param  {(Object|Array)} context
 * @return {String}
 */
exports = module.exports = function (string, context) {
  context = context || {};

  // No uri string has been specified.
  if (string == null) {
    return null;
  }

  // If the context is an array, we need to transform the replacements into
  // index based positions for the uri template parser.
  if (_.isArray(context)) {
    var index = 0;

    return string.replace(URI_PARAM_REGEXP, function () {
      return encodeURIComponent(context[index++] || '');
    });
  }

  return string.replace(URI_PARAM_REGEXP, function (match) {
    return encodeURIComponent(context[match.slice(1, -1)] || '');
  });
};

/**
 * Export the replacement regexp.
 */
exports.REGEXP = URI_PARAM_REGEXP;

},{}],59:[function(require,module,exports){
/* global App */
var _               = App._;
var ramlParser      = require('raml-parser');
var authenticate    = require('./authenticate');
var clientGenerator = require('./client-generator');
var fromPath        = require('../../lib/from-path');

/**
 * Implementation helpers.
 */
require('./inject-api-keys');
require('./insert-api-client');

/**
 * Provided a special documentation property for functionsw with another plugin.
 *
 * @type {String}
 */
var DESCRIPTION_PROPERTY = '!description';

/**
 * Custom file reader for RAML specs.
 *
 * @param  {String}  url
 * @return {Q.defer}
 */
var createReader = function (config) {
  return new ramlParser.FileReader(function (url) {
    var deferred = this.q.defer();

    App.middleware.trigger('ajax', {
      url: url,
      proxy: config.proxy,
      headers: {
        'Accept': 'application/raml+yaml, */*'
      }
    }, function (err, xhr) {
      if (err) {
        return deferred.reject(err);
      }

      if (Math.floor(xhr.status / 100) !== 2) {
        return deferred.reject(
          new Error('Received status code ' + xhr.status + ' loading ' + url)
        );
      }

      return deferred.resolve(xhr.responseText);
    });

    return deferred.promise;
  });
};

/**
 * The Api object is used in the execution context.
 *
 * @type {Object}
 */
var API = {};

/**
 * Responsible for loading RAML documents and return API clients.
 *
 * @param {String}   name
 * @param {String}   uri
 * @param {Object}   [config]
 * @param {Function} done
 */
API.createClient = function (name, uri, config, done) {
  if (!_.isString(name)) {
    throw new Error('Provide a name for the generated client');
  }

  if (!_.isString(uri)) {
    throw new Error('Provide a URL for the ' + name + ' RAML document');
  }

  // Allow the config object to be skipped.
  if (typeof config === 'function') {
    done   = arguments[2];
    config = {};
  }

  App._executeContext.timeout(Infinity);
  done   = done   || App._executeContext.async();
  config = config || {};

  /**
   * Generate and attach the RAML client from the AST.
   *
   * @param  {Object} ast
   */
  var createClient = function (ast) {
    try {
      fromPath(
        App._executeWindow, name.split('.'), clientGenerator(ast, config)
      );
    } catch (e) {
      return done(e);
    }

    return done(
      null,
      'Create a new code cell and type "' + name + '." to explore this API.'
    );
  };

  /**
   * Manually initialise the first ajax request to support JSON responses.
   */
  return App.middleware.trigger('ajax', {
    url:   uri,
    proxy: config.proxy,
    headers: {
      'Accept': 'application/raml+yaml, application/json, */*'
    }
  }, function (err, xhr) {
    if (err) {
      return done(err);
    }

    if (Math.floor(xhr.status / 100) !== 2) {
      return done(new Error('HTTP ' + xhr.status));
    }

    // Support JSON responses. Originally this checked the response content
    // types, etc. but it's just as easy to attempt parsing as JSON and if it
    // fails pass it onto the raml parser.
    try {
      return createClient(JSON.parse(xhr.responseText));
    } catch (e) {}

    // Pass our url to the RAML parser for processing and transform the promise
    // back into a callback format.
    return ramlParser.load(xhr.responseText, uri, {
      reader: createReader(config)
    }).then(createClient, done);
  });

};

/**
 * Description of the create client function.
 */
API.createClient[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(alias, url, options?, cb?)',
  '!args': [{
    '!type': 'string'
  }, {
    '!type': 'string'
  }, {
    '!type': 'object',
    '!doc': [
      'Initialize the client with default config options. Valid options:',
      '* **proxy**: Set to a custom proxy or `false` to disable entirely',
      '* **body**: Set a fallback request body',
      '* **uriParameters**: Set fallback uri parameters to inject',
      '* **baseUri:** Override the base uri',
      '* **baseUriParameters**: Inject base uri parameters to override',
      '* **headers**: Set default headers to send with every request',
      '* **query**: Set a default query string to send with every request'
    ].join('\n')
  }, {
    '!type': 'fn(error, client)',
    '!doc': [
      'Pass in a custom callback to run when the client has loaded.'
    ].join('\n')
  }],
  '!doc': [
    'Generate an API client from a RAML document and alias it on the window.'
  ].join(' ')
};

/**
 * Set a configuration value on a client.
 *
 * @param {Function} client
 * @param {String}   key
 * @param {*}        value
 */
API.set = function (client, key, value) {
  // If we don't have enough arguments for a key and value, assume we have
  // a fresh configuration object.
  if (arguments.length < 3) {
    return _.extend(client['!config'], key);
  }

  return client['!config'][key] = value;
};

/**
 * Set the description of the API client configuration setter.
 */
API.set[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key, value)',
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Set a configuration option of a RAML API client.'
};

/**
 * Retrieve a value from the client config object.
 *
 * @param  {Function} client
 * @param  {String}   key
 * @return {*}
 */
API.get = function (client, key) {
  if (arguments.length < 2) {
    return client['!config'];
  }

  return client['!config'][key];
};

/**
 * Set the description of the API client configuration getter.
 */
API.get[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key)',
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Get a configuration option from a RAML API client.'
};

/**
 * Unset a key from the client configuration.
 *
 * @param  {Function} client
 * @param  {String}   key
 * @return {Boolean}
 */
API.unset = function (client, key) {
  if (arguments.length < 2) {
    _.each(client['!config'], function (value, key, obj) {
      delete obj[key];
    });

    return true;
  }

  return delete client['!config'][key];
};

/**
 * Set the description of the API client configuration unsetter.
 */
API.unset[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key)',
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Unset a configuration option from a RAML API client.'
};

/**
 * Authenticate a RAML API client passing an optional method and accompanying
 * options object.
 *
 * @param {Function} client
 * @param {String}   method
 * @param {Object}   options
 * @param {Function} done
 */
API.authenticate = function (client, method, options, done) {
  App._executeContext.timeout(10 * 60 * 1000);
  done = done || App._executeContext.async();

  var clientOption    = client['!client'];
  var securitySchemes = clientOption.securitySchemes;

  // Extend passed in options with global options (for `baseUriParameters`).
  options = _.extend({}, options, client['!config']);

  /**
   * The callback is used to handle the persistence of data to the client.
   *
   * @param  {Error}    err
   * @param  {Object}   scheme
   * @param  {Object}   options
   * @param  {Object}   tokens
   * @return {Function}
   */
  var cb = function (err, scheme, options, tokens) {
    if (err) {
      return done(err);
    }

    // Alias onto the client object for future use.
    clientOption.authentication[scheme.type] = _.extend({}, options, tokens);

    // Set private fields to asterisks of an arbitrary length.
    _.each(tokens, function (value, key) {
      if (authenticate.SECRET_FIELDS[key]) {
        tokens[key] = new Array(Math.ceil(value.length / 5) * 5).join('*');
      }
    });

    return done(null, tokens);
  };

  return authenticate(securitySchemes, method, options, cb);
};

/**
 * Set the description of the API client authenticator.
 */
API.authenticate[DESCRIPTION_PROPERTY] = {
  '!type': [
    'fn(client, method?, options?, cb?)'
  ].join(''),
  '!args': [{
    '!type': 'fn()',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string',
    '!doc': 'Select an authentication method defined in the RAML file.'
  }, {
    '!type': 'object',
    '!doc': 'Override the default selected authentication method options.'
  }, {
    '!type': 'fn(error, response)'
  }],
  '!doc': [
    'Authentication parameters are optional. For popular APIs, we provide',
    'keys. If we need your keys we will prompt you via a modal. Never enter',
    'keys directly into a notebook unless you explicitly intend to share',
    'them. If you would like to know more about authenticating',
    'with this API, see \'securityScheme.settings\' in the RAML file.'
  ].join(' ')
};

/**
 * Alter the context to include the RAML client generator.
 *
 * @param {Object}   data
 * @param {Function} next
 */
exports['sandbox:context'] = function (context, next) {
  // This is extremely janky, but is required for Safari 7.0 which seems to
  // be ignoring direct property assignments under certain conditions.
  Object.defineProperty(context, 'API', { value: API });
  return next();
};

},{"../../lib/from-path":54,"./authenticate":55,"./client-generator":56,"./inject-api-keys":60,"./insert-api-client":61,"raml-parser":37}],60:[function(require,module,exports){
/* global App */
var apiKeys = {}.ramlClient;

/**
 * Check against our OAuth tokens and inject the tokens we have available.
 *
 * @param {Object}   data
 * @param {Function} next
 */
App.middleware.register('ramlClient:token', function (scheme, next, done) {
  var authUri = scheme.settings.authorizationUri;

  if (scheme.type === 'OAuth 1.0' && apiKeys.oauth1[authUri]) {
    return done(null, apiKeys.oauth1[authUri]);
  }

  if (scheme.type === 'OAuth 2.0' && apiKeys.oauth2[authUri]) {
    return done(null, apiKeys.oauth2[authUri]);
  }

  return next();
});

},{}],61:[function(require,module,exports){
/* global App */
var _          = App.Library._;
var qs         = App.Library.qs;
var domify     = App.Library.domify;
var Backbone   = App.Library.Backbone;
var changeCase = App.Library.changeCase;

var BASE_URI = 'https://anypoint.mulesoft.com/apiplatform/repository/v2/' +
  'organizations/52560d3f-c37a-409d-9887-79e0a9a9ecff/public/portals';
var ITEMS_PER_PAGE = 10;

/**
 * Create an api client cell that can load the selected api document.
 *
 * @param  {Cell}     cell
 * @param  {String}   invoke
 * @return {Function}
 */
var createApiClientCell = function (cell, invoke) {
  return function (err, api, version) {
    if (err) { return; }

    // Convert the API name into a variable for use.
    var variable = changeCase.camelCase(api.name);

    // Create the view with api creation details.
    var view = cell.notebook[invoke + 'CodeView'](cell.el, [
      '// Read about the ' + api.name + ' at ' + version.portalUrl,
      'API.createClient(\'' + variable + '\', \'' + version.ramlUrl + '\');'
    ].join('\n')).execute();

    cell.focus();

    // Trigger a raml client insertion message.
    App.messages.trigger('ramlClient:insert');

    return view;
  };
};

/**
 * Show RAML definitions to users in a modal, and upon selection pass the
 * selected definition back to the callback.
 *
 * @param {Function} done
 */
var selectAPIDefinition = function (done) {
  // Trigger modal display messages.
  App.messages.trigger('ramlClient:modal');

  /**
   * The current search specification object, passed to the middleware layer.
   *
   * @type {Object}
   */
  var searchSpec = {
    offset: 0,
    limit:  ITEMS_PER_PAGE,
    query:  ''
  };

  return App.middleware.trigger('ui:modal', {
    title: 'Insert an API Client',
    content: function (done) {
      return done(null, '<div class="modal-instructions">' +
        'Insert an API client from a RAML specification. An API client is ' +
        'a JavaScript representation of an API that you can use to explore ' +
        'available endpoints and their parameters. ' +
        '<a href="http://raml.org/" target="_blank">' +
        'Learn more about RAML</a>.' +
        '</div>' +
        '<div class="form-group">' +
        '<input class="item-search" placeholder="Search">' +
        '</div>' +
        '<div class="items-loading" ' +
        'style="text-align: center; font-size: 3em;">' +
        '<i class="icon-arrows-cw animate-spin"></i>' +
        '</div>' +
        '<div class="items-container clearfix">' +
        '<ul class="items-list"></ul>' +
        '<button class="btn-secondary items-prev-btn" style="float: left">' +
        'Previous</button>' +
        '<button class="btn-secondary items-next-btn" style="float: right">' +
        'Next</button>' +
        '</div>' +
        '<p class="items-unavailable">No matching APIs found.</p>'
      );
    },
    show: function (modal) {
      var itemsEl            = modal.el.querySelector('.items-container');
      var itemsListEl        = itemsEl.querySelector('.items-list');
      var itemsLoadingEl     = modal.el.querySelector('.items-loading');
      var itemsNextBtnEl     = itemsEl.querySelector('.items-next-btn');
      var itemsPrevBtnEl     = itemsEl.querySelector('.items-prev-btn');
      var itemsUnavailableEl = modal.el.querySelector('.items-unavailable');
      var searchId;

      /**
       * Load all the API definitions and return the items as an array.
       *
       * @param {Function} done
       */
      var loadAPIDefinitions = function (search, done) {
        var currentSearchId = Math.random();

        // Track current search index.
        searchId = currentSearchId;

        // Reset element states and show a loading indicator.
        itemsEl.classList.add('hide');
        itemsUnavailableEl.classList.add('hide');
        itemsLoadingEl.classList.remove('hide');

        // Set both buttons to disabled for now.
        itemsNextBtnEl.setAttribute('disabled', 'disabled');
        itemsPrevBtnEl.setAttribute('disabled', 'disabled');

        return App.middleware.trigger(
          'ramlClient:search',
          search,
          function (err, data) {
            // Skip updates when the ID has changed.
            if (currentSearchId !== searchId) {
              return;
            }

            return done(err, data);
          }
        );
      };

      /**
       * Render the search results.
       *
       * @param {Error}  err
       * @param {Object} result
       * @param {Number} result.total
       * @param {Array}  result.items
       */
      var updateResults = function (err, result) {
        // Always remove the loading indicator.
        itemsLoadingEl.classList.add('hide');

        // Empty the list before we populate it again.
        itemsListEl.innerHTML = '';

        if (err) {
          return done(err);
        }

        if (!result.items) {
          return itemsUnavailableEl.classList.remove('hide');
        }

        itemsEl.classList.remove('hide');

        // If the offset is past the first page, allow going back.
        if (searchSpec.offset > 0) {
          itemsPrevBtnEl.removeAttribute('disabled');
        }

        // If the offset can still move before hitting the last result, allow.
        if (searchSpec.offset < result.total - searchSpec.limit) {
          itemsNextBtnEl.removeAttribute('disabled');
        }

        // Iterate over each version and append to the item list.
        _.each(result.items, function (item) {
          var name = _.escape(item.name);

          var el = domify([
            '<li>',
            '<div class="item-info clearfix">',
            '<div class="item-action">',
            '<button class="btn btn-primary btn-small item-add">Add</button>',
            '</div>',
            '<a href="#" class="item-link">All versions</a>',
            '<div class="item-name">' + name + '</div>',
            '</div>',
            '<div class="item-versions">',
            _.map(item.versions, function (version, index) {
              var name        = _.escape(version.name);
              var description = _.escape(version.description);
              var portalUrl   = _.escape(version.portalUrl);

              return [
                '<div class="item-version clearfix">',
                '<div class="item-action">',
                '<button class="btn btn-primary btn-small item-add" ' +
                'data-index="' + index + '">',
                'Select',
                '</button>',
                '</div>',
                '<a href="' + portalUrl + '" class="item-link ' +
                'item-read-more" target="_blank">Read more</a>',
                '<div class="item-name">',
                '<span class="hint--top" data-hint="' + description + '">',
                name,
                '</span>',
                '</div>',
                '</div>'
              ].join('\n');
            }).join('\n'),
            '</div>',
            '</li>'
          ].join('\n'));

          itemsListEl.appendChild(el);

          // When the element is clicked, render the code cell.
          Backbone.$(el)
            .on('click', function (e) {
              // Do nothing if the read more link is clicked.
              if (e.target.classList.contains('item-read-more')) {
                return;
              }

              // Prevent following of links.
              e.preventDefault();

              var method = 'add';

              // Remove the attribute if it exists.
              if (el.classList.contains('item-visible')) {
                method = 'remove';
              }

              el.classList[method]('item-visible');
            })
            .on('click', '.item-add', function (e, el) {
              modal.close();
              e.stopPropagation();

              // Resolve to the clicked API version, or "latest".
              var version = item.versions[el.getAttribute('data-index') || 0];

              return done(null, item, version);
            });
        });
      };

      Backbone.$(modal.el)
        .on('click', '.items-next-btn', function () {
          return loadAPIDefinitions(_.extend(searchSpec, {
            offset: searchSpec.offset + ITEMS_PER_PAGE
          }), updateResults);
        })
        .on('click', '.items-prev-btn', function () {
          return loadAPIDefinitions(_.extend(searchSpec, {
            offset: searchSpec.offset - ITEMS_PER_PAGE
          }), updateResults);
        })
        .on('keyup', '.item-search', _.throttle(function (e, el) {
          // Avoid updating when the value hasn't changed.
          if (searchSpec.query === el.value) {
            return;
          }

          return loadAPIDefinitions(_.extend(searchSpec, {
            offset: 0,
            query:  el.value
          }), updateResults);
        }, 700));

      return loadAPIDefinitions(searchSpec, updateResults);
    }
  });
};

/**
 * Inserts a new code cell above with a RAML API client and executes it.
 */
App.View.EditorCell.prototype.newRAMLAbove = function () {
  return selectAPIDefinition(createApiClientCell(this, 'prepend'));
};

/**
 * Inserts a new code cell below with a RAML API client and executes it.
 */
App.View.EditorCell.prototype.newRAMLBelow = function () {
  return selectAPIDefinition(createApiClientCell(this, 'append'));
};

/**
 * Insert a RAML document by using the cell border buttons.
 */
App.View.CellButtons.controls.push({
  label:   'Insert API Client',
  command: 'newRAML'
});

/**
 * Insert a RAML document by using the cell menu buttons.
 */
App.View.CodeCell.prototype.cellControls.push({
  label:   'Insert API Client',
  command: 'newRAMLBelow'
});

/**
 * Register the basic raml client search middleware.
 */
App.middleware.register('ramlClient:search', function (search, next, done) {
  var url = BASE_URI + '?' + qs.stringify({
    sort:      'name',
    ascending: true,
    limit:     search.limit,
    offset:    search.offset,
    query:     search.query
  });

  return App.middleware.trigger('ajax', {
    url: url
  }, function (err, xhr) {
    var result;
    var data = {};

    if (err) {
      return done(err);
    }

    try {
      result = JSON.parse(xhr.responseText);
    } catch (e) {
      return done(e);
    }

    data.total = result.total;

    data.items = result.apis.map(function (item) {
      return {
        name: item.name,
        versions: item.versions.map(function (version) {
          return {
            name: version.name,
            portalUrl: 'https://anypoint.mulesoft.com/apiplatform/popular/#' +
              '/portals/organizations/' + version.organizationId + '/apis/' +
              version.apiId + '/versions/' + version.id,
            ramlUrl: 'https://anypoint.mulesoft.com/apiplatform/repository/v2' +
              '/organizations/' + version.organizationId + '/public/apis/' +
              version.apiId + '/versions/' + version.id + '/files/root',
            description: version.description,
            deprecated: version.deprecated,
            tags: version.tags
          };
        })
      };
    });

    return done(null, data);
  });
});

},{}]},{},[59])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2xpYi9yZXF1ZXN0LmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvbGliL3Jlc3BvbnNlLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL0Jhc2U2NC9iYXNlNjQuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9uYXRpdmUtYnVmZmVyLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL25hdGl2ZS1idWZmZXItYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL25hdGl2ZS1idWZmZXItYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvZHVwbGV4LmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvcGFzc3Rocm91Z2guanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3JlYWRhYmxlLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS90cmFuc2Zvcm0uanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3dyaXRhYmxlLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvY29tcG9zZXIuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9jb25zdHJ1Y3QuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9lcnJvcnMuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9ldmVudHMuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9qb2luZXIuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9sb2FkZXIuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9ub2Rlcy5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3BhcnNlci5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3Byb3RvY29scy5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3JhbWwuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yZWFkZXIuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yZXNvbHZlci5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3Jlc291cmNlVHlwZXMuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9zY2FubmVyLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvc2NoZW1hcy5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3NlY3VyaXR5U2NoZW1lcy5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3Rva2Vucy5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3RyYWl0cy5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3RyYW5zZm9ybWF0aW9ucy5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3V0aWwuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi92YWxpZGF0b3IuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL25vZGVfbW9kdWxlcy9pbmZsZWN0aW9uL2xpYi9pbmZsZWN0aW9uLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9ub2RlX21vZHVsZXMvanNvbi1saW50L2pzb25saW50LmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9ub2RlX21vZHVsZXMvcS9xLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9ub2RlX21vZHVsZXMvdXJpdGVtcGxhdGUvYmluL3VyaXRlbXBsYXRlLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9ub2RlX21vZHVsZXMveG1saHR0cHJlcXVlc3QvbGliL1hNTEh0dHBSZXF1ZXN0LmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL3NyYy9zY3JpcHRzL2xpYi9mcm9tLXBhdGguanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svc3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvYXV0aGVudGljYXRlLmpzIiwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL3NyYy9zY3JpcHRzL3BsdWdpbnMvcmFtbC1jbGllbnQtZ2VuZXJhdG9yL2NsaWVudC1nZW5lcmF0b3IvaW5kZXguanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svc3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvY2xpZW50LWdlbmVyYXRvci9zYW5pdGl6ZS1hc3QuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svc3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvY2xpZW50LWdlbmVyYXRvci90ZW1wbGF0ZS5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9zcmMvc2NyaXB0cy9wbHVnaW5zL3JhbWwtY2xpZW50LWdlbmVyYXRvci9pbmRleC5qcyIsIi9Vc2Vycy9hYW5hbmQvSWRlYVByb2plY3RzL2FwaS1ub3RlYm9vay9zcmMvc2NyaXB0cy9wbHVnaW5zL3JhbWwtY2xpZW50LWdlbmVyYXRvci9pbmplY3QtYXBpLWtleXMuanMiLCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svc3JjL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvaW5zZXJ0LWFwaS1jbGllbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ptQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbi9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ241REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwidmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiAhcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJzZUludCh3aW5kb3cubG9jYXRpb24ucG9ydCwgMTApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5ob3N0ICYmIHBhcmFtcy5ob3N0bmFtZSkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0bmFtZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFwYXJhbXMuc2NoZW1lKSBwYXJhbXMuc2NoZW1lID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gICAgaWYgKCFwYXJhbXMuaG9zdCkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSB8fCB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICB9XG4gICAgaWYgKC86Ly50ZXN0KHBhcmFtcy5ob3N0KSkge1xuICAgICAgICBpZiAoIXBhcmFtcy5wb3J0KSB7XG4gICAgICAgICAgICBwYXJhbXMucG9ydCA9IHBhcmFtcy5ob3N0LnNwbGl0KCc6JylbMV07XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmhvc3QgPSBwYXJhbXMuaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5wb3J0KSBwYXJhbXMucG9ydCA9IHBhcmFtcy5zY2hlbWUgPT0gJ2h0dHBzJyA/IDQ0MyA6IDgwO1xuICAgIFxuICAgIHZhciByZXEgPSBuZXcgUmVxdWVzdChuZXcgeGhySHR0cCwgcGFyYW1zKTtcbiAgICBpZiAoY2IpIHJlcS5vbigncmVzcG9uc2UnLCBjYik7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5cbmh0dHAuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBwYXJhbXMubWV0aG9kID0gJ0dFVCc7XG4gICAgdmFyIHJlcSA9IGh0dHAucmVxdWVzdChwYXJhbXMsIGNiKTtcbiAgICByZXEuZW5kKCk7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHMgPSA0O1xuXG52YXIgeGhySHR0cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gd2luZG93IG9iamVjdCBwcmVzZW50Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICB2YXIgYXhzID0gW1xuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjYuMCcsXG4gICAgICAgICAgICAnTXN4bWwyLlhNTEhUVFAuMy4wJyxcbiAgICAgICAgICAgICdNaWNyb3NvZnQuWE1MSFRUUCdcbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4ID0gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4XyA9IGF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4XztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcod2luZG93LkFjdGl2ZVhPYmplY3QpKGF4c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhamF4IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgIH1cbn0pKCk7XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG52YXIgQmFzZTY0ID0gcmVxdWlyZSgnQmFzZTY0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IFtdO1xuICAgIFxuICAgIHNlbGYudXJpID0gKHBhcmFtcy5zY2hlbWUgfHwgJ2h0dHAnKSArICc6Ly8nXG4gICAgICAgICsgcGFyYW1zLmhvc3RcbiAgICAgICAgKyAocGFyYW1zLnBvcnQgPyAnOicgKyBwYXJhbXMucG9ydCA6ICcnKVxuICAgICAgICArIChwYXJhbXMucGF0aCB8fCAnLycpXG4gICAgO1xuICAgIFxuICAgIHRyeSB7IHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlIH1cbiAgICBjYXRjaCAoZSkge31cbiAgICBcbiAgICB4aHIub3BlbihcbiAgICAgICAgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgc2VsZi51cmksXG4gICAgICAgIHRydWVcbiAgICApO1xuICAgIFxuICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzU2FmZVJlcXVlc3RIZWFkZXIoa2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXMuaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5hdXRoKSB7XG4gICAgICAgIC8vYmFzaWMgYXV0aFxuICAgICAgICB0aGlzLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgQmFzZTY0LmJ0b2EocGFyYW1zLmF1dGgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gbmV3IFJlc3BvbnNlO1xuICAgIHJlcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcbiAgICB9KTtcbiAgICBcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXMuaGFuZGxlKHhocik7XG4gICAgfTtcbn07XG5cbmluaGVyaXRzKFJlcXVlc3QsIFN0cmVhbSk7XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS5wdXNoKHMpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAocykge1xuICAgIGlmIChzICE9PSB1bmRlZmluZWQpIHRoaXMuYm9keS5wdXNoKHMpO1xuICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQoJycpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5ib2R5WzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnhoci5zZW5kKHRoaXMuYm9keS5qb2luKCcnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodGhpcy5ib2R5WzBdKSkge1xuICAgICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keS5wdXNoLmFwcGx5KGJvZHksIHRoaXMuYm9keVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChib2R5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL0FycmF5Ly50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLmJvZHlbMF0pKSkge1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLmJvZHlbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gbmV3KHRoaXMuYm9keVswXS5jb25zdHJ1Y3RvcikobGVuKTtcbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2R5W2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYm9keVtrKytdID0gYltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGJvZHkgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5ib2R5W2ldLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChib2R5KTtcbiAgICB9XG59O1xuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS9tb3ppbGxhLWNlbnRyYWwvY29udGVudC9iYXNlL3NyYy9uc1hNTEh0dHBSZXF1ZXN0LmNwcC5odG1sXG5SZXF1ZXN0LnVuc2FmZUhlYWRlcnMgPSBbXG4gICAgXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb250ZW50LWxlbmd0aFwiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJjb29raWUyXCIsXG4gICAgXCJjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJleHBlY3RcIixcbiAgICBcImhvc3RcIixcbiAgICBcImtlZXAtYWxpdmVcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwicmVmZXJlclwiLFxuICAgIFwidGVcIixcbiAgICBcInRyYWlsZXJcIixcbiAgICBcInRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJ1cGdyYWRlXCIsXG4gICAgXCJ1c2VyLWFnZW50XCIsXG4gICAgXCJ2aWFcIlxuXTtcblxuUmVxdWVzdC5wcm90b3R5cGUuaXNTYWZlUmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJOYW1lKSB7XG4gICAgaWYgKCFoZWFkZXJOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGluZGV4T2YoUmVxdWVzdC51bnNhZmVIZWFkZXJzLCBoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAtMTtcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaW5kZXhPZiA9IGZ1bmN0aW9uICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIFJlc3BvbnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xufTtcblxudXRpbC5pbmhlcml0cyhSZXNwb25zZSwgU3RyZWFtKTtcblxudmFyIGNhcGFibGUgPSB7XG4gICAgc3RyZWFtaW5nIDogdHJ1ZSxcbiAgICBzdGF0dXMyIDogdHJ1ZVxufTtcblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzIChyZXMpIHtcbiAgICB2YXIgbGluZXMgPSByZXMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoL1xccj9cXG4vKTtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGxpbmUgPT09ICcnKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXihbXjpdKyk6XFxzKiguKikvKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBtWzFdLnRvTG93ZXJDYXNlKCksIHZhbHVlID0gbVsyXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShoZWFkZXJzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFsgaGVhZGVyc1trZXldLCB2YWx1ZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyc1tsaW5lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXRSZXNwb25zZSA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgICB2YXIgcmVzcFR5cGUgPSBTdHJpbmcoeGhyLnJlc3BvbnNlVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocmVzcFR5cGUgPT09ICdibG9iJykgcmV0dXJuIHhoci5yZXNwb25zZUJsb2IgfHwgeGhyLnJlc3BvbnNlO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykgcmV0dXJuIHhoci5yZXNwb25zZTtcbiAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKHJlcy5yZWFkeVN0YXRlID09PSAyICYmIGNhcGFibGUuc3RhdHVzMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RhdHVzMiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwYWJsZS5zdHJlYW1pbmcgJiYgcmVzLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge31cbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RyZWFtaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdERhdGEocmVzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzLmdldFJlc3BvbnNlKHJlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB9XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX2VtaXREYXRhID0gZnVuY3Rpb24gKHJlcykge1xuICAgIHZhciByZXNwQm9keSA9IHRoaXMuZ2V0UmVzcG9uc2UocmVzKTtcbiAgICBpZiAocmVzcEJvZHkudG9TdHJpbmcoKS5tYXRjaCgvQXJyYXlCdWZmZXIvKSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBuZXcgVWludDhBcnJheShyZXNwQm9keSwgdGhpcy5vZmZzZXQpKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSByZXNwQm9keS5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwQm9keS5sZW5ndGggPiB0aGlzLm9mZnNldCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXNwQm9keS5zbGljZSh0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5Lmxlbmd0aDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiOyhmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG9iamVjdCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXM7IC8vICM4OiB3ZWIgd29ya2Vyc1xuICB2YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG4gIGZ1bmN0aW9uIEludmFsaWRDaGFyYWN0ZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yO1xuICBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuICAvLyBlbmNvZGVyXG4gIC8vIFtodHRwczovL2dpc3QuZ2l0aHViLmNvbS85OTkxNjZdIGJ5IFtodHRwczovL2dpdGh1Yi5jb20vbmlnbmFnXVxuICBvYmplY3QuYnRvYSB8fCAoXG4gIG9iamVjdC5idG9hID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgZm9yIChcbiAgICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgICB2YXIgYmxvY2ssIGNoYXJDb2RlLCBpZHggPSAwLCBtYXAgPSBjaGFycywgb3V0cHV0ID0gJyc7XG4gICAgICAvLyBpZiB0aGUgbmV4dCBpbnB1dCBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgICAvLyAgIGNoZWNrIGlmIGQgaGFzIG5vIGZyYWN0aW9uYWwgZGlnaXRzXG4gICAgICBpbnB1dC5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgICAvLyBcIjggLSBpZHggJSAxICogOFwiIGdlbmVyYXRlcyB0aGUgc2VxdWVuY2UgMiwgNCwgNiwgOFxuICAgICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICAgKSB7XG4gICAgICBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaWR4ICs9IDMvNCk7XG4gICAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IoXCInYnRvYScgZmFpbGVkOiBUaGUgc3RyaW5nIHRvIGJlIGVuY29kZWQgY29udGFpbnMgY2hhcmFjdGVycyBvdXRzaWRlIG9mIHRoZSBMYXRpbjEgcmFuZ2UuXCIpO1xuICAgICAgfVxuICAgICAgYmxvY2sgPSBibG9jayA8PCA4IHwgY2hhckNvZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pO1xuXG4gIC8vIGRlY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMjAzOTZdIGJ5IFtodHRwczovL2dpdGh1Yi5jb20vYXRrXVxuICBvYmplY3QuYXRvYiB8fCAoXG4gIG9iamVjdC5hdG9iID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC89KyQvLCAnJyk7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCAlIDQgPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIidhdG9iJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuXCIpO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJzXG4gICAgICB2YXIgYmMgPSAwLCBicywgYnVmZmVyLCBpZHggPSAwLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGdldCBuZXh0IGNoYXJhY3RlclxuICAgICAgYnVmZmVyID0gaW5wdXQuY2hhckF0KGlkeCsrKTtcbiAgICAgIC8vIGNoYXJhY3RlciBmb3VuZCBpbiB0YWJsZT8gaW5pdGlhbGl6ZSBiaXQgc3RvcmFnZSBhbmQgYWRkIGl0cyBhc2NpaSB2YWx1ZTtcbiAgICAgIH5idWZmZXIgJiYgKGJzID0gYmMgJSA0ID8gYnMgKiA2NCArIGJ1ZmZlciA6IGJ1ZmZlcixcbiAgICAgICAgLy8gYW5kIGlmIG5vdCBmaXJzdCBvZiBlYWNoIDQgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gY29udmVydCB0aGUgZmlyc3QgOCBiaXRzIHRvIG9uZSBhc2NpaSBjaGFyYWN0ZXJcbiAgICAgICAgYmMrKyAlIDQpID8gb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgYnMgPj4gKC0yICogYmMgJiA2KSkgOiAwXG4gICAgKSB7XG4gICAgICAvLyB0cnkgdG8gZmluZCBjaGFyYWN0ZXIgaW4gdGFibGUgKDAtNjMsIG5vdCBmb3VuZCA9PiAtMSlcbiAgICAgIGJ1ZmZlciA9IGNoYXJzLmluZGV4T2YoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbn0oKSk7XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gICAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XTtcbn07XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMuc2NoZW1lID0gJ2h0dHBzJztcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYik7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsInZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLFxuICAgLy8gRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXM/IElmXG4gIC8vIG5vdCwgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnQuIFdlIG5lZWQgdG8gYmUgYWJsZSB0b1xuICAvLyBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy5cbiAgLy8gUmVsZXZhbnQgRmlyZWZveCBidWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgwKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IGF1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBzdWJqZWN0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIFVpbnQ4QXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICd1Y3MyJzogLy8gVE9ETzogTm8gc3VwcG9ydCBmb3IgdWNzMiBvciB1dGYxNmxlIGVuY29kaW5ncyB5ZXRcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndWNzMic6IC8vIFRPRE86IE5vIHN1cHBvcnQgZm9yIHVjczIgb3IgdXRmMTZsZSBlbmNvZGluZ3MgeWV0XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICAvLyBjb3B5IVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyBpKyspXG4gICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8vIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmX3NsaWNlX3N0YXJ0X2VuZFxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCB0aGUgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBhdWdtZW50IChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsXG4gICAgICAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwOi8vbXRocy5iZS9wdW55Y29kZSB2MS4yLjQgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXiAtfl0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvXFx4MkV8XFx1MzAwMnxcXHVGRjBFfFxcdUZGNjEvZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRhcnJheVtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3MuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0cmV0dXJuIG1hcChzdHJpbmcuc3BsaXQocmVnZXhTZXBhcmF0b3JzKSwgZm4pLmpvaW4oJy4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyB0byBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5XG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBVbmljb2RlLiBPbmx5IHRoZVxuXHQgKiBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG9cblx0ICogVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIFB1bnljb2RlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gUHVueWNvZGUuIE9ubHkgdGhlXG5cdCAqIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpbiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQsIGFzIGEgVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4yLjQnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUuanMnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUuanMnKTtcblxuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbkR1cGxleC5wcm90b3R5cGUud3JpdGUgPSBXcml0YWJsZS5wcm90b3R5cGUud3JpdGU7XG5EdXBsZXgucHJvdG90eXBlLmVuZCA9IFdyaXRhYmxlLnByb3RvdHlwZS5lbmQ7XG5EdXBsZXgucHJvdG90eXBlLl93cml0ZSA9IFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGU7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbmQoKTtcbiAgfSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgnLi93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IG4gPT09IG51bGwpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgIWVyKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHNldEltbWVkaWF0ZShlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgLy8gY2hlY2sgZm9yIGxpc3RlbmVycyBiZWZvcmUgZW1pdCByZW1vdmVzIG9uZS10aW1lIGxpc3RlbmVycy5cbiAgdmFyIGVyckxpc3RlbmVycyA9IEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJyk7XG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBpZiAoZXJyTGlzdGVuZXJzID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIGRlc3Qub25jZSgnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdC5hcHBseShzZWxmLCBldiwgeCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4LmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbnZhciBpc1VpbnQ4QXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfVxuICA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5J1xuICB9XG47XG52YXIgaXNBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIH1cbiAgOiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICYmIHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInXG4gIH1cbjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtLkR1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgaXNVaW50OEFycmF5KGNodW5rKSlcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmspO1xuICBpZiAoaXNBcnJheUJ1ZmZlcihjaHVuaykgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShjaHVuaykpO1xuICBcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgc3RhdGUubmVlZERyYWluID0gIXJldDtcblxuICBpZiAoc3RhdGUud3JpdGluZylcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIGNiKCk7XG4gIGlmIChmaW5pc2hlZClcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgYysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICBlbHNlXG4gICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2h1bmsgIT09IG51bGwpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHNldEltbWVkaWF0ZShjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgICAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIG9mZnNldCwgaSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gKGkgLSBvZmZzZXQpO1xuICAgIG9mZnNldCA9IGk7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoaSA9PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gY2hhclN0cjtcblxuICAgIC8vIG90aGVyd2lzZSBjdXQgb2ZmIHRoZSBjaGFyYWN0ZXJzIGVuZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoaSwgYnVmZmVyLmxlbmd0aCk7XG4gICAgYnJlYWs7XG4gIH1cblxuICB2YXIgbGVuSW5jb21wbGV0ZSA9IHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gbGVuSW5jb21wbGV0ZSwgZW5kKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IGxlbkluY29tcGxldGU7XG4gICAgZW5kIC09IGxlbkluY29tcGxldGU7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICB0aGlzLmNoYXJCdWZmZXIud3JpdGUoY2hhclN0ci5jaGFyQXQoY2hhclN0ci5sZW5ndGggLSAxKSwgdGhpcy5lbmNvZGluZyk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB2YXIgaW5jb21wbGV0ZSA9IHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGUgPyAyIDogMDtcbiAgcmV0dXJuIGluY29tcGxldGU7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB2YXIgaW5jb21wbGV0ZSA9IHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGUgPyAzIDogMDtcbiAgcmV0dXJuIGluY29tcGxldGU7XG59XG4iLCIvKmpzaGludCBzdHJpY3Q6dHJ1ZSBub2RlOnRydWUgZXM1OnRydWUgb25ldmFyOnRydWUgbGF4Y29tbWE6dHJ1ZSBsYXhicmVhazp0cnVlIGVxZXFlcTp0cnVlIGltbWVkOnRydWUgbGF0ZWRlZjp0cnVlKi9cbihmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnficsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KGRlbGltcyksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddXG4gICAgICAuY29uY2F0KHVud2lzZSkuY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIG5vbkF1dGhDaGFycyA9IFsnLycsICdAJywgJz8nLCAnIyddLmNvbmNhdChkZWxpbXMpLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtekEtWjAtOV1bYS16MC05QS1aXy1dezAsNjJ9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGhhdmUgYSBwYXRoIGNvbXBvbmVudC5cbiAgICBwYXRoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mKHVybCkgPT09ICdvYmplY3QnICYmIHVybC5ocmVmKSByZXR1cm4gdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgb3V0ID0ge30sXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICBvdXQucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICBvdXQuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvLyBkb24ndCBlbmZvcmNlIGZ1bGwgUkZDIGNvcnJlY3RuZXNzLCBqdXN0IGJlIHVuc3R1cGlkIGFib3V0IGl0LlxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBAIHNpZ24sIHVubGVzcyBzb21lIG5vbi1hdXRoIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIHZhciBhdFNpZ24gPSByZXN0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgdmFyIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG5cbiAgICAgIC8vIHRoZXJlICptYXkgYmUqIGFuIGF1dGhcbiAgICAgIHZhciBoYXNBdXRoID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uQXV0aENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXV0aC5pbmRleE9mKG5vbkF1dGhDaGFyc1tpXSkgIT09IC0xKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgYXV0aC4gIFNvbWV0aGluZyBsaWtlIGh0dHA6Ly9mb28uY29tL2JhckBiYXovXG4gICAgICAgICAgaGFzQXV0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNBdXRoKSB7XG4gICAgICAgIC8vIHBsdWNrIG9mZiB0aGUgYXV0aCBwb3J0aW9uLlxuICAgICAgICBvdXQuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGF0U2lnbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJzdE5vbkhvc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgIChmaXJzdE5vbkhvc3QgPCAwIHx8IGluZGV4IDwgZmlyc3ROb25Ib3N0KSkgZmlyc3ROb25Ib3N0ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Tm9uSG9zdCAhPT0gLTEpIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdC5zdWJzdHIoMCwgZmlyc3ROb25Ib3N0KTtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihmaXJzdE5vbkhvc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQuaG9zdCA9IHJlc3Q7XG4gICAgICByZXN0ID0gJyc7XG4gICAgfVxuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB2YXIgcCA9IHBhcnNlSG9zdChvdXQuaG9zdCk7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIG91dFtrZXldID0gcFtrZXldO1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSBvdXQuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICBvdXQuaG9zdG5hbWVbb3V0Lmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAob3V0Lmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICBvdXQuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSBvdXQuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Lmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IG91dC5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgb3V0Lmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICBvdXQuaG9zdCA9IChvdXQuaG9zdG5hbWUgfHwgJycpICtcbiAgICAgICAgKChvdXQucG9ydCkgPyAnOicgKyBvdXQucG9ydCA6ICcnKTtcbiAgICBvdXQuaHJlZiArPSBvdXQuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUuc3Vic3RyKDEsIG91dC5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgb3V0Lmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIG91dC5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgb3V0LnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgb3V0LnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2Uob3V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIG91dC5zZWFyY2ggPSAnJztcbiAgICBvdXQucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgb3V0LnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIG91dC5ob3N0bmFtZSAmJiAhb3V0LnBhdGhuYW1lKSB7XG4gICAgb3V0LnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAob3V0LnBhdGhuYW1lIHx8IG91dC5zZWFyY2gpIHtcbiAgICBvdXQucGF0aCA9IChvdXQucGF0aG5hbWUgPyBvdXQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgKG91dC5zZWFyY2ggPyBvdXQuc2VhcmNoIDogJycpO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIG91dC5ocmVmID0gdXJsRm9ybWF0KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSBvYmogPSB1cmxQYXJzZShvYmopO1xuXG4gIHZhciBhdXRoID0gb2JqLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IG9iai5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gb2JqLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IG9iai5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAob2JqLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGhvc3QgPSBhdXRoICsgb2JqLmhvc3Q7XG4gIH0gZWxzZSBpZiAob2JqLmhvc3RuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBob3N0ID0gYXV0aCArIChvYmouaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIG9iai5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIG9iai5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKG9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIG9iai5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvYmoucXVlcnkgJiYgdHlwZW9mIG9iai5xdWVyeSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIE9iamVjdC5rZXlzKG9iai5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkob2JqLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmIChvYmouc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsRm9ybWF0KHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkpO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcblxuICBzb3VyY2UgPSB1cmxQYXJzZSh1cmxGb3JtYXQoc291cmNlKSwgZmFsc2UsIHRydWUpO1xuICByZWxhdGl2ZSA9IHVybFBhcnNlKHVybEZvcm1hdChyZWxhdGl2ZSksIGZhbHNlLCB0cnVlKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgc291cmNlLmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICByZWxhdGl2ZS5wcm90b2NvbCA9IHNvdXJjZS5wcm90b2NvbDtcbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdICYmXG4gICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lICYmICFyZWxhdGl2ZS5wYXRobmFtZSkge1xuICAgICAgcmVsYXRpdmUucGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICByZXR1cm4gcmVsYXRpdmU7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHNvdXJjZS5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHJlbGF0aXZlLmhyZWYgPSB1cmxGb3JtYXQocmVsYXRpdmUpO1xuICAgICAgcmV0dXJuIHJlbGF0aXZlO1xuICAgIH1cbiAgICBzb3VyY2UucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZWxhdGl2ZS5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH1cbiAgICBzb3VyY2UucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNvdXJjZS5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgc291cmNlLmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICBzb3VyY2UucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlLmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHNvdXJjZS5wYXRobmFtZSAmJiBzb3VyY2UucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gc291cmNlLnByb3RvY29sICYmXG4gICAgICAgICAgIXNsYXNoZWRQcm90b2NvbFtzb3VyY2UucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHNvdXJjZS5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG5cbiAgICBkZWxldGUgc291cmNlLmhvc3RuYW1lO1xuICAgIGRlbGV0ZSBzb3VyY2UucG9ydDtcbiAgICBpZiAoc291cmNlLmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHNvdXJjZS5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQoc291cmNlLmhvc3QpO1xuICAgIH1cbiAgICBkZWxldGUgc291cmNlLmhvc3Q7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICBkZWxldGUgcmVsYXRpdmUuaG9zdG5hbWU7XG4gICAgICBkZWxldGUgcmVsYXRpdmUucG9ydDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3Q7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHNvdXJjZS5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogc291cmNlLmhvc3Q7XG4gICAgc291cmNlLmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogc291cmNlLmhvc3RuYW1lO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICgnc2VhcmNoJyBpbiByZWxhdGl2ZSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHNvdXJjZS5ob3N0bmFtZSA9IHNvdXJjZS5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHNvdXJjZS5ob3N0ICYmIHNvdXJjZS5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICBzb3VyY2UuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICBkZWxldGUgc291cmNlLnBhdGhuYW1lO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXNvdXJjZS5zZWFyY2gpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gJy8nICsgc291cmNlLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNvdXJjZS5wYXRoO1xuICAgIH1cbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChzb3VyY2UuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBzb3VyY2UuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICBzb3VyY2UuaG9zdCA9IHNvdXJjZS5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAoc291cmNlLmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHNvdXJjZS5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICB9XG4gIHNvdXJjZS5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCBzb3VyY2UuYXV0aDtcbiAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvc3QoaG9zdCkge1xuICB2YXIgb3V0ID0ge307XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICBvdXQucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIG91dC5ob3N0bmFtZSA9IGhvc3Q7XG4gIHJldHVybiBvdXQ7XG59XG5cbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBldmVudHMsIG5vZGVzLCByYW1sLCB1dGlsLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICByYW1sID0gcmVxdWlyZSgnLi9yYW1sJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIHRoaXMuQ29tcG9zZXJFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcG9zZXJFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIENvbXBvc2VyRXJyb3IoKSB7XG4gICAgICBfcmVmID0gQ29tcG9zZXJFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBDb21wb3NlckVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgdGhpcy5Db21wb3NlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBDb21wb3NlcigpIHtcbiAgICAgIHRoaXMuY29tcG9zZVJhbWxUcmVlID0gX19iaW5kKHRoaXMuY29tcG9zZVJhbWxUcmVlLCB0aGlzKTtcbiAgICAgIHRoaXMuYW5jaG9ycyA9IHt9O1xuICAgICAgdGhpcy5maWxlc1RvUmVhZCA9IFtdO1xuICAgIH1cblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jaGVja19ub2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtU3RhcnRFdmVudCkpIHtcbiAgICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhdGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtRW5kRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdldCB0aGUgcm9vdCBub2RlIG9mIHRoZSBuZXh0IGRvY3VtZW50LlxuICAgICovXG5cblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5nZXRfbm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TdHJlYW1FbmRFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zZV9kb2N1bWVudCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuZ2V0WWFtbFJvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkb2N1bWVudCwgZXZlbnQ7XG4gICAgICB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgZG9jdW1lbnQgPSBudWxsO1xuICAgICAgaWYgKCF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TdHJlYW1FbmRFdmVudCkpIHtcbiAgICAgICAgZG9jdW1lbnQgPSB0aGlzLmNvbXBvc2VfZG9jdW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jaGVja19ldmVudChldmVudHMuU3RyZWFtRW5kRXZlbnQpKSB7XG4gICAgICAgIGV2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29tcG9zZXJFcnJvcignZG9jdW1lbnQgc2NhbicsIGRvY3VtZW50LnN0YXJ0X21hcmssICdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtIGJ1dCBmb3VuZCBhbm90aGVyIGRvY3VtZW50JywgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY29tcG9zZVJhbWxUcmVlID0gZnVuY3Rpb24obm9kZSwgc2V0dGluZ3MpIHtcbiAgICAgIGlmIChzZXR0aW5ncy52YWxpZGF0ZSB8fCBzZXR0aW5ncy50cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5sb2FkX3NjaGVtYXMobm9kZSk7XG4gICAgICAgIHRoaXMubG9hZF90cmFpdHMobm9kZSk7XG4gICAgICAgIHRoaXMubG9hZF90eXBlcyhub2RlKTtcbiAgICAgICAgdGhpcy5sb2FkX3NlY3VyaXR5X3NjaGVtZXMobm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MudmFsaWRhdGUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZV9kb2N1bWVudChub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy50cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5hcHBseV90eXBlcyhub2RlKTtcbiAgICAgICAgdGhpcy5hcHBseV90cmFpdHMobm9kZSk7XG4gICAgICAgIHRoaXMuYXBwbHlfc2NoZW1hcyhub2RlKTtcbiAgICAgICAgdGhpcy5hcHBseV9wcm90b2NvbHMobm9kZSk7XG4gICAgICAgIHRoaXMuam9pbl9yZXNvdXJjZXMobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNvbXBvc2VfZG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIG5vZGUgPSB0aGlzLmNvbXBvc2Vfbm9kZSgpO1xuICAgICAgdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIHRoaXMuYW5jaG9ycyA9IHt9O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5nZXRQZW5kaW5nRmlsZXNMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlc1RvUmVhZDtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNvbXBvc2Vfbm9kZSA9IGZ1bmN0aW9uKHBhcmVudCwgaW5kZXgpIHtcbiAgICAgIHZhciBhbmNob3IsIGV2ZW50LCBub2RlO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLkFsaWFzRXZlbnQpKSB7XG4gICAgICAgIGV2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgICAgYW5jaG9yID0gZXZlbnQuYW5jaG9yO1xuICAgICAgICBpZiAoIShhbmNob3IgaW4gdGhpcy5hbmNob3JzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbXBvc2VyRXJyb3IobnVsbCwgbnVsbCwgXCJmb3VuZCB1bmRlZmluZWQgYWxpYXMgXCIgKyBhbmNob3IsIGV2ZW50LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvcnNbYW5jaG9yXS5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgZXZlbnQgPSB0aGlzLnBlZWtfZXZlbnQoKTtcbiAgICAgIGFuY2hvciA9IGV2ZW50LmFuY2hvcjtcbiAgICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgYW5jaG9yIGluIHRoaXMuYW5jaG9ycykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db21wb3NlckVycm9yKFwiZm91bmQgZHVwbGljYXRlIGFuY2hvciBcIiArIGFuY2hvciArIFwiOyBmaXJzdCBvY2N1cmVuY2VcIiwgdGhpcy5hbmNob3JzW2FuY2hvcl0uc3RhcnRfbWFyaywgJ3NlY29uZCBvY2N1cnJlbmNlJywgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlc2NlbmRfcmVzb2x2ZXIocGFyZW50LCBpbmRleCk7XG4gICAgICBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuU2NhbGFyRXZlbnQpKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNvbXBvc2Vfc2NhbGFyX25vZGUoYW5jaG9yLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuU2VxdWVuY2VTdGFydEV2ZW50KSkge1xuICAgICAgICBub2RlID0gdGhpcy5jb21wb3NlX3NlcXVlbmNlX25vZGUoYW5jaG9yKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuTWFwcGluZ1N0YXJ0RXZlbnQpKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNvbXBvc2VfbWFwcGluZ19ub2RlKGFuY2hvcik7XG4gICAgICB9XG4gICAgICB0aGlzLmFzY2VuZF9yZXNvbHZlcigpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jb21wb3NlX2ZpeGVkX3NjYWxhcl9ub2RlID0gZnVuY3Rpb24oYW5jaG9yLCB2YWx1ZSkge1xuICAgICAgdmFyIGV2ZW50LCBub2RlO1xuICAgICAgZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB2YWx1ZSwgZXZlbnQuc3RhcnRfbWFyaywgZXZlbnQuZW5kX21hcmssIGV2ZW50LnN0eWxlKTtcbiAgICAgIGlmIChhbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JzW2FuY2hvcl0gPSBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jb21wb3NlX3NjYWxhcl9ub2RlID0gZnVuY3Rpb24oYW5jaG9yLCBwYXJlbnQsIGtleSkge1xuICAgICAgdmFyIGV2ZW50LCBleHRlbnNpb24sIGZpbGVUeXBlLCBub2RlLCB0YWc7XG4gICAgICBldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICB0YWcgPSBldmVudC50YWc7XG4gICAgICBub2RlID0ge307XG4gICAgICBpZiAodGFnID09PSBudWxsIHx8IHRhZyA9PT0gJyEnKSB7XG4gICAgICAgIHRhZyA9IHRoaXMucmVzb2x2ZShub2Rlcy5TY2FsYXJOb2RlLCBldmVudC52YWx1ZSwgZXZlbnQuaW1wbGljaXQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gJyFpbmNsdWRlJykge1xuICAgICAgICBpZiAoZXZlbnQudmFsdWUubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29tcG9zZXJFcnJvcignd2hpbGUgY29tcG9zaW5nIHNjYWxhciBvdXQgb2YgIWluY2x1ZGUnLCBudWxsLCBcImZpbGUgbmFtZS9VUkwgY2Fubm90IGJlIG51bGxcIiwgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uID0gZXZlbnQudmFsdWUuc3BsaXQoJy4nKS5wb3AoKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiA9PT0gJ3lhbWwnIHx8IGV4dGVuc2lvbiA9PT0gJ3ltbCcgfHwgZXh0ZW5zaW9uID09PSAncmFtbCcpIHtcbiAgICAgICAgICBmaWxlVHlwZSA9ICdmcmFnbWVudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsZVR5cGUgPSAnc2NhbGFyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGVzVG9SZWFkLnB1c2goe1xuICAgICAgICAgIHRhcmdldFVyaTogZXZlbnQudmFsdWUsXG4gICAgICAgICAgdHlwZTogZmlsZVR5cGUsXG4gICAgICAgICAgcGFyZW50Tm9kZTogcGFyZW50LFxuICAgICAgICAgIHBhcmVudEtleToga2V5LFxuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBpbmNsdWRpbmdDb250ZXh0OiB0aGlzLnNyYyxcbiAgICAgICAgICB0YXJnZXRGaWxlVXJpOiBldmVudC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSh0YWcsIGV2ZW50LnZhbHVlLCBldmVudC5zdGFydF9tYXJrLCBldmVudC5lbmRfbWFyaywgZXZlbnQuc3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKGFuY2hvciAmJiBub2RlKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yc1thbmNob3JdID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY29tcG9zZV9zZXF1ZW5jZV9ub2RlID0gZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICB2YXIgZW5kX2V2ZW50LCBpbmRleCwgbm9kZSwgc3RhcnRfZXZlbnQsIHRhZywgdmFsdWU7XG4gICAgICBzdGFydF9ldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICB0YWcgPSBzdGFydF9ldmVudC50YWc7XG4gICAgICBpZiAodGFnID09PSBudWxsIHx8IHRhZyA9PT0gJyEnKSB7XG4gICAgICAgIHRhZyA9IHRoaXMucmVzb2x2ZShub2Rlcy5TZXF1ZW5jZU5vZGUsIG51bGwsIHN0YXJ0X2V2ZW50LmltcGxpY2l0KTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU2VxdWVuY2VOb2RlKHRhZywgW10sIHN0YXJ0X2V2ZW50LnN0YXJ0X21hcmssIG51bGwsIHN0YXJ0X2V2ZW50LmZsb3dfc3R5bGUpO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICB0aGlzLmFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlNlcXVlbmNlRW5kRXZlbnQpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9IHRoaXMuY29tcG9zZV9ub2RlKG5vZGUsIGluZGV4KSkge1xuICAgICAgICAgIG5vZGUudmFsdWVbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVuZF9ldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICBub2RlLmVuZF9tYXJrID0gZW5kX2V2ZW50LmVuZF9tYXJrO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jb21wb3NlX21hcHBpbmdfbm9kZSA9IGZ1bmN0aW9uKGFuY2hvcikge1xuICAgICAgdmFyIGVuZF9ldmVudCwgaXRlbV9rZXksIGl0ZW1fdmFsdWUsIG5vZGUsIHN0YXJ0X2V2ZW50LCB0YWc7XG4gICAgICBzdGFydF9ldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICB0YWcgPSBzdGFydF9ldmVudC50YWc7XG4gICAgICBpZiAodGFnID09PSBudWxsIHx8IHRhZyA9PT0gJyEnKSB7XG4gICAgICAgIHRhZyA9IHRoaXMucmVzb2x2ZShub2Rlcy5NYXBwaW5nTm9kZSwgbnVsbCwgc3RhcnRfZXZlbnQuaW1wbGljaXQpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5NYXBwaW5nTm9kZSh0YWcsIFtdLCBzdGFydF9ldmVudC5zdGFydF9tYXJrLCBudWxsLCBzdGFydF9ldmVudC5mbG93X3N0eWxlKTtcbiAgICAgIGlmIChhbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JzW2FuY2hvcl0gPSBub2RlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQpKSB7XG4gICAgICAgIGl0ZW1fa2V5ID0gdGhpcy5jb21wb3NlX25vZGUobm9kZSk7XG4gICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihpdGVtX2tleSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db21wb3NlckVycm9yKCd3aGlsZSBjb21wb3NpbmcgbWFwcGluZyBrZXknLCBudWxsLCBcIm9ubHkgc2NhbGFyIG1hcCBrZXlzIGFyZSBhbGxvd2VkIGluIFJBTUxcIiwgaXRlbV9rZXkuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1fdmFsdWUgPSB0aGlzLmNvbXBvc2Vfbm9kZShub2RlLCBpdGVtX2tleSkpIHtcbiAgICAgICAgICBub2RlLnZhbHVlLnB1c2goW2l0ZW1fa2V5LCBpdGVtX3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVuZF9ldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICBub2RlLmVuZF9tYXJrID0gZW5kX2V2ZW50LmVuZF9tYXJrO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIHJldHVybiBDb21wb3NlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBub2RlcywgdXRpbCwgX3JlZiwgX3JlZjEsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3JFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uc3RydWN0b3JFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yRXJyb3IoKSB7XG4gICAgICBfcmVmID0gQ29uc3RydWN0b3JFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvckVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgdGhpcy5CYXNlQ29uc3RydWN0b3IgPSAoZnVuY3Rpb24oKSB7XG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9ycyA9IHt9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS55YW1sX211bHRpX2NvbnN0cnVjdG9ycyA9IHt9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHRhZywgY29uc3RydWN0b3IpIHtcbiAgICAgIGlmICghdGhpcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3lhbWxfY29uc3RydWN0b3JzJykpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUueWFtbF9jb25zdHJ1Y3RvcnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5wcm90b3R5cGUueWFtbF9jb25zdHJ1Y3RvcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLnlhbWxfY29uc3RydWN0b3JzW3RhZ10gPSBjb25zdHJ1Y3RvcjtcbiAgICB9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLmFkZF9tdWx0aV9jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHRhZ19wcmVmaXgsIG11bHRpX2NvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KCd5YW1sX211bHRpX2NvbnN0cnVjdG9ycycpKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzID0gdXRpbC5leHRlbmQoe30sIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZS55YW1sX211bHRpX2NvbnN0cnVjdG9yc1t0YWdfcHJlZml4XSA9IG11bHRpX2NvbnN0cnVjdG9yO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBCYXNlQ29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdGVkX29iamVjdHMgPSB7fTtcbiAgICAgIHRoaXMuY29uc3RydWN0aW5nX25vZGVzID0gW107XG4gICAgICB0aGlzLmRlZmVycmVkX2NvbnN0cnVjdG9ycyA9IFtdO1xuICAgIH1cblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X2RvY3VtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGRhdGE7XG4gICAgICB0aGlzLmFwcGx5QXN0VHJhbnNmb3JtYXRpb25zKG5vZGUpO1xuICAgICAgZGF0YSA9IHRoaXMuY29uc3RydWN0X29iamVjdChub2RlKTtcbiAgICAgIHdoaWxlICghdXRpbC5pc19lbXB0eSh0aGlzLmRlZmVycmVkX2NvbnN0cnVjdG9ycykpIHtcbiAgICAgICAgdGhpcy5kZWZlcnJlZF9jb25zdHJ1Y3RvcnMucG9wKCkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbnMoZGF0YSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5kZWZlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkX2NvbnN0cnVjdG9ycy5wdXNoKGYpO1xuICAgIH07XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9vYmplY3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY29uc3RydWN0b3IsIG9iamVjdCwgdGFnX3ByZWZpeCwgdGFnX3N1ZmZpeCwgX3JlZjE7XG4gICAgICBpZiAobm9kZS51bmlxdWVfaWQgaW4gdGhpcy5jb25zdHJ1Y3RlZF9vYmplY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGVkX29iamVjdHNbbm9kZS51bmlxdWVfaWRdO1xuICAgICAgfVxuICAgICAgaWYgKF9yZWYxID0gbm9kZS51bmlxdWVfaWQsIF9faW5kZXhPZi5jYWxsKHRoaXMuY29uc3RydWN0aW5nX25vZGVzLCBfcmVmMSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsICdmb3VuZCB1bmNvbnN0cnVjdGFibGUgcmVjdXJzaXZlIG5vZGUnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25zdHJ1Y3Rpbmdfbm9kZXMucHVzaChub2RlLnVuaXF1ZV9pZCk7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICB0YWdfc3VmZml4ID0gbnVsbDtcbiAgICAgIGlmIChub2RlLnRhZyBpbiB0aGlzLnlhbWxfY29uc3RydWN0b3JzKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy55YW1sX2NvbnN0cnVjdG9yc1tub2RlLnRhZ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHRhZ19wcmVmaXggaW4gdGhpcy55YW1sX211bHRpX2NvbnN0cnVjdG9ycykge1xuICAgICAgICAgIGlmIChub2RlLnRhZy5pbmRleE9mKHRhZ19wcmVmaXggPT09IDApKSB7XG4gICAgICAgICAgICB0YWdfc3VmZml4ID0gbm9kZS50YWcuc2xpY2UodGFnX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzW3RhZ19wcmVmaXhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKG51bGwgaW4gdGhpcy55YW1sX211bHRpX2NvbnN0cnVjdG9ycykge1xuICAgICAgICAgICAgdGFnX3N1ZmZpeCA9IG5vZGUudGFnO1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzW251bGxdO1xuICAgICAgICAgIH0gZWxzZSBpZiAobnVsbCBpbiB0aGlzLnlhbWxfY29uc3RydWN0b3JzKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMueWFtbF9jb25zdHJ1Y3RvcnNbbnVsbF07XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2NhbGFyTm9kZSkge1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2VxdWVuY2VOb2RlKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0X3NlcXVlbmNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0X21hcHBpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBjb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHRhZ19zdWZmaXggIT0gbnVsbCA/IHRhZ19zdWZmaXggOiBub2RlLCBub2RlKTtcbiAgICAgIHRoaXMuY29uc3RydWN0ZWRfb2JqZWN0c1tub2RlLnVuaXF1ZV9pZF0gPSBvYmplY3Q7XG4gICAgICB0aGlzLmNvbnN0cnVjdGluZ19ub2Rlcy5wb3AoKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3NjYWxhciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TY2FsYXJOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsIFwiZXhwZWN0ZWQgYSBzY2FsYXIgbm9kZSBidXQgZm91bmQgXCIgKyBub2RlLmlkLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3NlcXVlbmNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNoaWxkLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNlcXVlbmNlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBcImV4cGVjdGVkIGFuIGFycmF5IG5vZGUgYnV0IGZvdW5kIFwiICsgbm9kZS5pZCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gbm9kZS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNoaWxkID0gX3JlZjFbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuY29uc3RydWN0X29iamVjdChjaGlsZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9tYXBwaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGtleSwga2V5X2l0ZW0sIGtleV9pdGVtX3ZhbHVlLCBrZXlfbm9kZSwgbWFwcGluZywgdmFsdWUsIHZhbHVlX25vZGUsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYxLCBfcmVmMiwgX3JlZjM7XG4gICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgXCJleHBlY3RlZCBhIG1hcCBub2RlIGJ1dCBmb3VuZCBcIiArIG5vZGUuaWQsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBtYXBwaW5nID0ge307XG4gICAgICBfcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIF9yZWYyID0gX3JlZjFbX2ldLCBrZXlfbm9kZSA9IF9yZWYyWzBdLCB2YWx1ZV9ub2RlID0gX3JlZjJbMV07XG4gICAgICAgIGtleSA9IHRoaXMuY29uc3RydWN0X29iamVjdChrZXlfbm9kZSk7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KHZhbHVlX25vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYga2V5X25vZGUudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6c2VxJykge1xuICAgICAgICAgIF9yZWYzID0ga2V5X25vZGUudmFsdWU7XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjMubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICBrZXlfaXRlbSA9IF9yZWYzW19qXTtcbiAgICAgICAgICAgIGtleV9pdGVtX3ZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KGtleV9pdGVtKTtcbiAgICAgICAgICAgIG1hcHBpbmdba2V5X2l0ZW1fdmFsdWVdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcignd2hpbGUgY29uc3RydWN0aW5nIGEgbWFwJywgbm9kZS5zdGFydF9tYXJrLCAnZm91bmQgdW5oYXNoYWJsZSBrZXknLCBrZXlfbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBpbmc7XG4gICAgfTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3BhaXJzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGtleSwga2V5X25vZGUsIHBhaXJzLCB2YWx1ZSwgdmFsdWVfbm9kZSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMjtcbiAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBcImV4cGVjdGVkIGEgbWFwIG5vZGUgYnV0IGZvdW5kIFwiICsgbm9kZS5pZCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHBhaXJzID0gW107XG4gICAgICBfcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIF9yZWYyID0gX3JlZjFbX2ldLCBrZXlfbm9kZSA9IF9yZWYyWzBdLCB2YWx1ZV9ub2RlID0gX3JlZjJbMV07XG4gICAgICAgIGtleSA9IHRoaXMuY29uc3RydWN0X29iamVjdChrZXlfbm9kZSk7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KHZhbHVlX25vZGUpO1xuICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFpcnM7XG4gICAgfTtcblxuICAgIHJldHVybiBCYXNlQ29uc3RydWN0b3I7XG5cbiAgfSkoKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHZhciBCT09MX1ZBTFVFUywgVElNRVNUQU1QX1BBUlRTLCBUSU1FU1RBTVBfUkVHRVg7XG5cbiAgICBfX2V4dGVuZHMoQ29uc3RydWN0b3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBDb25zdHJ1Y3RvcigpIHtcbiAgICAgIF9yZWYxID0gQ29uc3RydWN0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjE7XG4gICAgfVxuXG4gICAgQk9PTF9WQUxVRVMgPSB7XG4gICAgICBcInRydWVcIjogdHJ1ZSxcbiAgICAgIFwiZmFsc2VcIjogZmFsc2VcbiAgICB9O1xuXG4gICAgVElNRVNUQU1QX1JFR0VYID0gL14oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldPyktKFswLTldWzAtOV0/KSg/Oig/OltUdF18W1xceDIwXFx0XSspKFswLTldWzAtOV0/KTooWzAtOV1bMC05XSk6KFswLTldWzAtOV0pKD86XFwuKFswLTldKikpPyg/OltcXHgyMFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KSg/OjooWzAtOV1bMC05XSkpPykpPyk/JC87XG5cbiAgICBUSU1FU1RBTVBfUEFSVFMgPSB7XG4gICAgICB5ZWFyOiAxLFxuICAgICAgbW9udGg6IDIsXG4gICAgICBkYXk6IDMsXG4gICAgICBob3VyOiA0LFxuICAgICAgbWludXRlOiA1LFxuICAgICAgc2Vjb25kOiA2LFxuICAgICAgZnJhY3Rpb246IDcsXG4gICAgICB0ejogOCxcbiAgICAgIHR6X3NpZ246IDksXG4gICAgICB0el9ob3VyOiAxMCxcbiAgICAgIHR6X21pbnV0ZTogMTFcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLnlhbWxfY29uc3RydWN0b3JzID0ge307XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMgPSB7fTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rfc2NhbGFyID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGtleV9ub2RlLCB2YWx1ZV9ub2RlLCBfaSwgX2xlbiwgX3JlZjIsIF9yZWYzO1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICBfcmVmMiA9IG5vZGUudmFsdWU7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBfcmVmMyA9IF9yZWYyW19pXSwga2V5X25vZGUgPSBfcmVmM1swXSwgdmFsdWVfbm9kZSA9IF9yZWYzWzFdO1xuICAgICAgICAgIGlmIChrZXlfbm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjp2YWx1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdF9zY2FsYXIodmFsdWVfbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3IuX19zdXBlcl9fLmNvbnN0cnVjdF9zY2FsYXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmZsYXR0ZW5fbWFwcGluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCwga2V5X25vZGUsIG1lcmdlLCBzdWJtZXJnZSwgc3Vibm9kZSwgdmFsdWUsIHZhbHVlX25vZGUsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYyLCBfcmVmMztcbiAgICAgIG1lcmdlID0gW107XG4gICAgICBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAoaW5kZXggPCBub2RlLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBfcmVmMiA9IG5vZGUudmFsdWVbaW5kZXhdLCBrZXlfbm9kZSA9IF9yZWYyWzBdLCB2YWx1ZV9ub2RlID0gX3JlZjJbMV07XG4gICAgICAgIGlmIChrZXlfbm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICAgICAgICBub2RlLnZhbHVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaWYgKHZhbHVlX25vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuX21hcHBpbmcodmFsdWVfbm9kZSk7XG4gICAgICAgICAgICBtZXJnZSA9IG1lcmdlLmNvbmNhdCh2YWx1ZV9ub2RlLnZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlX25vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXF1ZW5jZU5vZGUpIHtcbiAgICAgICAgICAgIHN1Ym1lcmdlID0gW107XG4gICAgICAgICAgICBfcmVmMyA9IHZhbHVlX25vZGUudmFsdWU7XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHN1Ym5vZGUgPSBfcmVmM1tfaV07XG4gICAgICAgICAgICAgIGlmICghKHN1Ym5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKCd3aGlsZSBjb25zdHJ1Y3RpbmcgYSBtYXAnLCBub2RlLnN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBtYXAgZm9yIG1lcmdpbmcsIGJ1dCBmb3VuZCBcIiArIHN1Ym5vZGUuaWQsIHN1Ym5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuX21hcHBpbmcoc3Vibm9kZSk7XG4gICAgICAgICAgICAgIHN1Ym1lcmdlLnB1c2goc3Vibm9kZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJtZXJnZS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBzdWJtZXJnZS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdWJtZXJnZVtfal07XG4gICAgICAgICAgICAgIG1lcmdlID0gbWVyZ2UuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcignd2hpbGUgY29uc3RydWN0aW5nIGEgbWFwJywgbm9kZS5zdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgbWFwIG9yIGFuIGFycmF5IG9mIG1hcHMgZm9yICAgICAgICAgICAgbWVyZ2luZyBidXQgZm91bmQgXCIgKyB2YWx1ZV9ub2RlLmlkLCB2YWx1ZV9ub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXlfbm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjp2YWx1ZScpIHtcbiAgICAgICAgICBrZXlfbm9kZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXJnZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUgPSBtZXJnZS5jb25jYXQobm9kZS52YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfbWFwcGluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgdGhpcy5mbGF0dGVuX21hcHBpbmcobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3IuX19zdXBlcl9fLmNvbnN0cnVjdF9tYXBwaW5nLmNhbGwodGhpcywgbm9kZSk7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9udWxsID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9ib29sID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICByZXR1cm4gQk9PTF9WQUxVRVNbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9pbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgYmFzZSwgZGlnaXQsIGRpZ2l0cywgcGFydCwgc2lnbiwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMjtcbiAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIHNpZ24gPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgaWYgKF9yZWYyID0gdmFsdWVbMF0sIF9faW5kZXhPZi5jYWxsKCcrLScsIF9yZWYyKSA+PSAwKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09ICcwJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignMGInKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignMHgnKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzBvJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgOCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlWzBdID09PSAnMCcpIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgOCk7XG4gICAgICB9IGVsc2UgaWYgKF9faW5kZXhPZi5jYWxsKHZhbHVlLCAnOicpID49IDApIHtcbiAgICAgICAgZGlnaXRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZjMsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYzID0gdmFsdWUuc3BsaXQoLzovZyk7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gX3JlZjNbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChwYXJzZUludChwYXJ0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgZGlnaXRzLnJldmVyc2UoKTtcbiAgICAgICAgYmFzZSA9IDE7XG4gICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBkaWdpdHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBkaWdpdCA9IGRpZ2l0c1tfaV07XG4gICAgICAgICAgdmFsdWUgKz0gZGlnaXQgKiBiYXNlO1xuICAgICAgICAgIGJhc2UgKj0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfZmxvYXQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgYmFzZSwgZGlnaXQsIGRpZ2l0cywgcGFydCwgc2lnbiwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMjtcbiAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc2lnbiA9IHZhbHVlWzBdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICBpZiAoX3JlZjIgPSB2YWx1ZVswXSwgX19pbmRleE9mLmNhbGwoJystJywgX3JlZjIpID49IDApIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH0gZWxzZSBpZiAoX19pbmRleE9mLmNhbGwodmFsdWUsICc6JykgPj0gMCkge1xuICAgICAgICBkaWdpdHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZjMgPSB2YWx1ZS5zcGxpdCgvOi9nKTtcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIHBhcnQgPSBfcmVmM1tfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnNlRmxvYXQocGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGRpZ2l0cy5yZXZlcnNlKCk7XG4gICAgICAgIGJhc2UgPSAxO1xuICAgICAgICB2YWx1ZSA9IDAuMDtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBkaWdpdHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBkaWdpdCA9IGRpZ2l0c1tfaV07XG4gICAgICAgICAgdmFsdWUgKz0gZGlnaXQgKiBiYXNlO1xuICAgICAgICAgIGJhc2UgKj0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9iaW5hcnkgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZXJyb3IsIHZhbHVlO1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXRvYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBcImZhaWxlZCB0byBkZWNvZGUgYmFzZTY0IGRhdGE6IFwiICsgZXJyb3IsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF90aW1lc3RhbXAgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZGF0ZSwgZGF5LCBmcmFjdGlvbiwgaG91ciwgaW5kZXgsIGtleSwgbWF0Y2gsIG1pbGxpc2Vjb25kLCBtaW51dGUsIG1vbnRoLCBzZWNvbmQsIHR6X2hvdXIsIHR6X21pbnV0ZSwgdHpfc2lnbiwgdmFsdWUsIHZhbHVlcywgeWVhcjtcbiAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgICAgbWF0Y2ggPSBub2RlLnZhbHVlLm1hdGNoKFRJTUVTVEFNUF9SRUdFWCk7XG4gICAgICB2YWx1ZXMgPSB7fTtcbiAgICAgIGZvciAoa2V5IGluIFRJTUVTVEFNUF9QQVJUUykge1xuICAgICAgICBpbmRleCA9IFRJTUVTVEFNUF9QQVJUU1trZXldO1xuICAgICAgICB2YWx1ZXNba2V5XSA9IG1hdGNoW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHllYXIgPSBwYXJzZUludCh2YWx1ZXMueWVhcik7XG4gICAgICBtb250aCA9IHBhcnNlSW50KHZhbHVlcy5tb250aCkgLSAxO1xuICAgICAgZGF5ID0gcGFyc2VJbnQodmFsdWVzLmRheSk7XG4gICAgICBpZiAoIXZhbHVlcy5ob3VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gICAgICB9XG4gICAgICBob3VyID0gcGFyc2VJbnQodmFsdWVzLmhvdXIpO1xuICAgICAgbWludXRlID0gcGFyc2VJbnQodmFsdWVzLm1pbnV0ZSk7XG4gICAgICBzZWNvbmQgPSBwYXJzZUludCh2YWx1ZXMuc2Vjb25kKTtcbiAgICAgIG1pbGxpc2Vjb25kID0gMDtcbiAgICAgIGlmICh2YWx1ZXMuZnJhY3Rpb24pIHtcbiAgICAgICAgZnJhY3Rpb24gPSB2YWx1ZXMuZnJhY3Rpb24uc2xpY2UoMCwgNik7XG4gICAgICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIGZyYWN0aW9uID0gcGFyc2VJbnQoZnJhY3Rpb24pO1xuICAgICAgICBtaWxsaXNlY29uZCA9IE1hdGgucm91bmQoZnJhY3Rpb24gLyAxMDAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXMudHpfc2lnbikge1xuICAgICAgICB0el9zaWduID0gdmFsdWVzLnR6X3NpZ24gPT09ICctJyA/IDEgOiAtMTtcbiAgICAgICAgaWYgKHR6X2hvdXIgPSBwYXJzZUludCh2YWx1ZXMudHpfaG91cikpIHtcbiAgICAgICAgICBob3VyICs9IHR6X3NpZ24gKiB0el9ob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0el9taW51dGUgPSBwYXJzZUludCh2YWx1ZXMudHpfbWludXRlKSkge1xuICAgICAgICAgIG1pbnV0ZSArPSB0el9zaWduICogdHpfbWludXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3BhaXJfbGlzdCA9IGZ1bmN0aW9uKHR5cGUsIG5vZGUpIHtcbiAgICAgIHZhciBsaXN0LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBsaXN0ID0gW107XG4gICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2VxdWVuY2VOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKFwid2hpbGUgY29uc3RydWN0aW5nIFwiICsgdHlwZSwgbm9kZS5zdGFydF9tYXJrLCBcImV4cGVjdGVkIGFuIGFycmF5IGJ1dCBmb3VuZCBcIiArIG5vZGUuaWQsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5LCBrZXlfbm9kZSwgc3Vibm9kZSwgdmFsdWUsIHZhbHVlX25vZGUsIF9pLCBfbGVuLCBfcmVmMiwgX3JlZjMsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmMiA9IG5vZGUudmFsdWU7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBzdWJub2RlID0gX3JlZjJbX2ldO1xuICAgICAgICAgIGlmICghKHN1Ym5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoXCJ3aGlsZSBjb25zdHJ1Y3RpbmcgXCIgKyB0eXBlLCBub2RlLnN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBtYXAgb2YgbGVuZ3RoIDEgYnV0IGZvdW5kIFwiICsgc3Vibm9kZS5pZCwgc3Vibm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN1Ym5vZGUudmFsdWUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKFwid2hpbGUgY29uc3RydWN0aW5nIFwiICsgdHlwZSwgbm9kZS5zdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgbWFwIG9mIGxlbmd0aCAxIGJ1dCBmb3VuZCBcIiArIHN1Ym5vZGUuaWQsIHN1Ym5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZWYzID0gc3Vibm9kZS52YWx1ZVswXSwga2V5X25vZGUgPSBfcmVmM1swXSwgdmFsdWVfbm9kZSA9IF9yZWYzWzFdO1xuICAgICAgICAgIGtleSA9IF90aGlzLmNvbnN0cnVjdF9vYmplY3Qoa2V5X25vZGUpO1xuICAgICAgICAgIHZhbHVlID0gX3RoaXMuY29uc3RydWN0X29iamVjdCh2YWx1ZV9ub2RlKTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGxpc3QucHVzaChba2V5LCB2YWx1ZV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfb21hcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdF95YW1sX3BhaXJfbGlzdCgnYW4gb3JkZXJlZCBtYXAnLCBub2RlKTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3BhaXJzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0X3lhbWxfcGFpcl9saXN0KCdwYWlycycsIG5vZGUpO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfc2V0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGRhdGEsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGRhdGEgPSBbXTtcbiAgICAgIHRoaXMuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpdGVtIGluIF90aGlzLmNvbnN0cnVjdF9tYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnB1c2goaXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9zdHIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rfc2NhbGFyKG5vZGUpO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfc2VxID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGRhdGEsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGRhdGEgPSBbXTtcbiAgICAgIHRoaXMuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtLCBfaSwgX2xlbiwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmMiA9IF90aGlzLmNvbnN0cnVjdF9zZXF1ZW5jZShub2RlKTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGl0ZW0gPSBfcmVmMltfaV07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLnB1c2goaXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9tYXAgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZGF0YSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleSwgdmFsdWUsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZjIgPSBfdGhpcy5jb25zdHJ1Y3RfbWFwcGluZyhub2RlKTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gX3JlZjIpIHtcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYyW2tleV07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX29iamVjdCA9IGZ1bmN0aW9uKG5vZGUsIGtsYXNzKSB7XG4gICAgICB2YXIgZGF0YSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgZGF0YSA9IG5ldyBrbGFzcztcbiAgICAgIHRoaXMuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXksIHZhbHVlLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYyID0gX3RoaXMuY29uc3RydWN0X21hcHBpbmcobm9kZSwgdHJ1ZSk7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoa2V5IGluIF9yZWYyKSB7XG4gICAgICAgICAgdmFsdWUgPSBfcmVmMltrZXldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZGF0YVtrZXldID0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfdW5kZWZpbmVkID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBcImNvdWxkIG5vdCBkZXRlcm1pbmUgYSBjb25zdHJ1Y3RvciBmb3IgdGhlIHRhZyBcIiArIG5vZGUudGFnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG5cbiAgfSkodGhpcy5CYXNlQ29uc3RydWN0b3IpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfbnVsbCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9ib29sKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6aW50JywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfaW50KTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9mbG9hdCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2JpbmFyeSk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3RpbWVzdGFtcCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9vbWFwKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9wYWlycyk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3NldCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3N0cik7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3NlcSk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX21hcCk7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IobnVsbCwgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3VuZGVmaW5lZCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuQ29uc3RydWN0b3IgPSB0aGlzLkNvbnN0cnVjdG9yO1xuXG4gIG1vZHVsZS5leHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IgPSB0aGlzLkNvbnN0cnVjdG9yRXJyb3I7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBfcmVmLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIHRoaXMuTWFyayA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNYXJrKG5hbWUsIGxpbmUsIGNvbHVtbiwgYnVmZmVyLCBwb2ludGVyKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xuICAgIH1cblxuICAgIE1hcmsucHJvdG90eXBlLmdldF9zbmlwcGV0ID0gZnVuY3Rpb24oaW5kZW50LCBtYXhfbGVuZ3RoKSB7XG4gICAgICB2YXIgYnJlYWtfY2hhcnMsIGVuZCwgaGVhZCwgc3RhcnQsIHRhaWwsIF9yZWYsIF9yZWYxO1xuICAgICAgaWYgKGluZGVudCA9PSBudWxsKSB7XG4gICAgICAgIGluZGVudCA9IDQ7XG4gICAgICB9XG4gICAgICBpZiAobWF4X2xlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIG1heF9sZW5ndGggPSA3NTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgYnJlYWtfY2hhcnMgPSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5JztcbiAgICAgIGhlYWQgPSAnJztcbiAgICAgIHN0YXJ0ID0gdGhpcy5wb2ludGVyO1xuICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiAoX3JlZiA9IHRoaXMuYnVmZmVyW3N0YXJ0IC0gMV0sIF9faW5kZXhPZi5jYWxsKGJyZWFrX2NoYXJzLCBfcmVmKSA8IDApKSB7XG4gICAgICAgIHN0YXJ0LS07XG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXIgLSBzdGFydCA+IG1heF9sZW5ndGggLyAyIC0gMSkge1xuICAgICAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgICAgIHN0YXJ0ICs9IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhaWwgPSAnJztcbiAgICAgIGVuZCA9IHRoaXMucG9pbnRlcjtcbiAgICAgIHdoaWxlIChlbmQgPCB0aGlzLmJ1ZmZlci5sZW5ndGggJiYgKF9yZWYxID0gdGhpcy5idWZmZXJbZW5kXSwgX19pbmRleE9mLmNhbGwoYnJlYWtfY2hhcnMsIF9yZWYxKSA8IDApKSB7XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBpZiAoZW5kIC0gdGhpcy5wb2ludGVyID4gbWF4X2xlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICAgICAgZW5kIC09IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiICsgKChuZXcgQXJyYXkoaW5kZW50KSkuam9pbignICcpKSArIGhlYWQgKyB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSArIHRhaWwgKyBcIlxcblwiICsgKChuZXcgQXJyYXkoaW5kZW50ICsgdGhpcy5wb2ludGVyIC0gc3RhcnQgKyBoZWFkLmxlbmd0aCkpLmpvaW4oJyAnKSkgKyBcIl5cIjtcbiAgICB9O1xuXG4gICAgTWFyay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzbmlwcGV0LCB3aGVyZTtcbiAgICAgIHNuaXBwZXQgPSB0aGlzLmdldF9zbmlwcGV0KCk7XG4gICAgICB3aGVyZSA9IFwiICBpbiBcXFwiXCIgKyB0aGlzLm5hbWUgKyBcIlxcXCIsIGxpbmUgXCIgKyAodGhpcy5saW5lICsgMSkgKyBcIiwgY29sdW1uIFwiICsgKHRoaXMuY29sdW1uICsgMSk7XG4gICAgICBpZiAoc25pcHBldCkge1xuICAgICAgICByZXR1cm4gd2hlcmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIiArIHdoZXJlICsgXCI6XFxuXCIgKyBzbmlwcGV0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gTWFyaztcblxuICB9KSgpO1xuXG4gIHRoaXMuWUFNTEVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhZQU1MRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBZQU1MRXJyb3IoKSB7XG4gICAgICBZQU1MRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFlBTUxFcnJvcjtcblxuICB9KShFcnJvcik7XG5cbiAgdGhpcy5NYXJrZWRZQU1MRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcmtlZFlBTUxFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIE1hcmtlZFlBTUxFcnJvcihjb250ZXh0LCBjb250ZXh0X21hcmssIG1lc3NhZ2UsIHByb2JsZW1fbWFyaywgbm90ZSkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMuY29udGV4dF9tYXJrID0gY29udGV4dF9tYXJrO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIHRoaXMucHJvYmxlbV9tYXJrID0gcHJvYmxlbV9tYXJrO1xuICAgICAgdGhpcy5ub3RlID0gbm90ZTtcbiAgICAgIE1hcmtlZFlBTUxFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wcm9ibGVtX21hcmspIHtcbiAgICAgICAgdGhpcy5wcm9ibGVtX21hcmsgPSB0aGlzLmNvbnRleHRfbWFyaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBNYXJrZWRZQU1MRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgaWYgKHRoaXMuY29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICgodGhpcy5jb250ZXh0X21hcmsgIT0gbnVsbCkgJiYgKCh0aGlzLm1lc3NhZ2UgPT0gbnVsbCkgfHwgKHRoaXMucHJvYmxlbV9tYXJrID09IG51bGwpIHx8IHRoaXMuY29udGV4dF9tYXJrLm5hbWUgIT09IHRoaXMucHJvYmxlbV9tYXJrLm5hbWUgfHwgdGhpcy5jb250ZXh0X21hcmsubGluZSAhPT0gdGhpcy5wcm9ibGVtX21hcmsubGluZSB8fCB0aGlzLmNvbnRleHRfbWFyay5jb2x1bW4gIT09IHRoaXMucHJvYmxlbV9tYXJrLmNvbHVtbikpIHtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmNvbnRleHRfbWFyay50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9ibGVtX21hcmsgIT0gbnVsbCkge1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMucHJvYmxlbV9tYXJrLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm90ZSAhPSBudWxsKSB7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5ub3RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcmtlZFlBTUxFcnJvcjtcblxuICB9KSh0aGlzLllBTUxFcnJvcik7XG5cbiAgLypcbiAgVGhlIFZhbGlkYXRvciB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLlZhbGlkYXRpb25FcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGlvbkVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgX3JlZiA9IFZhbGlkYXRpb25FcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3I7XG5cbiAgfSkodGhpcy5NYXJrZWRZQU1MRXJyb3IpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgX3JlZiwgX3JlZjEsIF9yZWYyLCBfcmVmMywgX3JlZjQsIF9yZWY1LCBfcmVmNixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICB0aGlzLkV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50KHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBFdmVudDtcblxuICB9KSgpO1xuXG4gIHRoaXMuTm9kZUV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb2RlRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXZlbnQoYW5jaG9yLCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXZlbnQ7XG5cbiAgfSkodGhpcy5FdmVudCk7XG5cbiAgdGhpcy5Db2xsZWN0aW9uU3RhcnRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sbGVjdGlvblN0YXJ0RXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uU3RhcnRFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5pbXBsaWNpdCA9IGltcGxpY2l0O1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gQ29sbGVjdGlvblN0YXJ0RXZlbnQ7XG5cbiAgfSkodGhpcy5Ob2RlRXZlbnQpO1xuXG4gIHRoaXMuQ29sbGVjdGlvbkVuZEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2xsZWN0aW9uRW5kRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uRW5kRXZlbnQoKSB7XG4gICAgICBfcmVmID0gQ29sbGVjdGlvbkVuZEV2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbGxlY3Rpb25FbmRFdmVudDtcblxuICB9KSh0aGlzLkV2ZW50KTtcblxuICB0aGlzLlN0cmVhbVN0YXJ0RXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmVhbVN0YXJ0RXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTdHJlYW1TdGFydEV2ZW50KHN0YXJ0X21hcmssIGVuZF9tYXJrLCBleHBsaWNpdCwgdmVyc2lvbiwgdGFncykge1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJlYW1TdGFydEV2ZW50O1xuXG4gIH0pKHRoaXMuRXZlbnQpO1xuXG4gIHRoaXMuU3RyZWFtRW5kRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmVhbUVuZEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU3RyZWFtRW5kRXZlbnQoKSB7XG4gICAgICBfcmVmMSA9IFN0cmVhbUVuZEV2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJlYW1FbmRFdmVudDtcblxuICB9KSh0aGlzLkV2ZW50KTtcblxuICB0aGlzLkRvY3VtZW50U3RhcnRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9jdW1lbnRTdGFydEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRTdGFydEV2ZW50KHN0YXJ0X21hcmssIGVuZF9tYXJrLCBleHBsaWNpdCwgdmVyc2lvbiwgdGFncykge1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIH1cblxuICAgIHJldHVybiBEb2N1bWVudFN0YXJ0RXZlbnQ7XG5cbiAgfSkodGhpcy5FdmVudCk7XG5cbiAgdGhpcy5Eb2N1bWVudEVuZEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb2N1bWVudEVuZEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRFbmRFdmVudChzdGFydF9tYXJrLCBlbmRfbWFyaywgZXhwbGljaXQpIHtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIERvY3VtZW50RW5kRXZlbnQ7XG5cbiAgfSkodGhpcy5FdmVudCk7XG5cbiAgdGhpcy5BbGlhc0V2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbGlhc0V2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQWxpYXNFdmVudCgpIHtcbiAgICAgIF9yZWYyID0gQWxpYXNFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMjtcbiAgICB9XG5cbiAgICByZXR1cm4gQWxpYXNFdmVudDtcblxuICB9KSh0aGlzLk5vZGVFdmVudCk7XG5cbiAgdGhpcy5TY2FsYXJFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTY2FsYXJFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgc3R5bGUpIHtcbiAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLmltcGxpY2l0ID0gaW1wbGljaXQ7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBTY2FsYXJFdmVudDtcblxuICB9KSh0aGlzLk5vZGVFdmVudCk7XG5cbiAgdGhpcy5TZXF1ZW5jZVN0YXJ0RXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlU3RhcnRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFNlcXVlbmNlU3RhcnRFdmVudCgpIHtcbiAgICAgIF9yZWYzID0gU2VxdWVuY2VTdGFydEV2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYzO1xuICAgIH1cblxuICAgIHJldHVybiBTZXF1ZW5jZVN0YXJ0RXZlbnQ7XG5cbiAgfSkodGhpcy5Db2xsZWN0aW9uU3RhcnRFdmVudCk7XG5cbiAgdGhpcy5TZXF1ZW5jZUVuZEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXF1ZW5jZUVuZEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2VxdWVuY2VFbmRFdmVudCgpIHtcbiAgICAgIF9yZWY0ID0gU2VxdWVuY2VFbmRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmNDtcbiAgICB9XG5cbiAgICByZXR1cm4gU2VxdWVuY2VFbmRFdmVudDtcblxuICB9KSh0aGlzLkNvbGxlY3Rpb25FbmRFdmVudCk7XG5cbiAgdGhpcy5NYXBwaW5nU3RhcnRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwcGluZ1N0YXJ0RXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBNYXBwaW5nU3RhcnRFdmVudCgpIHtcbiAgICAgIF9yZWY1ID0gTWFwcGluZ1N0YXJ0RXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjU7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hcHBpbmdTdGFydEV2ZW50O1xuXG4gIH0pKHRoaXMuQ29sbGVjdGlvblN0YXJ0RXZlbnQpO1xuXG4gIHRoaXMuTWFwcGluZ0VuZEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBwaW5nRW5kRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBNYXBwaW5nRW5kRXZlbnQoKSB7XG4gICAgICBfcmVmNiA9IE1hcHBpbmdFbmRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmNjtcbiAgICB9XG5cbiAgICByZXR1cm4gTWFwcGluZ0VuZEV2ZW50O1xuXG4gIH0pKHRoaXMuQ29sbGVjdGlvbkVuZEV2ZW50KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgbm9kZXMsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgLypcbiAgVGhlIFRyYWl0cyB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLkpvaW5FcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSm9pbkVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gSm9pbkVycm9yKCkge1xuICAgICAgX3JlZiA9IEpvaW5FcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBKb2luRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICBUaGUgSm9pbmVyIGNsYXNzIGdyb3VwcyByZXNvdXJjZXMgdW5kZXIgcmVzb3VyY2UgcHJvcGVydHkgYW5kIGdyb3VwcyBtZXRob2RzIHVuZGVyIG9wZXJhdGlvbnMgcHJvcGVydHlcbiAgKi9cblxuXG4gIHRoaXMuSm9pbmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEpvaW5lcigpIHt9XG5cbiAgICBKb2luZXIucHJvdG90eXBlLmpvaW5fcmVzb3VyY2VzID0gZnVuY3Rpb24obm9kZSwgY2FsbCkge1xuICAgICAgdmFyIHJlc291cmNlcywgcmVzb3VyY2VzQXJyYXksIHJlc291cmNlc05hbWUsIHJlc291cmNlc1ZhbHVlLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoY2FsbCA9PSBudWxsKSB7XG4gICAgICAgIGNhbGwgPSAwO1xuICAgICAgfVxuICAgICAgcmVzb3VyY2VzID0gW107XG4gICAgICBpZiAobm9kZSAhPSBudWxsID8gbm9kZS52YWx1ZSA6IHZvaWQgMCkge1xuICAgICAgICByZXNvdXJjZXMgPSBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3JlZjE7XG4gICAgICAgICAgcmV0dXJuIChfcmVmMSA9IGNoaWxkTm9kZVswXSkgIT0gbnVsbCA/IF9yZWYxLnZhbHVlLm1hdGNoKC9eXFwvLykgOiB2b2lkIDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVzb3VyY2VzQXJyYXkgPSBbXTtcbiAgICAgIGlmIChyZXNvdXJjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobm9kZSAhPSBudWxsID8gbm9kZS52YWx1ZSA6IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhY2hpbGROb2RlWzBdLnZhbHVlLm1hdGNoKC9eXFwvLyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb3VyY2VzTmFtZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCAncmVzb3VyY2VzJywgcmVzb3VyY2VzWzBdWzBdLnN0YXJ0X21hcmssIHJlc291cmNlc1tyZXNvdXJjZXMubGVuZ3RoIC0gMV1bMV0uZW5kX21hcmspO1xuICAgICAgICByZXNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICAgIHZhciByZWxhdGl2ZVVyaU5hbWUsIHJlbGF0aXZlVXJpVmFsdWU7XG4gICAgICAgICAgcmVsYXRpdmVVcmlOYW1lID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsICdyZWxhdGl2ZVVyaScsIHJlc291cmNlWzBdLnN0YXJ0X21hcmssIHJlc291cmNlWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICByZWxhdGl2ZVVyaVZhbHVlID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHJlc291cmNlWzBdLnZhbHVlLCByZXNvdXJjZVswXS5zdGFydF9tYXJrLCByZXNvdXJjZVsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgaWYgKHJlc291cmNlWzFdLnRhZyA9PT0gXCJ0YWc6eWFtbC5vcmcsMjAwMjpudWxsXCIpIHtcbiAgICAgICAgICAgIHJlc291cmNlWzFdID0gbmV3IG5vZGVzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgcmVzb3VyY2VbMF0uc3RhcnRfbWFyaywgcmVzb3VyY2VbMV0uZW5kX21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvdXJjZVsxXS52YWx1ZS5wdXNoKFtyZWxhdGl2ZVVyaU5hbWUsIHJlbGF0aXZlVXJpVmFsdWVdKTtcbiAgICAgICAgICByZXNvdXJjZXNBcnJheS5wdXNoKHJlc291cmNlWzFdKTtcbiAgICAgICAgICBfdGhpcy5qb2luX21ldGhvZHMocmVzb3VyY2VbMV0pO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5qb2luX3Jlc291cmNlcyhyZXNvdXJjZVsxXSwgKytjYWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc291cmNlc1ZhbHVlID0gbmV3IG5vZGVzLlNlcXVlbmNlTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywgcmVzb3VyY2VzQXJyYXksIHJlc291cmNlc1swXVswXS5zdGFydF9tYXJrLCByZXNvdXJjZXNbcmVzb3VyY2VzLmxlbmd0aCAtIDFdWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUucHVzaChbcmVzb3VyY2VzTmFtZSwgcmVzb3VyY2VzVmFsdWVdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgSm9pbmVyLnByb3RvdHlwZS5qb2luX21ldGhvZHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgbWV0aG9kcywgbWV0aG9kc0FycmF5LCBtZXRob2RzTmFtZSwgbWV0aG9kc1ZhbHVlLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBtZXRob2RzID0gW107XG4gICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlKSB7XG4gICAgICAgIG1ldGhvZHMgPSBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3JlZjE7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmlzSHR0cE1ldGhvZCgoX3JlZjEgPSBjaGlsZE5vZGVbMF0pICE9IG51bGwgPyBfcmVmMS52YWx1ZSA6IHZvaWQgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbWV0aG9kc0FycmF5ID0gW107XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gIV90aGlzLmlzSHR0cE1ldGhvZChjaGlsZE5vZGVbMF0udmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0aG9kc05hbWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgJ21ldGhvZHMnLCBtZXRob2RzWzBdWzBdLnN0YXJ0X21hcmssIG1ldGhvZHNbbWV0aG9kcy5sZW5ndGggLSAxXVsxXS5lbmRfbWFyayk7XG4gICAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICB2YXIgbWV0aG9kTmFtZSwgbWV0aG9kVmFsdWU7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCAnbWV0aG9kJywgbWV0aG9kWzBdLnN0YXJ0X21hcmssIG1ldGhvZFsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgbWV0aG9kVmFsdWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgbWV0aG9kWzBdLnZhbHVlLCBtZXRob2RbMF0uc3RhcnRfbWFyaywgbWV0aG9kWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICBpZiAobWV0aG9kWzFdLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnKSB7XG4gICAgICAgICAgICBtZXRob2RbMV0gPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCBtZXRob2RbMV0uc3RhcnRfbWFyaywgbWV0aG9kWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWV0aG9kWzFdLnZhbHVlLnB1c2goW21ldGhvZE5hbWUsIG1ldGhvZFZhbHVlXSk7XG4gICAgICAgICAgcmV0dXJuIG1ldGhvZHNBcnJheS5wdXNoKG1ldGhvZFsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtZXRob2RzVmFsdWUgPSBuZXcgbm9kZXMuU2VxdWVuY2VOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCBtZXRob2RzQXJyYXksIG1ldGhvZHNbMF1bMF0uc3RhcnRfbWFyaywgbWV0aG9kc1ttZXRob2RzLmxlbmd0aCAtIDFdWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUucHVzaChbbWV0aG9kc05hbWUsIG1ldGhvZHNWYWx1ZV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gSm9pbmVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBjb21wb3NlciwgY29uc3RydWN0LCBqb2luZXIsIHBhcnNlciwgcHJvdG9jb2xzLCByZWFkZXIsIHJlc29sdmVyLCBzY2FubmVyLCBzY2hlbWFzLCBzZWN1cml0eVNjaGVtZXMsIHRyYWl0cywgdHJhbnNmb3JtYXRpb25zLCB0eXBlcywgdXRpbCwgdmFsaWRhdG9yO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICByZWFkZXIgPSByZXF1aXJlKCcuL3JlYWRlcicpO1xuXG4gIHNjYW5uZXIgPSByZXF1aXJlKCcuL3NjYW5uZXInKTtcblxuICBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG4gIGNvbXBvc2VyID0gcmVxdWlyZSgnLi9jb21wb3NlcicpO1xuXG4gIHJlc29sdmVyID0gcmVxdWlyZSgnLi9yZXNvbHZlcicpO1xuXG4gIGNvbnN0cnVjdCA9IHJlcXVpcmUoJy4vY29uc3RydWN0Jyk7XG5cbiAgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3InKTtcblxuICBqb2luZXIgPSByZXF1aXJlKCcuL2pvaW5lcicpO1xuXG4gIHRyYWl0cyA9IHJlcXVpcmUoJy4vdHJhaXRzJyk7XG5cbiAgdHlwZXMgPSByZXF1aXJlKCcuL3Jlc291cmNlVHlwZXMnKTtcblxuICBzY2hlbWFzID0gcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgcHJvdG9jb2xzID0gcmVxdWlyZSgnLi9wcm90b2NvbHMnKTtcblxuICBzZWN1cml0eVNjaGVtZXMgPSByZXF1aXJlKCcuL3NlY3VyaXR5U2NoZW1lcycpO1xuXG4gIHRyYW5zZm9ybWF0aW9ucyA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtYXRpb25zJyk7XG5cbiAgdGhpcy5tYWtlX2xvYWRlciA9IGZ1bmN0aW9uKFJlYWRlciwgU2Nhbm5lciwgUGFyc2VyLCBDb21wb3NlciwgUmVzb2x2ZXIsIFZhbGlkYXRvciwgUmVzb3VyY2VUeXBlcywgVHJhaXRzLCBTY2hlbWFzLCBQcm90b2NvbHMsIEpvaW5lciwgU2VjdXJpdHlTY2hlbWVzLCBDb25zdHJ1Y3RvciwgVHJhbnNmb3JtYXRpb25zKSB7XG4gICAgaWYgKFJlYWRlciA9PSBudWxsKSB7XG4gICAgICBSZWFkZXIgPSByZWFkZXIuUmVhZGVyO1xuICAgIH1cbiAgICBpZiAoU2Nhbm5lciA9PSBudWxsKSB7XG4gICAgICBTY2FubmVyID0gc2Nhbm5lci5TY2FubmVyO1xuICAgIH1cbiAgICBpZiAoUGFyc2VyID09IG51bGwpIHtcbiAgICAgIFBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG4gICAgfVxuICAgIGlmIChDb21wb3NlciA9PSBudWxsKSB7XG4gICAgICBDb21wb3NlciA9IGNvbXBvc2VyLkNvbXBvc2VyO1xuICAgIH1cbiAgICBpZiAoUmVzb2x2ZXIgPT0gbnVsbCkge1xuICAgICAgUmVzb2x2ZXIgPSByZXNvbHZlci5SZXNvbHZlcjtcbiAgICB9XG4gICAgaWYgKFZhbGlkYXRvciA9PSBudWxsKSB7XG4gICAgICBWYWxpZGF0b3IgPSB2YWxpZGF0b3IuVmFsaWRhdG9yO1xuICAgIH1cbiAgICBpZiAoUmVzb3VyY2VUeXBlcyA9PSBudWxsKSB7XG4gICAgICBSZXNvdXJjZVR5cGVzID0gdHlwZXMuUmVzb3VyY2VUeXBlcztcbiAgICB9XG4gICAgaWYgKFRyYWl0cyA9PSBudWxsKSB7XG4gICAgICBUcmFpdHMgPSB0cmFpdHMuVHJhaXRzO1xuICAgIH1cbiAgICBpZiAoU2NoZW1hcyA9PSBudWxsKSB7XG4gICAgICBTY2hlbWFzID0gc2NoZW1hcy5TY2hlbWFzO1xuICAgIH1cbiAgICBpZiAoUHJvdG9jb2xzID09IG51bGwpIHtcbiAgICAgIFByb3RvY29scyA9IHByb3RvY29scy5Qcm90b2NvbHM7XG4gICAgfVxuICAgIGlmIChKb2luZXIgPT0gbnVsbCkge1xuICAgICAgSm9pbmVyID0gam9pbmVyLkpvaW5lcjtcbiAgICB9XG4gICAgaWYgKFNlY3VyaXR5U2NoZW1lcyA9PSBudWxsKSB7XG4gICAgICBTZWN1cml0eVNjaGVtZXMgPSBzZWN1cml0eVNjaGVtZXMuU2VjdXJpdHlTY2hlbWVzO1xuICAgIH1cbiAgICBpZiAoQ29uc3RydWN0b3IgPT0gbnVsbCkge1xuICAgICAgQ29uc3RydWN0b3IgPSBjb25zdHJ1Y3QuQ29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmIChUcmFuc2Zvcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgVHJhbnNmb3JtYXRpb25zID0gdHJhbnNmb3JtYXRpb25zLlRyYW5zZm9ybWF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21wb25lbnQsIGNvbXBvbmVudHM7XG5cbiAgICAgIGNvbXBvbmVudHMgPSBbUmVhZGVyLCBTY2FubmVyLCBDb21wb3NlciwgVHJhbnNmb3JtYXRpb25zLCBQYXJzZXIsIFJlc29sdmVyLCBWYWxpZGF0b3IsIFRyYWl0cywgUmVzb3VyY2VUeXBlcywgU2NoZW1hcywgUHJvdG9jb2xzLCBKb2luZXIsIENvbnN0cnVjdG9yLCBTZWN1cml0eVNjaGVtZXNdO1xuXG4gICAgICB1dGlsLmV4dGVuZC5hcHBseSh1dGlsLCBbX0NsYXNzLnByb3RvdHlwZV0uY29uY2F0KChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjb21wb25lbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tfaV07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChjb21wb25lbnQucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpKSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9DbGFzcyhzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgcGFyZW50KSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgIT0gbnVsbCA/IHBhcmVudCA6IG51bGw7XG4gICAgICAgIGNvbXBvbmVudHNbMF0uY2FsbCh0aGlzLCBzdHJlYW0sIGxvY2F0aW9uKTtcbiAgICAgICAgY29tcG9uZW50c1sxXS5jYWxsKHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgY29tcG9uZW50c1syXS5jYWxsKHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgY29tcG9uZW50c1szXS5jYWxsKHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgX3JlZiA9IGNvbXBvbmVudHMuc2xpY2UoNCk7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IF9yZWZbX2ldO1xuICAgICAgICAgIGNvbXBvbmVudC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfQ2xhc3M7XG5cbiAgICB9KSgpO1xuICB9O1xuXG4gIHRoaXMuTG9hZGVyID0gdGhpcy5tYWtlX2xvYWRlcigpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCB1bmlxdWVfaWQsIF9yZWYsIF9yZWYxLCBfcmVmMixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICB1bmlxdWVfaWQgPSAwO1xuXG4gIHRoaXMuQXBwbGljYXRpb25FcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXBwbGljYXRpb25FcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uRXJyb3IoKSB7XG4gICAgICBfcmVmID0gQXBwbGljYXRpb25FcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBBcHBsaWNhdGlvbkVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgdGhpcy5Ob2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUodGFnLCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMudW5pcXVlX2lkID0gXCJub2RlX1wiICsgKHVuaXF1ZV9pZCsrKTtcbiAgICB9XG5cbiAgICBOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRlbXA7XG4gICAgICB0ZW1wID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50YWcsIHRoaXMudmFsdWUsIHRoaXMuc3RhcnRfbWFyaywgdGhpcy5lbmRfbWFyayk7XG4gICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5vZGU7XG5cbiAgfSkoKTtcblxuICB0aGlzLlNjYWxhck5vZGUgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhck5vZGUsIF9zdXBlcik7XG5cbiAgICBTY2FsYXJOb2RlLnByb3RvdHlwZS5pZCA9ICdzY2FsYXInO1xuXG4gICAgZnVuY3Rpb24gU2NhbGFyTm9kZSh0YWcsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgc3R5bGUpIHtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgIFNjYWxhck5vZGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgU2NhbGFyTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ZW1wO1xuICAgICAgdGVtcCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGFnLCB0aGlzLnZhbHVlLCB0aGlzLnN0YXJ0X21hcmssIHRoaXMuZW5kX21hcmssIHRoaXMuc3R5bGUpO1xuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcblxuICAgIFNjYWxhck5vZGUucHJvdG90eXBlLmNsb25lUmVtb3ZlSXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgfTtcblxuICAgIFNjYWxhck5vZGUucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAodGhpcy50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyAmJiBub2RlLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBleHBvcnRzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgbm9kZS5zdGFydF9tYXJrLCBub2RlLmVuZF9tYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuY29tYmluZShub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoIShub2RlIGluc3RhbmNlb2YgZXhwb3J0cy5TY2FsYXJOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5BcHBsaWNhdGlvbkVycm9yKCd3aGlsZSBhcHBseWluZyBub2RlJywgbnVsbCwgJ2RpZmZlcmVudCBZQU1MIHN0cnVjdHVyZXMnLCB0aGlzLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH07XG5cbiAgICBTY2FsYXJOb2RlLnByb3RvdHlwZS5yZW1vdmVfcXVlc3Rpb25fbWFya19wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIHJldHVybiBTY2FsYXJOb2RlO1xuXG4gIH0pKHRoaXMuTm9kZSk7XG5cbiAgdGhpcy5Db2xsZWN0aW9uTm9kZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sbGVjdGlvbk5vZGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uTm9kZSh0YWcsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgZmxvd19zdHlsZSkge1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5mbG93X3N0eWxlID0gZmxvd19zdHlsZTtcbiAgICAgIENvbGxlY3Rpb25Ob2RlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBDb2xsZWN0aW9uTm9kZTtcblxuICB9KSh0aGlzLk5vZGUpO1xuXG4gIHRoaXMuU2VxdWVuY2VOb2RlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXF1ZW5jZU5vZGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTZXF1ZW5jZU5vZGUoKSB7XG4gICAgICBfcmVmMSA9IFNlcXVlbmNlTm9kZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICBTZXF1ZW5jZU5vZGUucHJvdG90eXBlLmlkID0gJ3NlcXVlbmNlJztcblxuICAgIFNlcXVlbmNlTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdGVtLCBpdGVtcywgdGVtcCwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMjtcbiAgICAgIGl0ZW1zID0gW107XG4gICAgICBfcmVmMiA9IHRoaXMudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBfcmVmMltfaV07XG4gICAgICAgIHZhbHVlID0gaXRlbS5jbG9uZSgpO1xuICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRlbXAgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRhZywgaXRlbXMsIHRoaXMuc3RhcnRfbWFyaywgdGhpcy5lbmRfbWFyaywgdGhpcy5mbG93X3N0eWxlKTtcbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG5cbiAgICBTZXF1ZW5jZU5vZGUucHJvdG90eXBlLmNsb25lUmVtb3ZlSXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTm9kZS5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgZXhwb3J0cy5TZXF1ZW5jZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkFwcGxpY2F0aW9uRXJyb3IoJ3doaWxlIGFwcGx5aW5nIG5vZGUnLCBudWxsLCAnZGlmZmVyZW50IFlBTUwgc3RydWN0dXJlcycsIHRoaXMuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVmMiA9IG5vZGUudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYyW19pXTtcbiAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5jbG9uZSgpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsdWUucHVzaCh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBTZXF1ZW5jZU5vZGUucHJvdG90eXBlLnJlbW92ZV9xdWVzdGlvbl9tYXJrX3Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdGVtLCBfaSwgX2xlbiwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgX3JlZjIgPSB0aGlzLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgaXRlbSA9IF9yZWYyW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChpdGVtLnJlbW92ZV9xdWVzdGlvbl9tYXJrX3Byb3BlcnRpZXMoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXF1ZW5jZU5vZGU7XG5cbiAgfSkodGhpcy5Db2xsZWN0aW9uTm9kZSk7XG5cbiAgdGhpcy5NYXBwaW5nTm9kZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwcGluZ05vZGUsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBNYXBwaW5nTm9kZSgpIHtcbiAgICAgIF9yZWYyID0gTWFwcGluZ05vZGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjI7XG4gICAgfVxuXG4gICAgTWFwcGluZ05vZGUucHJvdG90eXBlLmlkID0gJ21hcHBpbmcnO1xuXG4gICAgTWFwcGluZ05vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSwgcHJvcGVydGllcywgcHJvcGVydHksIHRlbXAsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjM7XG4gICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICBfcmVmMyA9IHRoaXMudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjNbX2ldO1xuICAgICAgICBuYW1lID0gcHJvcGVydHlbMF0uY2xvbmUoKTtcbiAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eVsxXS5jbG9uZSgpO1xuICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICB9XG4gICAgICB0ZW1wID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50YWcsIHByb3BlcnRpZXMsIHRoaXMuc3RhcnRfbWFyaywgdGhpcy5lbmRfbWFyaywgdGhpcy5mbG93X3N0eWxlKTtcbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUuY2xvbmVSZW1vdmVJcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5hbWUsIHByb3BlcnRpZXMsIHByb3BlcnR5LCB0ZW1wLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYzLCBfcmVmNDtcbiAgICAgIHByb3BlcnRpZXMgPSBbXTtcbiAgICAgIF9yZWYzID0gdGhpcy52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmM1tfaV07XG4gICAgICAgIG5hbWUgPSBwcm9wZXJ0eVswXS5jbG9uZVJlbW92ZUlzKCk7XG4gICAgICAgIHZhbHVlID0gcHJvcGVydHlbMV0uY2xvbmVSZW1vdmVJcygpO1xuICAgICAgICBpZiAoKF9yZWY0ID0gbmFtZS52YWx1ZSkgIT09ICdpcycpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXAgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRhZywgcHJvcGVydGllcywgdGhpcy5zdGFydF9tYXJrLCB0aGlzLmVuZF9tYXJrLCB0aGlzLmZsb3dfc3R5bGUpO1xuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcblxuICAgIE1hcHBpbmdOb2RlLnByb3RvdHlwZS5jbG9uZUZvclRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSwgcHJvcGVydGllcywgcHJvcGVydHksIHRlbXAsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjMsIF9yZWY0O1xuICAgICAgcHJvcGVydGllcyA9IFtdO1xuICAgICAgX3JlZjMgPSB0aGlzLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYzW19pXTtcbiAgICAgICAgbmFtZSA9IHByb3BlcnR5WzBdLmNsb25lKCk7XG4gICAgICAgIHZhbHVlID0gcHJvcGVydHlbMV0uY2xvbmUoKTtcbiAgICAgICAgaWYgKChfcmVmNCA9IG5hbWUudmFsdWUpICE9PSAndXNhZ2UnICYmIF9yZWY0ICE9PSAnZGlzcGxheU5hbWUnKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50YWcsIHByb3BlcnRpZXMsIHRoaXMuc3RhcnRfbWFyaywgdGhpcy5lbmRfbWFyaywgdGhpcy5mbG93X3N0eWxlKTtcbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUuY2xvbmVGb3JSZXNvdXJjZVR5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eSwgdGVtcCwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMywgX3JlZjQ7XG4gICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICBfcmVmMyA9IHRoaXMudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjNbX2ldO1xuICAgICAgICBuYW1lID0gcHJvcGVydHlbMF0uY2xvbmVSZW1vdmVJcygpO1xuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5WzFdLmNsb25lUmVtb3ZlSXMoKTtcbiAgICAgICAgaWYgKChfcmVmNCA9IG5hbWUudmFsdWUpICE9PSAnaXMnICYmIF9yZWY0ICE9PSAndHlwZScgJiYgX3JlZjQgIT09ICd1c2FnZScgJiYgX3JlZjQgIT09ICdkaXNwbGF5TmFtZScpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXAgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRhZywgcHJvcGVydGllcywgdGhpcy5zdGFydF9tYXJrLCB0aGlzLmVuZF9tYXJrLCB0aGlzLmZsb3dfc3R5bGUpO1xuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcblxuICAgIE1hcHBpbmdOb2RlLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24ocmVzb3VyY2VOb2RlKSB7XG4gICAgICB2YXIgbmFtZSwgbm9kZV9oYXNfcHJvcGVydHksIG5vbk51bGxOb2RlLCBvd25Ob2RlUHJvcGVydHksIG93bk5vZGVQcm9wZXJ0eU5hbWUsIHJlc291cmNlUHJvcGVydHksIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG4gICAgICBpZiAocmVzb3VyY2VOb2RlLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnKSB7XG4gICAgICAgIHJlc291cmNlTm9kZSA9IG5ldyBleHBvcnRzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgcmVzb3VyY2VOb2RlLnN0YXJ0X21hcmssIHJlc291cmNlTm9kZS5lbmRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXNvdXJjZU5vZGUgaW5zdGFuY2VvZiBleHBvcnRzLk1hcHBpbmdOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5BcHBsaWNhdGlvbkVycm9yKCd3aGlsZSBhcHBseWluZyBub2RlJywgbnVsbCwgJ2RpZmZlcmVudCBZQU1MIHN0cnVjdHVyZXMnLCB0aGlzLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3JlZjMgPSByZXNvdXJjZU5vZGUudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICByZXNvdXJjZVByb3BlcnR5ID0gX3JlZjNbX2ldO1xuICAgICAgICBuYW1lID0gcmVzb3VyY2VQcm9wZXJ0eVswXS52YWx1ZTtcbiAgICAgICAgbm9kZV9oYXNfcHJvcGVydHkgPSB0aGlzLnZhbHVlLnNvbWUoZnVuY3Rpb24oc29tZVByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIChzb21lUHJvcGVydHlbMF0udmFsdWUgPT09IG5hbWUpIHx8ICgoc29tZVByb3BlcnR5WzBdLnZhbHVlICsgJz8nKSA9PT0gbmFtZSkgfHwgKHNvbWVQcm9wZXJ0eVswXS52YWx1ZSA9PT0gKG5hbWUgKyAnPycpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChub2RlX2hhc19wcm9wZXJ0eSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjQsIF9yZXN1bHRzMTtcbiAgICAgICAgICAgIF9yZWY0ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjQubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICAgIG93bk5vZGVQcm9wZXJ0eSA9IF9yZWY0W19qXTtcbiAgICAgICAgICAgICAgb3duTm9kZVByb3BlcnR5TmFtZSA9IG93bk5vZGVQcm9wZXJ0eVswXS52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKChvd25Ob2RlUHJvcGVydHlOYW1lID09PSBuYW1lKSB8fCAoKG93bk5vZGVQcm9wZXJ0eU5hbWUgKyAnPycpID09PSBuYW1lKSB8fCAob3duTm9kZVByb3BlcnR5TmFtZSA9PT0gKG5hbWUgKyAnPycpKSkge1xuICAgICAgICAgICAgICAgIGlmICgob3duTm9kZVByb3BlcnR5WzFdLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnKSAmJiAocmVzb3VyY2VQcm9wZXJ0eVsxXS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnKSkge1xuICAgICAgICAgICAgICAgICAgbm9uTnVsbE5vZGUgPSBuZXcgZXhwb3J0cy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIG93bk5vZGVQcm9wZXJ0eVsxXS5zdGFydF9tYXJrLCBvd25Ob2RlUHJvcGVydHlbMV0uZW5kX21hcmspO1xuICAgICAgICAgICAgICAgICAgb3duTm9kZVByb3BlcnR5WzFdID0gbm9uTnVsbE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG93bk5vZGVQcm9wZXJ0eVsxXS5jb21iaW5lKHJlc291cmNlUHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICAgIGlmICghKChvd25Ob2RlUHJvcGVydHlbMF0udmFsdWUuc2xpY2UoLTEpID09PSAnPycpICYmIChyZXNvdXJjZVByb3BlcnR5WzBdLnZhbHVlLnNsaWNlKC0xKSA9PT0gJz8nKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvd25Ob2RlUHJvcGVydHlbMF0udmFsdWUuc2xpY2UoLTEpID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2gob3duTm9kZVByb3BlcnR5WzBdLnZhbHVlID0gb3duTm9kZVByb3BlcnR5WzBdLnZhbHVlLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWx1ZS5wdXNoKFtyZXNvdXJjZVByb3BlcnR5WzBdLmNsb25lKCksIHJlc291cmNlUHJvcGVydHlbMV0uY2xvbmUoKV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUucmVtb3ZlX3F1ZXN0aW9uX21hcmtfcHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByb3BlcnR5LCBfaSwgX2xlbiwgX3JlZjMsIF9yZXN1bHRzO1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVswXS52YWx1ZS5zbGljZSgtMSkgIT09ICc/JztcbiAgICAgIH0pO1xuICAgICAgX3JlZjMgPSB0aGlzLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmM1tfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2gocHJvcGVydHlbMV0ucmVtb3ZlX3F1ZXN0aW9uX21hcmtfcHJvcGVydGllcygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcHBpbmdOb2RlO1xuXG4gIH0pKHRoaXMuQ29sbGVjdGlvbk5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBldmVudHMsIHRva2VucywgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX3NsaWNlID0gW10uc2xpY2U7XG5cbiAgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICB0b2tlbnMgPSByZXF1aXJlKCcuL3Rva2VucycpO1xuXG4gIHRoaXMuUGFyc2VyRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnNlckVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gUGFyc2VyRXJyb3IoKSB7XG4gICAgICBfcmVmID0gUGFyc2VyRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICB0aGlzLlBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgREVGQVVMVF9UQUdTO1xuXG4gICAgREVGQVVMVF9UQUdTID0ge1xuICAgICAgJyEnOiAnIScsXG4gICAgICAnISEnOiAndGFnOnlhbWwub3JnLDIwMDI6J1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRfZXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy55YW1sX3ZlcnNpb24gPSBudWxsO1xuICAgICAgdGhpcy50YWdfaGFuZGxlcyA9IHt9O1xuICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgIHRoaXMubWFya3MgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2Vfc3RyZWFtX3N0YXJ0JztcbiAgICB9XG5cbiAgICAvKlxuICAgIFJlc2V0IHRoZSBzdGF0ZSBhdHRyaWJ1dGVzLlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVjayB0aGUgdHlwZSBvZiB0aGUgbmV4dCBldmVudC5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmNoZWNrX2V2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hvaWNlLCBjaG9pY2VzLCBfaSwgX2xlbjtcbiAgICAgIGNob2ljZXMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50X2V2ZW50ID0gdGhpc1t0aGlzLnN0YXRlXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50X2V2ZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjaG9pY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gY2hvaWNlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGNob2ljZSA9IGNob2ljZXNbX2ldO1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRfZXZlbnQgaW5zdGFuY2VvZiBjaG9pY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdldCB0aGUgbmV4dCBldmVudC5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBlZWtfZXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRfZXZlbnQgPT09IG51bGwgJiYgKHRoaXMuc3RhdGUgIT0gbnVsbCkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50X2V2ZW50ID0gdGhpc1t0aGlzLnN0YXRlXSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudF9ldmVudDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBHZXQgdGhlIGV2ZW50IGFuZCBwcm9jZWVkIGZ1cnRoZXIuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5nZXRfZXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBldmVudDtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRfZXZlbnQgPT09IG51bGwgJiYgKHRoaXMuc3RhdGUgIT0gbnVsbCkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50X2V2ZW50ID0gdGhpc1t0aGlzLnN0YXRlXSgpO1xuICAgICAgfVxuICAgICAgZXZlbnQgPSB0aGlzLmN1cnJlbnRfZXZlbnQ7XG4gICAgICB0aGlzLmN1cnJlbnRfZXZlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFBhcnNlIHRoZSBzdHJlYW0gc3RhcnQuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9zdHJlYW1fc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBldmVudCwgdG9rZW47XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICBldmVudCA9IG5ldyBldmVudHMuU3RyZWFtU3RhcnRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2ltcGxpY2l0X2RvY3VtZW50X3N0YXJ0JztcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBQYXJzZSBhbiBpbXBsaWNpdCBkb2N1bWVudC5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2ltcGxpY2l0X2RvY3VtZW50X3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW5kX21hcmssIGV2ZW50LCBzdGFydF9tYXJrLCB0b2tlbjtcbiAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRGlyZWN0aXZlVG9rZW4sIHRva2Vucy5Eb2N1bWVudFN0YXJ0VG9rZW4sIHRva2Vucy5TdHJlYW1FbmRUb2tlbikpIHtcbiAgICAgICAgdGhpcy50YWdfaGFuZGxlcyA9IERFRkFVTFRfVEFHUztcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgc3RhcnRfbWFyayA9IGVuZF9tYXJrID0gdG9rZW4uc3RhcnRfbWFyaztcbiAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLkRvY3VtZW50U3RhcnRFdmVudChzdGFydF9tYXJrLCBlbmRfbWFyaywgZmFsc2UpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9kb2N1bWVudF9lbmQnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19ub2RlJztcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZG9jdW1lbnRfc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBQYXJzZSBhbiBleHBsaWNpdCBkb2N1bWVudC5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2RvY3VtZW50X3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW5kX21hcmssIGV2ZW50LCBzdGFydF9tYXJrLCB0YWdzLCB0b2tlbiwgdmVyc2lvbiwgX3JlZjE7XG4gICAgICB3aGlsZSAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRG9jdW1lbnRFbmRUb2tlbikpIHtcbiAgICAgICAgdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuU3RyZWFtRW5kVG9rZW4pKSB7XG4gICAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5zdGFydF9tYXJrO1xuICAgICAgICBfcmVmMSA9IHRoaXMucHJvY2Vzc19kaXJlY3RpdmVzKCksIHZlcnNpb24gPSBfcmVmMVswXSwgdGFncyA9IF9yZWYxWzFdO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkRvY3VtZW50U3RhcnRUb2tlbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihcImV4cGVjdGVkICc8ZG9jdW1lbnQgc3RhcnQ+JywgYnV0IGZvdW5kIFwiICsgKHRoaXMucGVla190b2tlbigpLmlkKSwgdGhpcy5wZWVrX3Rva2VuKCkuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICBldmVudCA9IG5ldyBldmVudHMuRG9jdW1lbnRTdGFydEV2ZW50KHN0YXJ0X21hcmssIGVuZF9tYXJrLCB0cnVlLCB2ZXJzaW9uLCB0YWdzKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZG9jdW1lbnRfZW5kJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZG9jdW1lbnRfY29udGVudCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TdHJlYW1FbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc2VydGlvbiBlcnJvciwgc3RhdGVzIHNob3VsZCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzZXJ0aW9uIGVycm9yLCBtYXJrcyBzaG91bGQgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBQYXJzZSB0aGUgZG9jdW1lbnQgZW5kLlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZG9jdW1lbnRfZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW5kX21hcmssIGV2ZW50LCBleHBsaWNpdCwgc3RhcnRfbWFyaywgdG9rZW47XG4gICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgc3RhcnRfbWFyayA9IGVuZF9tYXJrID0gdG9rZW4uc3RhcnRfbWFyaztcbiAgICAgIGV4cGxpY2l0ID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRG9jdW1lbnRFbmRUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICBleHBsaWNpdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBldmVudCA9IG5ldyBldmVudHMuRG9jdW1lbnRFbmRFdmVudChzdGFydF9tYXJrLCBlbmRfbWFyaywgZXhwbGljaXQpO1xuICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9kb2N1bWVudF9zdGFydCc7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZG9jdW1lbnRfY29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkRpcmVjdGl2ZVRva2VuLCB0b2tlbnMuRG9jdW1lbnRTdGFydFRva2VuLCB0b2tlbnMuRG9jdW1lbnRFbmRUb2tlbiwgdG9rZW5zLlN0cmVhbUVuZFRva2VuKSkge1xuICAgICAgICBldmVudCA9IHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodGhpcy5wZWVrX3Rva2VuKCkuc3RhcnRfbWFyayk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfbm9kZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhhbmRsZSwgbWFqb3IsIG1pbm9yLCBwcmVmaXgsIHRhZ19oYW5kbGVzX2NvcHksIHRva2VuLCB2YWx1ZSwgX3JlZjEsIF9yZWYyLCBfcmVmMztcbiAgICAgIHRoaXMueWFtbF92ZXJzaW9uID0gbnVsbDtcbiAgICAgIHRoaXMudGFnX2hhbmRsZXMgPSB7fTtcbiAgICAgIHdoaWxlICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5EaXJlY3RpdmVUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ1lBTUwnKSB7XG4gICAgICAgICAgaWYgKHRoaXMueWFtbF92ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihudWxsLCBudWxsLCAnZm91bmQgZHVwbGljYXRlIFlBTUwgZGlyZWN0aXZlJywgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZWYxID0gdG9rZW4udmFsdWUsIG1ham9yID0gX3JlZjFbMF0sIG1pbm9yID0gX3JlZjFbMV07XG4gICAgICAgICAgaWYgKG1ham9yICE9PSAxIHx8IG1pbm9yICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihudWxsLCBudWxsLCAnZm91bmQgaW5jb21wYXRpYmxlIFlBTUwgZG9jdW1lbnQgKHZlcnNpb24gMS4yIGlzIHJlcXVpcmVkKScsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnlhbWxfdmVyc2lvbiA9IHRva2VuLnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuLm5hbWUgPT09ICdUQUcnKSB7XG4gICAgICAgICAgX3JlZjIgPSB0b2tlbi52YWx1ZSwgaGFuZGxlID0gX3JlZjJbMF0sIHByZWZpeCA9IF9yZWYyWzFdO1xuICAgICAgICAgIGlmIChoYW5kbGUgaW4gdGhpcy50YWdfaGFuZGxlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IobnVsbCwgbnVsbCwgXCJkdXBsaWNhdGUgdGFnIGhhbmRsZSBcIiArIGhhbmRsZSwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGFnX2hhbmRsZXNbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFnX2hhbmRsZXNfY29weSA9IG51bGw7XG4gICAgICBfcmVmMyA9IHRoaXMudGFnX2hhbmRsZXM7XG4gICAgICBmb3IgKGhhbmRsZSBpbiBfcmVmMykge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKF9yZWYzLCBoYW5kbGUpKSBjb250aW51ZTtcbiAgICAgICAgcHJlZml4ID0gX3JlZjNbaGFuZGxlXTtcbiAgICAgICAgaWYgKHRhZ19oYW5kbGVzX2NvcHkgPT0gbnVsbCkge1xuICAgICAgICAgIHRhZ19oYW5kbGVzX2NvcHkgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0YWdfaGFuZGxlc19jb3B5W2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IFt0aGlzLnlhbWxfdmVyc2lvbiwgdGFnX2hhbmRsZXNfY29weV07XG4gICAgICBmb3IgKGhhbmRsZSBpbiBERUZBVUxUX1RBR1MpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChERUZBVUxUX1RBR1MsIGhhbmRsZSkpIGNvbnRpbnVlO1xuICAgICAgICBwcmVmaXggPSBERUZBVUxUX1RBR1NbaGFuZGxlXTtcbiAgICAgICAgaWYgKCEocHJlZml4IGluIHRoaXMudGFnX2hhbmRsZXMpKSB7XG4gICAgICAgICAgdGhpcy50YWdfaGFuZGxlc1toYW5kbGVdID0gcHJlZml4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfYmxvY2tfbm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2Vfbm9kZSh0cnVlKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X25vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlX25vZGUoKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ibG9ja19ub2RlX29yX2luZGVudGxlc3Nfc2VxdWVuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlX25vZGUodHJ1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2Vfbm9kZSA9IGZ1bmN0aW9uKGJsb2NrLCBpbmRlbnRsZXNzX3NlcXVlbmNlKSB7XG4gICAgICB2YXIgYW5jaG9yLCBlbmRfbWFyaywgZXZlbnQsIGhhbmRsZSwgaW1wbGljaXQsIG5vZGUsIHN0YXJ0X21hcmssIHN1ZmZpeCwgdGFnLCB0YWdfbWFyaywgdG9rZW47XG4gICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICBibG9jayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGluZGVudGxlc3Nfc2VxdWVuY2UgPT0gbnVsbCkge1xuICAgICAgICBpbmRlbnRsZXNzX3NlcXVlbmNlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuQWxpYXNUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBldmVudCA9IG5ldyBldmVudHMuQWxpYXNFdmVudCh0b2tlbi52YWx1ZSwgdG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IgPSBudWxsO1xuICAgICAgICB0YWcgPSBudWxsO1xuICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0YWdfbWFyayA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5BbmNob3JUb2tlbikpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgc3RhcnRfbWFyayA9IHRva2VuLnN0YXJ0X21hcms7XG4gICAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgICBhbmNob3IgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuVGFnVG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgICB0YWdfbWFyayA9IHRva2VuLnN0YXJ0X21hcms7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgICAgdGFnID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlRhZ1Rva2VuKSkge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICBzdGFydF9tYXJrID0gdGFnX21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgICAgdGFnID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkFuY2hvclRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgICAgIGFuY2hvciA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnICE9PSBudWxsKSB7XG4gICAgICAgICAgaGFuZGxlID0gdGFnWzBdLCBzdWZmaXggPSB0YWdbMV07XG4gICAgICAgICAgaWYgKGhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCEoaGFuZGxlIGluIHRoaXMudGFnX2hhbmRsZXMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKCd3aGlsZSBwYXJzaW5nIGEgbm9kZScsIHN0YXJ0X21hcmssIFwiZm91bmQgdW5kZWZpbmVkIHRhZyBoYW5kbGUgXCIgKyBoYW5kbGUsIHRhZ19tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhZyA9IHRoaXMudGFnX2hhbmRsZXNbaGFuZGxlXSArIHN1ZmZpeDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFnID0gc3VmZml4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRfbWFyayA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0YXJ0X21hcmsgPSBlbmRfbWFyayA9IHRoaXMucGVla190b2tlbigpLnN0YXJ0X21hcms7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQgPSBudWxsO1xuICAgICAgICBpbXBsaWNpdCA9IHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09ICchJztcbiAgICAgICAgaWYgKGluZGVudGxlc3Nfc2VxdWVuY2UgJiYgdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuKSkge1xuICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuZW5kX21hcms7XG4gICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlU3RhcnRFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2luZGVudGxlc3Nfc2VxdWVuY2VfZW50cnknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5TY2FsYXJUb2tlbikpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgICAgICBpZiAoKHRva2VuLnBsYWluICYmIHRhZyA9PT0gbnVsbCkgfHwgdGFnID09PSAnIScpIHtcbiAgICAgICAgICAgICAgaW1wbGljaXQgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaW1wbGljaXQgPSBbZmFsc2UsIHRydWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW1wbGljaXQgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TY2FsYXJFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHRva2VuLnZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgdG9rZW4uc3R5bGUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd1NlcXVlbmNlU3RhcnRUb2tlbikpIHtcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuZW5kX21hcms7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuU2VxdWVuY2VTdGFydEV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgc3RhcnRfbWFyaywgZW5kX21hcmssIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X3NlcXVlbmNlX2ZpcnN0X2VudHJ5JztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dNYXBwaW5nU3RhcnRUb2tlbikpIHtcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuZW5kX21hcms7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuTWFwcGluZ1N0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfbWFwcGluZ19maXJzdF9rZXknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sgJiYgdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW4pKSB7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRoaXMucGVla190b2tlbigpLmVuZF9tYXJrO1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlU3RhcnRFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX3NlcXVlbmNlX2ZpcnN0X2VudHJ5JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrICYmIHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4pKSB7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRoaXMucGVla190b2tlbigpLmVuZF9tYXJrO1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLk1hcHBpbmdTdGFydEV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgc3RhcnRfbWFyaywgZW5kX21hcmssIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfbWFwcGluZ19maXJzdF9rZXknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yICE9PSBudWxsIHx8IHRhZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNjYWxhckV2ZW50KGFuY2hvciwgdGFnLCBbaW1wbGljaXQsIGZhbHNlXSwgJycsIHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSAnYmxvY2snO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZSA9ICdmbG93JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihcIndoaWxlIHBhcnNpbmcgYSBcIiArIG5vZGUgKyBcIiBub2RlXCIsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgdGhlIG5vZGUgY29udGVudCwgYnV0IGZvdW5kIFwiICsgdG9rZW4uaWQsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Jsb2NrX3NlcXVlbmNlX2ZpcnN0X2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICB0aGlzLm1hcmtzLnB1c2godG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19zZXF1ZW5jZV9lbnRyeSgpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Jsb2NrX3NlcXVlbmNlX2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW50cnlUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW50cnlUb2tlbiwgdG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfYmxvY2tfc2VxdWVuY2VfZW50cnknKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19zZXF1ZW5jZV9lbnRyeSc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKCd3aGlsZSBwYXJzaW5nIGEgYmxvY2sgY29sbGVjdGlvbicsIHRoaXMubWFya3Muc2xpY2UoLTEpWzBdLCBcImV4cGVjdGVkIDxibG9jayBlbmQ+LCBidXQgZm91bmQgXCIgKyB0b2tlbi5pZCwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICBldmVudCA9IG5ldyBldmVudHMuU2VxdWVuY2VFbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICB0aGlzLm1hcmtzLnBvcCgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2luZGVudGxlc3Nfc2VxdWVuY2VfZW50cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBldmVudCwgdG9rZW47XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuLCB0b2tlbnMuS2V5VG9rZW4sIHRva2Vucy5WYWx1ZVRva2VuLCB0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9pbmRlbnRsZXNzX3NlcXVlbmNlX2VudHJ5Jyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfbm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfaW5kZW50bGVzc19zZXF1ZW5jZV9lbnRyeSc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNlcXVlbmNlRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfYmxvY2tfbWFwcGluZ19maXJzdF9rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIHRoaXMubWFya3MucHVzaCh0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX21hcHBpbmdfa2V5KCk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfYmxvY2tfbWFwcGluZ19rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBldmVudCwgdG9rZW47XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuS2V5VG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5LZXlUb2tlbiwgdG9rZW5zLlZhbHVlVG9rZW4sIHRva2Vucy5CbG9ja0VuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Jsb2NrX21hcHBpbmdfdmFsdWUnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlX29yX2luZGVudGxlc3Nfc2VxdWVuY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX21hcHBpbmdfdmFsdWUnO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VuZFRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIGJsb2NrIG1hcHBpbmcnLCB0aGlzLm1hcmtzLnNsaWNlKC0xKVswXSwgXCJleHBlY3RlZCA8YmxvY2sgZW5kPiwgYnV0IGZvdW5kIFwiICsgdG9rZW4uaWQsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLk1hcHBpbmdFbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICB0aGlzLm1hcmtzLnBvcCgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Jsb2NrX21hcHBpbmdfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5WYWx1ZVRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuS2V5VG9rZW4sIHRva2Vucy5WYWx1ZVRva2VuLCB0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9ibG9ja19tYXBwaW5nX2tleScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX25vZGVfb3JfaW5kZW50bGVzc19zZXF1ZW5jZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfbWFwcGluZ19rZXknO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19tYXBwaW5nX2tleSc7XG4gICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfc2VxdWVuY2VfZmlyc3RfZW50cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIHRoaXMubWFya3MucHVzaCh0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnkodHJ1ZSk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeSA9IGZ1bmN0aW9uKGZpcnN0KSB7XG4gICAgICB2YXIgZXZlbnQsIHRva2VuO1xuICAgICAgaWYgKGZpcnN0ID09IG51bGwpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd1NlcXVlbmNlRW5kVG9rZW4pKSB7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd0VudHJ5VG9rZW4pKSB7XG4gICAgICAgICAgICB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoJ3doaWxlIHBhcnNpbmcgYSBmbG93IHNlcXVlbmNlJywgdGhpcy5tYXJrcy5zbGljZSgtMSlbMF0sIFwiZXhwZWN0ZWQgJywnIG9yICddJywgYnV0IGdvdCBcIiArIHRva2VuLmlkLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLktleVRva2VuKSkge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLk1hcHBpbmdTdGFydEV2ZW50KG51bGwsIG51bGwsIHRydWUsIHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19rZXknO1xuICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd1NlcXVlbmNlRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICBldmVudCA9IG5ldyBldmVudHMuU2VxdWVuY2VFbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICB0aGlzLm1hcmtzLnBvcCgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkZsb3dFbnRyeVRva2VuLCB0b2tlbnMuRmxvd1NlcXVlbmNlRW5kVG9rZW4pKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ192YWx1ZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X25vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX3ZhbHVlJztcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ192YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlZhbHVlVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93RW50cnlUb2tlbiwgdG9rZW5zLkZsb3dTZXF1ZW5jZUVuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19lbmQnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X25vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19lbmQnO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfZW5kJztcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5JztcbiAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICByZXR1cm4gbmV3IGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19tYXBwaW5nX2ZpcnN0X2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgdGhpcy5tYXJrcy5wdXNoKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19tYXBwaW5nX2tleSh0cnVlKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X21hcHBpbmdfa2V5ID0gZnVuY3Rpb24oZmlyc3QpIHtcbiAgICAgIHZhciBldmVudCwgdG9rZW47XG4gICAgICBpZiAoZmlyc3QgPT0gbnVsbCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKSkge1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dFbnRyeVRva2VuKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKCd3aGlsZSBwYXJzaW5nIGEgZmxvdyBtYXBwaW5nJywgdGhpcy5tYXJrcy5zbGljZSgtMSlbMF0sIFwiZXhwZWN0ZWQgJywnIG9yICd9JywgYnV0IGdvdCBcIiArIHRva2VuLmlkLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLktleVRva2VuKSkge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlZhbHVlVG9rZW4sIHRva2Vucy5GbG93RW50cnlUb2tlbiwgdG9rZW5zLkZsb3dNYXBwaW5nRW5kVG9rZW4pKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9mbG93X21hcHBpbmdfdmFsdWUnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfbWFwcGluZ192YWx1ZSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfbWFwcGluZ19lbXB0eV92YWx1ZScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICBldmVudCA9IG5ldyBldmVudHMuTWFwcGluZ0VuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgIHRoaXMubWFya3MucG9wKCk7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19tYXBwaW5nX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dFbnRyeVRva2VuLCB0b2tlbnMuRmxvd01hcHBpbmdFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9mbG93X21hcHBpbmdfa2V5Jyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X21hcHBpbmdfa2V5JztcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX2tleSc7XG4gICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfbWFwcGluZ19lbXB0eV92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X21hcHBpbmdfa2V5JztcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRoaXMucGVla190b2tlbigpLnN0YXJ0X21hcmspO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NfZW1wdHlfc2NhbGFyID0gZnVuY3Rpb24obWFyaykge1xuICAgICAgcmV0dXJuIG5ldyBldmVudHMuU2NhbGFyRXZlbnQobnVsbCwgbnVsbCwgW3RydWUsIGZhbHNlXSwgJycsIG1hcmssIG1hcmspO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGFyc2VyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIG5vZGVzLCB1cmwsIHV0aWwsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLypcbiAgVGhlIFByb3RvY29scyBjbGFzcyBkZWFscyB3aXRoIGFwcGx5aW5nIHByb3RvY29scyB0byBtZXRob2RzIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAqL1xuXG5cbiAgdGhpcy5Qcm90b2NvbHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJvdG9jb2xzKCkge1xuICAgICAgdGhpcy5hcHBseV9wcm90b2NvbHMgPSBfX2JpbmQodGhpcy5hcHBseV9wcm90b2NvbHMsIHRoaXMpO1xuICAgIH1cblxuICAgIFByb3RvY29scy5wcm90b3R5cGUuYXBwbHlfcHJvdG9jb2xzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByb3RvY29scztcbiAgICAgIGlmIChwcm90b2NvbHMgPSB0aGlzLmFwcGx5X3Byb3RvY29sc190b19yb290KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5X3Byb3RvY29sc190b19yZXNvdXJjZXMobm9kZSwgcHJvdG9jb2xzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUHJvdG9jb2xzLnByb3RvdHlwZS5hcHBseV9wcm90b2NvbHNfdG9fcm9vdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBiYXNlVXJpLCBwYXJzZWRCYXNlVXJpLCBwcm90b2NvbCwgcHJvdG9jb2xzO1xuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsICdwcm90b2NvbHMnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfcHJvcGVydHkobm9kZSwgJ3Byb3RvY29scycpO1xuICAgICAgfVxuICAgICAgaWYgKCEoYmFzZVVyaSA9IHRoaXMucHJvcGVydHlfdmFsdWUobm9kZSwgJ2Jhc2VVcmknKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyc2VkQmFzZVVyaSA9IHVybC5wYXJzZShiYXNlVXJpKTtcbiAgICAgIHByb3RvY29sID0gKHBhcnNlZEJhc2VVcmkucHJvdG9jb2wgfHwgJ2h0dHA6Jykuc2xpY2UoMCwgLTEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBwcm90b2NvbHMgPSBbbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsICdwcm90b2NvbHMnLCBub2RlLnN0YXJ0X21hcmssIG5vZGUuZW5kX21hcmspLCBuZXcgbm9kZXMuU2VxdWVuY2VOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCBbbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHByb3RvY29sLCBub2RlLnN0YXJ0X21hcmssIG5vZGUuZW5kX21hcmspXSwgbm9kZS5zdGFydF9tYXJrLCBub2RlLmVuZF9tYXJrKV07XG4gICAgICBub2RlLnZhbHVlLnB1c2gocHJvdG9jb2xzKTtcbiAgICAgIHJldHVybiBwcm90b2NvbHNbMV07XG4gICAgfTtcblxuICAgIFByb3RvY29scy5wcm90b3R5cGUuYXBwbHlfcHJvdG9jb2xzX3RvX3Jlc291cmNlcyA9IGZ1bmN0aW9uKG5vZGUsIHByb3RvY29scykge1xuICAgICAgdmFyIHJlc291cmNlLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmID0gdGhpcy5jaGlsZF9yZXNvdXJjZXMobm9kZSk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHJlc291cmNlID0gX3JlZltfaV07XG4gICAgICAgIHRoaXMuYXBwbHlfcHJvdG9jb2xzX3RvX3Jlc291cmNlcyhyZXNvdXJjZSwgcHJvdG9jb2xzKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmFwcGx5X3Byb3RvY29sc190b19tZXRob2RzKHJlc291cmNlLCBwcm90b2NvbHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgUHJvdG9jb2xzLnByb3RvdHlwZS5hcHBseV9wcm90b2NvbHNfdG9fbWV0aG9kcyA9IGZ1bmN0aW9uKG5vZGUsIHByb3RvY29scykge1xuICAgICAgdmFyIG1ldGhvZCwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IHRoaXMuY2hpbGRfbWV0aG9kcyhub2RlWzFdKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgbWV0aG9kID0gX3JlZltfaV07XG4gICAgICAgIGlmICghdGhpcy5oYXNfcHJvcGVydHkobWV0aG9kWzFdLCAncHJvdG9jb2xzJykpIHtcbiAgICAgICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG1ldGhvZFsxXSkpIHtcbiAgICAgICAgICAgIG1ldGhvZFsxXSA9IG5ldyBub2Rlcy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIG1ldGhvZFsxXS5zdGFydF9tYXJrLCBtZXRob2RbMV0uZW5kX21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG1ldGhvZFsxXS52YWx1ZS5wdXNoKFtuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgJ3Byb3RvY29scycsIG1ldGhvZFswXS5zdGFydF9tYXJrLCBtZXRob2RbMF0uZW5kX21hcmspLCBwcm90b2NvbHMuY2xvbmUoKV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3RvY29scztcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgZGVmYXVsdFNldHRpbmdzLCB1dGlsLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIHRoaXMuZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuICB0aGlzLmxvYWRlciA9IHJlcXVpcmUoJy4vbG9hZGVyJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIHRoaXMuRmlsZUVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWxlRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBGaWxlRXJyb3IoKSB7XG4gICAgICBfcmVmID0gRmlsZUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZpbGVFcnJvcjtcblxuICB9KSh0aGlzLmVycm9ycy5NYXJrZWRZQU1MRXJyb3IpO1xuXG4gIHRoaXMuRmlsZVJlYWRlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBGaWxlUmVhZGVyKHJlYWRGaWxlQXN5bmNPdmVycmlkZSkge1xuICAgICAgdGhpcy5xID0gcmVxdWlyZSgncScpO1xuICAgICAgdGhpcy51cmwgPSByZXF1aXJlKCd1cmwnKTtcbiAgICAgIGlmIChyZWFkRmlsZUFzeW5jT3ZlcnJpZGUpIHtcbiAgICAgICAgdGhpcy5yZWFkRmlsZUFzeW5jT3ZlcnJpZGUgPSByZWFkRmlsZUFzeW5jT3ZlcnJpZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICBSZWFkIGZpbGUgZWl0aGVyIGxvY2FsbHkgb3IgZnJvbSB0aGUgbmV0d29yay5cbiAgICAqL1xuXG5cbiAgICBGaWxlUmVhZGVyLnByb3RvdHlwZS5yZWFkRmlsZUFzeW5jID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgdmFyIHRhcmdlclVybDtcbiAgICAgIGlmICh0aGlzLnJlYWRGaWxlQXN5bmNPdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmlsZUFzeW5jT3ZlcnJpZGUoZmlsZSk7XG4gICAgICB9XG4gICAgICB0YXJnZXJVcmwgPSB0aGlzLnVybC5wYXJzZShmaWxlKTtcbiAgICAgIGlmICh0YXJnZXJVcmwucHJvdG9jb2wgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIXRhcmdlclVybC5wcm90b2NvbC5tYXRjaCgvXmh0dHBzPy9pKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkZpbGVFcnJvcihcIndoaWxlIHJlYWRpbmcgXCIgKyBmaWxlLCBudWxsLCBcInVua25vd24gcHJvdG9jb2wgXCIgKyB0YXJnZXJVcmwucHJvdG9jb2wsIHRoaXMuc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hGaWxlQXN5bmMoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoRmlsZUFzeW5jKGZpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoTG9jYWxGaWxlQXN5bmMoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBSZWFkIGZpbGUgZnJvbSB0aGUgZGlzay5cbiAgICAqL1xuXG5cbiAgICBGaWxlUmVhZGVyLnByb3RvdHlwZS5mZXRjaExvY2FsRmlsZUFzeW5jID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgdmFyIGRlZmVycmVkLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBkZWZlcnJlZCA9IHRoaXMucS5kZWZlcigpO1xuICAgICAgcmVxdWlyZSgnZnMnKS5yZWFkRmlsZShmaWxlLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QobmV3IGV4cG9ydHMuRmlsZUVycm9yKFwid2hpbGUgcmVhZGluZyBcIiArIGZpbGUsIG51bGwsIFwiY2Fubm90IHJlYWQgXCIgKyBmaWxlICsgXCIgKFwiICsgZXJyICsgXCIpXCIsIF90aGlzLnN0YXJ0X21hcmspKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZShkYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJlYWQgZmlsZSBmcm9tIHRoZSBuZXR3b3JrLlxuICAgICovXG5cblxuICAgIEZpbGVSZWFkZXIucHJvdG90eXBlLmZldGNoRmlsZUFzeW5jID0gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgdmFyIGRlZmVycmVkLCBlcnJvciwgeGhyLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBkZWZlcnJlZCA9IHRoaXMucS5kZWZlcigpO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeGhyID0gbmV3IChyZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpLlhNTEh0dHBSZXF1ZXN0KSgpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGZpbGUsIGZhbHNlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9yYW1sK3lhbWwsICovKicpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiB4aHIuc3RhdHVzID09PSAnbnVtYmVyJyAmJiB4aHIuc3RhdHVzID09PSAyMDApIHx8ICh0eXBlb2YgeGhyLnN0YXR1cyA9PT0gJ3N0cmluZycgJiYgeGhyLnN0YXR1cy5tYXRjaCgvXjIwMC9pKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KG5ldyBleHBvcnRzLkZpbGVFcnJvcihcIndoaWxlIGZldGNoaW5nIFwiICsgZmlsZSwgbnVsbCwgXCJjYW5ub3QgZmV0Y2ggXCIgKyBmaWxlICsgXCIgKFwiICsgeGhyLnN0YXR1c1RleHQgKyBcIilcIiwgX3RoaXMuc3RhcnRfbWFyaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5GaWxlRXJyb3IoXCJ3aGlsZSBmZXRjaGluZyBcIiArIGZpbGUsIG51bGwsIFwiY2Fubm90IGZldGNoIFwiICsgZmlsZSArIFwiIChcIiArIGVycm9yICsgXCIpLCBjaGVjayB0aGF0IHRoZSBzZXJ2ZXIgaXMgdXAgYW5kIHRoYXQgQ09SUyBpcyBlbmFibGVkXCIsIHRoaXMuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBGaWxlUmVhZGVyO1xuXG4gIH0pKCk7XG5cbiAgLypcbiAgT08gdmVyc2lvbiBvZiB0aGUgcGFyc2VyLCBzdGF0aWMgZnVuY3Rpb25zIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjb25zdW1lcnMgbW92ZSBvbiB0byB1c2UgdGhlIE9PIHZlcnNpb25cbiAgT08gd2lsbCBvZmZlciBjYWNoaW5nXG4gICovXG5cblxuICB0aGlzLlJhbWxQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUmFtbFBhcnNlcihzZXR0aW5ncykge1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzICE9IG51bGwgPyBzZXR0aW5ncyA6IGRlZmF1bHRTZXR0aW5ncztcbiAgICAgIHRoaXMucSA9IHJlcXVpcmUoJ3EnKTtcbiAgICAgIHRoaXMudXJsID0gcmVxdWlyZSgndXJsJyk7XG4gICAgICB0aGlzLm5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuICAgICAgdGhpcy5sb2FkRGVmYXVsdFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5sb2FkRGVmYXVsdFNldHRpbmdzID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGVmYXVsdFNldHRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uKHNldHRpbmdOYW1lKSB7XG4gICAgICAgIGlmICghKHNldHRpbmdOYW1lIGluIHNldHRpbmdzKSkge1xuICAgICAgICAgIHJldHVybiBzZXR0aW5nc1tzZXR0aW5nTmFtZV0gPSBkZWZhdWx0U2V0dGluZ3Nbc2V0dGluZ05hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUubG9hZEZpbGUgPSBmdW5jdGlvbihmaWxlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIGVycm9yLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MucmVhZGVyLnJlYWRGaWxlQXN5bmMoZmlsZSkudGhlbihmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMubG9hZChzdHJlYW0sIGZpbGUsIHNldHRpbmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLnEuZmNhbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuRmlsZUVycm9yKFwid2hpbGUgZmV0Y2hpbmcgXCIgKyBmaWxlLCBudWxsLCBcImNhbm5vdCBmZXRjaCBcIiArIGZpbGUgKyBcIiAoXCIgKyBlcnJvciArIFwiKVwiLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmNvbXBvc2VGaWxlID0gZnVuY3Rpb24oZmlsZSwgc2V0dGluZ3MsIHBhcmVudCkge1xuICAgICAgdmFyIGVycm9yLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MucmVhZGVyLnJlYWRGaWxlQXN5bmMoZmlsZSkudGhlbihmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY29tcG9zZShzdHJlYW0sIGZpbGUsIHNldHRpbmdzLCBwYXJlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMucS5mY2FsbChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5GaWxlRXJyb3IoXCJ3aGlsZSBmZXRjaGluZyBcIiArIGZpbGUsIG51bGwsIFwiY2Fubm90IGZldGNoIFwiICsgZmlsZSArIFwiIChcIiArIGVycm9yICsgXCIpXCIsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUuY29tcG9zZSA9IGZ1bmN0aW9uKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBwYXJlbnQpIHtcbiAgICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQgPSB7XG4gICAgICAgICAgc3JjOiBsb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2V0dGluZ3MuY29tcG9zZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdHJlYW0oc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHBhcmVudCk7XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncykge1xuICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgfVxuICAgICAgc2V0dGluZ3MuY29tcG9zZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmVhbShzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywge1xuICAgICAgICBzcmM6IGxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgcGFyZW50KSB7XG4gICAgICB2YXIgbG9hZGVyLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB9XG4gICAgICBsb2FkZXIgPSBuZXcgZXhwb3J0cy5sb2FkZXIuTG9hZGVyKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucS5mY2FsbChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlci5nZXRZYW1sUm9vdCgpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbihwYXJ0aWFsVHJlZSkge1xuICAgICAgICB2YXIgZmlsZXM7XG4gICAgICAgIGZpbGVzID0gbG9hZGVyLmdldFBlbmRpbmdGaWxlc0xpc3QoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFBlbmRpbmdGaWxlcyhsb2FkZXIsIHBhcnRpYWxUcmVlLCBmaWxlcyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKGZ1bGx5QXNzZW1ibGVkVHJlZSkge1xuICAgICAgICBsb2FkZXIuY29tcG9zZVJhbWxUcmVlKGZ1bGx5QXNzZW1ibGVkVHJlZSwgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuY29tcG9zZSkge1xuICAgICAgICAgIGlmIChmdWxseUFzc2VtYmxlZFRyZWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlci5jb25zdHJ1Y3RfZG9jdW1lbnQoZnVsbHlBc3NlbWJsZWRUcmVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmdWxseUFzc2VtYmxlZFRyZWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5nZXRQZW5kaW5nRmlsZXMgPSBmdW5jdGlvbihsb2FkZXIsIG5vZGUsIGZpbGVzKSB7XG4gICAgICB2YXIgZmlsZSwgbGFzdFZpc2l0ZWROb2RlLCBsb2MsIF9pLCBfbGVuLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBsb2MgPSBbXTtcbiAgICAgIGxhc3RWaXNpdGVkTm9kZSA9IHZvaWQgMDtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZmlsZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZmlsZSA9IGZpbGVzW19pXTtcbiAgICAgICAgbG9jLnB1c2godGhpcy5nZXRQZW5kaW5nRmlsZShsb2FkZXIsIGZpbGUpLnRoZW4oZnVuY3Rpb24ob3ZlcndyaXRpbmdub2RlKSB7XG4gICAgICAgICAgaWYgKG92ZXJ3cml0aW5nbm9kZSAmJiAhbGFzdFZpc2l0ZWROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZpc2l0ZWROb2RlID0gb3ZlcndyaXRpbmdub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucS5hbGwobG9jKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGFzdFZpc2l0ZWROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGxhc3RWaXNpdGVkTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmdldFBlbmRpbmdGaWxlID0gZnVuY3Rpb24obG9hZGVyLCBmaWxlSW5mbykge1xuICAgICAgdmFyIGVycm9yLCBldmVudCwgZmlsZVVyaSwga2V5LCBub2RlLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBub2RlID0gZmlsZUluZm8ucGFyZW50Tm9kZTtcbiAgICAgIGV2ZW50ID0gZmlsZUluZm8uZXZlbnQ7XG4gICAgICBrZXkgPSBmaWxlSW5mby5wYXJlbnRLZXk7XG4gICAgICBmaWxlVXJpID0gZmlsZUluZm8udGFyZ2V0RmlsZVVyaTtcbiAgICAgIGlmIChmaWxlSW5mby5pbmNsdWRpbmdDb250ZXh0KSB7XG4gICAgICAgIGZpbGVVcmkgPSB0aGlzLnVybC5yZXNvbHZlKGZpbGVJbmZvLmluY2x1ZGluZ0NvbnRleHQsIGZpbGVJbmZvLnRhcmdldEZpbGVVcmkpO1xuICAgICAgfVxuICAgICAgaWYgKGxvYWRlci5wYXJlbnQgJiYgdGhpcy5pc0luSW5jbHVkZVRhZ3NTdGFjayhmaWxlVXJpLCBsb2FkZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkZpbGVFcnJvcignd2hpbGUgY29tcG9zaW5nIHNjYWxhciBvdXQgb2YgIWluY2x1ZGUnLCBudWxsLCBcImRldGVjdGVkIGNpcmN1bGFyICFpbmNsdWRlIG9mIFwiICsgZXZlbnQudmFsdWUsIGV2ZW50LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGZpbGVJbmZvLnR5cGUgPT09ICdmcmFnbWVudCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZWFkZXIucmVhZEZpbGVBc3luYyhmaWxlVXJpKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbXBvc2UocmVzdWx0LCBmaWxlVXJpLCB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29tcG9zZTogdHJ1ZVxuICAgICAgICAgICAgfSwgbG9hZGVyKTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwZW5kTmV3Tm9kZVRvUGFyZW50KG5vZGUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hZGRDb250ZXh0VG9FcnJvcihlcnJvciwgZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnJlYWRlci5yZWFkRmlsZUFzeW5jKGZpbGVVcmkpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBfdGhpcy5ub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCByZXN1bHQsIGV2ZW50LnN0YXJ0X21hcmssIGV2ZW50LmVuZF9tYXJrLCBldmVudC5zdHlsZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwZW5kTmV3Tm9kZVRvUGFyZW50KG5vZGUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hZGRDb250ZXh0VG9FcnJvcihlcnJvciwgZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENvbnRleHRUb0Vycm9yKGVycm9yLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmFkZENvbnRleHRUb0Vycm9yID0gZnVuY3Rpb24oZXJyb3IsIGV2ZW50KSB7XG4gICAgICBpZiAoZXJyb3IuY29uc3RydWN0b3IubmFtZSA9PT0gXCJGaWxlRXJyb3JcIikge1xuICAgICAgICBpZiAoIWVycm9yLnByb2JsZW1fbWFyaykge1xuICAgICAgICAgIGVycm9yLnByb2JsZW1fbWFyayA9IGV2ZW50LnN0YXJ0X21hcms7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5GaWxlRXJyb3IoJ3doaWxlIHJlYWRpbmcgZmlsZScsIG51bGwsIFwiZXJyb3I6IFwiICsgZXJyb3IsIGV2ZW50LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5pc0luSW5jbHVkZVRhZ3NTdGFjayA9IGZ1bmN0aW9uKGluY2x1ZGUsIHBhcmVudCkge1xuICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5zcmMgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5hcHBlbmROZXdOb2RlVG9QYXJlbnQgPSBmdW5jdGlvbihub2RlLCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAodXRpbC5pc1NlcXVlbmNlKG5vZGUpKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS52YWx1ZS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBSYW1sUGFyc2VyO1xuXG4gIH0pKCk7XG5cbiAgLypcbiAgICB2YWxpZGF0ZSBjb250cm9scyB3aGV0aGVyIHRoZSBzdHJlYW0gbXVzdCBiZSBwcm9jZXNzZWQgYXMgYVxuICAqL1xuXG5cbiAgZGVmYXVsdFNldHRpbmdzID0ge1xuICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgIHRyYW5zZm9ybTogdHJ1ZSxcbiAgICBjb21wb3NlOiB0cnVlLFxuICAgIHJlYWRlcjogbmV3IGV4cG9ydHMuRmlsZVJlYWRlcihudWxsKVxuICB9O1xuXG4gIC8qXG4gIFBhcnNlIHRoZSBmaXJzdCBSQU1MIGRvY3VtZW50IGluIGEgc3RyZWFtIGFuZCBwcm9kdWNlIHRoZSBjb3JyZXNwb25kaW5nXG4gIEphdmFzY3JpcHQgb2JqZWN0LlxuICAqL1xuXG5cbiAgdGhpcy5sb2FkRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIHNldHRpbmdzKSB7XG4gICAgdmFyIHBhcnNlcjtcbiAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgc2V0dGluZ3MgPSBkZWZhdWx0U2V0dGluZ3M7XG4gICAgfVxuICAgIHBhcnNlciA9IG5ldyBleHBvcnRzLlJhbWxQYXJzZXIoc2V0dGluZ3MpO1xuICAgIHJldHVybiBwYXJzZXIubG9hZEZpbGUoZmlsZSwgc2V0dGluZ3MpO1xuICB9O1xuXG4gIC8qXG4gIFBhcnNlIHRoZSBmaXJzdCBSQU1MIGRvY3VtZW50IGluIGEgZmlsZSBhbmQgcHJvZHVjZSB0aGUgY29ycmVzcG9uZGluZ1xuICByZXByZXNlbnRhdGlvbiB0cmVlLlxuICAqL1xuXG5cbiAgdGhpcy5jb21wb3NlRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIHNldHRpbmdzLCBwYXJlbnQpIHtcbiAgICB2YXIgcGFyc2VyO1xuICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICBzZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncztcbiAgICB9XG4gICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICBwYXJlbnQgPSBmaWxlO1xuICAgIH1cbiAgICBwYXJzZXIgPSBuZXcgZXhwb3J0cy5SYW1sUGFyc2VyKHNldHRpbmdzKTtcbiAgICByZXR1cm4gcGFyc2VyLmNvbXBvc2VGaWxlKGZpbGUsIHNldHRpbmdzLCBwYXJlbnQpO1xuICB9O1xuXG4gIC8qXG4gIFBhcnNlIHRoZSBmaXJzdCBSQU1MIGRvY3VtZW50IGluIGEgc3RyZWFtIGFuZCBwcm9kdWNlIHRoZSBjb3JyZXNwb25kaW5nXG4gIHJlcHJlc2VudGF0aW9uIHRyZWUuXG4gICovXG5cblxuICB0aGlzLmNvbXBvc2UgPSBmdW5jdGlvbihzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgcGFyZW50KSB7XG4gICAgdmFyIHBhcnNlcjtcbiAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgc2V0dGluZ3MgPSBkZWZhdWx0U2V0dGluZ3M7XG4gICAgfVxuICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgcGFyZW50ID0gbG9jYXRpb247XG4gICAgfVxuICAgIHBhcnNlciA9IG5ldyBleHBvcnRzLlJhbWxQYXJzZXIoc2V0dGluZ3MpO1xuICAgIHJldHVybiBwYXJzZXIuY29tcG9zZShzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgcGFyZW50KTtcbiAgfTtcblxuICAvKlxuICBQYXJzZSB0aGUgZmlyc3QgUkFNTCBkb2N1bWVudCBpbiBhIHN0cmVhbSBhbmQgcHJvZHVjZSB0aGUgY29ycmVzcG9uZGluZ1xuICBKYXZhc2NyaXB0IG9iamVjdC5cbiAgKi9cblxuXG4gIHRoaXMubG9hZCA9IGZ1bmN0aW9uKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzKSB7XG4gICAgdmFyIHBhcnNlcjtcbiAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgc2V0dGluZ3MgPSBkZWZhdWx0U2V0dGluZ3M7XG4gICAgfVxuICAgIHBhcnNlciA9IG5ldyBleHBvcnRzLlJhbWxQYXJzZXIoc2V0dGluZ3MpO1xuICAgIHJldHVybiBwYXJzZXIubG9hZChzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgbnVsbCk7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrLCBNYXJrZWRZQU1MRXJyb3IsIF9yZWYsIF9yZWYxLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIF9yZWYgPSByZXF1aXJlKCcuL2Vycm9ycycpLCBNYXJrID0gX3JlZi5NYXJrLCBNYXJrZWRZQU1MRXJyb3IgPSBfcmVmLk1hcmtlZFlBTUxFcnJvcjtcblxuICB0aGlzLlJlYWRlckVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkZXJFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFJlYWRlckVycm9yKCkge1xuICAgICAgX3JlZjEgPSBSZWFkZXJFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGVyRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICBSZWFkZXI6XG4gICAgY2hlY2tzIGlmIGNoYXJhY3RlcnMgYXJlIHdpdGhpbiB0aGUgYWxsb3dlZCByYW5nZVxuICAgIGFkZCAnXFx4MDAnIHRvIHRoZSBlbmRcbiAgKi9cblxuXG4gIHRoaXMuUmVhZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBOT05fUFJJTlRBQkxFO1xuXG4gICAgTk9OX1BSSU5UQUJMRSA9IC9bXlxceDA5XFx4MEFcXHgwRFxceDIwLVxceDdFXFx4ODVcXHhBMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZEXS87XG5cbiAgICBmdW5jdGlvbiBSZWFkZXIoc3RyaW5nLCBzcmMpIHtcbiAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICB0aGlzLmxpbmUgPSAwO1xuICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICB0aGlzLnN0cmluZyArPSAnXFx4MDAnO1xuICAgIH1cblxuICAgIFJlYWRlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmdbdGhpcy5pbmRleCArIGluZGV4XTtcbiAgICB9O1xuXG4gICAgUmVhZGVyLnByb3RvdHlwZS5wcmVmaXggPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBSZWFkZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIHZhciBjaGFyLCBfcmVzdWx0cztcbiAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgICAgY2hhciA9IHRoaXMuc3RyaW5nW3RoaXMuaW5kZXhdO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmIChfX2luZGV4T2YuY2FsbCgnXFxuXFx4ODVcXHUyMDgyXFx1MjAyOScsIGNoYXIpID49IDAgfHwgKGNoYXIgPT09ICdcXHInICYmIHRoaXMuc3RyaW5nW3RoaXMuaW5kZXhdICE9PSAnXFxuJykpIHtcbiAgICAgICAgICB0aGlzLmxpbmUrKztcbiAgICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGVja19wcmludGFibGUoY2hhcik7XG4gICAgICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBfcmVzdWx0cy5wdXNoKGxlbmd0aC0tKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgUmVhZGVyLnByb3RvdHlwZS5jcmVhdGVfbWFyayA9IGZ1bmN0aW9uKGxpbmUsIGNvbHVtbikge1xuICAgICAgaWYgKGxpbmUgPT0gbnVsbCkge1xuICAgICAgICBsaW5lID0gdGhpcy5saW5lO1xuICAgICAgfVxuICAgICAgaWYgKGNvbHVtbiA9PSBudWxsKSB7XG4gICAgICAgIGNvbHVtbiA9IHRoaXMuY29sdW1uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMuc3JjLCBsaW5lLCBjb2x1bW4sIHRoaXMuc3RyaW5nLCB0aGlzLmluZGV4KTtcbiAgICB9O1xuXG4gICAgUmVhZGVyLnByb3RvdHlwZS5nZXRfbWFyayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlX21hcmsoKTtcbiAgICB9O1xuXG4gICAgUmVhZGVyLnByb3RvdHlwZS5jaGVja19wcmludGFibGUgPSBmdW5jdGlvbihjaGFyKSB7XG4gICAgICBpZiAoTk9OX1BSSU5UQUJMRS5leGVjKGNoYXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlJlYWRlckVycm9yKCd3aGlsZSByZWFkaW5nIGZpbGUnLCBudWxsLCBcIm5vbiBwcmludGFibGUgY2hhcmFjdGVycyBhcmUgbm90IGFsbG93ZWQgY29sdW1uOiBcIiArICh0aGlzLmdldF9tYXJrKCkuY29sdW1uKSwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlYWRlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgWUFNTEVycm9yLCBub2RlcywgdXRpbCwgX3JlZiwgX3JlZjEsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuWUFNTEVycm9yO1xuXG4gIHRoaXMuUmVzb2x2ZXJFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzb2x2ZXJFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFJlc29sdmVyRXJyb3IoKSB7XG4gICAgICBfcmVmID0gUmVzb2x2ZXJFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBSZXNvbHZlckVycm9yO1xuXG4gIH0pKFlBTUxFcnJvcik7XG5cbiAgdGhpcy5CYXNlUmVzb2x2ZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIERFRkFVTFRfTUFQUElOR19UQUcsIERFRkFVTFRfU0NBTEFSX1RBRywgREVGQVVMVF9TRVFVRU5DRV9UQUc7XG5cbiAgICBERUZBVUxUX1NDQUxBUl9UQUcgPSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJztcblxuICAgIERFRkFVTFRfU0VRVUVOQ0VfVEFHID0gJ3RhZzp5YW1sLm9yZywyMDAyOnNlcSc7XG5cbiAgICBERUZBVUxUX01BUFBJTkdfVEFHID0gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCc7XG5cbiAgICBCYXNlUmVzb2x2ZXIucHJvdG90eXBlLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzID0ge307XG5cbiAgICBCYXNlUmVzb2x2ZXIucHJvdG90eXBlLnlhbWxfcGF0aF9yZXNvbHZlcnMgPSB7fTtcblxuICAgIEJhc2VSZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIgPSBmdW5jdGlvbih0YWcsIHJlZ2V4cCwgZmlyc3QpIHtcbiAgICAgIHZhciBjaGFyLCBfYmFzZSwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgaWYgKGZpcnN0ID09IG51bGwpIHtcbiAgICAgICAgZmlyc3QgPSBbbnVsbF07XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KCd5YW1sX2ltcGxpY2l0X3Jlc29sdmVycycpKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzID0gdXRpbC5leHRlbmQoe30sIHRoaXMucHJvdG90eXBlLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGZpcnN0Lmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNoYXIgPSBmaXJzdFtfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2goKChfYmFzZSA9IHRoaXMucHJvdG90eXBlLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzKVtjaGFyXSAhPSBudWxsID8gKF9iYXNlID0gdGhpcy5wcm90b3R5cGUueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMpW2NoYXJdIDogX2Jhc2VbY2hhcl0gPSBbXSkucHVzaChbdGFnLCByZWdleHBdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEJhc2VSZXNvbHZlcigpIHtcbiAgICAgIHRoaXMucmVzb2x2ZXJfZXhhY3RfcGF0aHMgPSBbXTtcbiAgICAgIHRoaXMucmVzb2x2ZXJfcHJlZml4X3BhdGhzID0gW107XG4gICAgfVxuXG4gICAgQmFzZVJlc29sdmVyLnByb3RvdHlwZS5kZXNjZW5kX3Jlc29sdmVyID0gZnVuY3Rpb24oY3VycmVudF9ub2RlLCBjdXJyZW50X2luZGV4KSB7XG4gICAgICB2YXIgZGVwdGgsIGV4YWN0X3BhdGhzLCBraW5kLCBwYXRoLCBwcmVmaXhfcGF0aHMsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0O1xuICAgICAgaWYgKHV0aWwuaXNfZW1wdHkodGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBleGFjdF9wYXRocyA9IHt9O1xuICAgICAgcHJlZml4X3BhdGhzID0gW107XG4gICAgICBpZiAoY3VycmVudF9ub2RlKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlcl9wcmVmaXhfcGF0aHMubGVuZ3RoO1xuICAgICAgICBfcmVmMSA9IHRoaXMucmVzb2x2ZXJfcHJlZml4X3BhdGhzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIF9yZWYyID0gX3JlZjFbX2ldLCBwYXRoID0gX3JlZjJbMF0sIGtpbmQgPSBfcmVmMlsxXTtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja19yZXNvbHZlcl9wcmVmaXgoZGVwdGgsIHBhdGgsIGtpbmQsIGN1cnJlbnRfbm9kZSwgY3VycmVudF9pbmRleCkpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICAgIHByZWZpeF9wYXRocy5wdXNoKFtwYXRoLCBraW5kXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleGFjdF9wYXRoc1traW5kXSA9IHRoaXMueWFtbF9wYXRoX3Jlc29sdmVyc1twYXRoXVtraW5kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZWYzID0gdGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICBfcmVmNCA9IF9yZWYzW19qXSwgcGF0aCA9IF9yZWY0WzBdLCBraW5kID0gX3JlZjRbMV07XG4gICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBleGFjdF9wYXRoc1traW5kXSA9IHRoaXMueWFtbF9wYXRoX3Jlc29sdmVyc1twYXRoXVtraW5kXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlZml4X3BhdGhzLnB1c2goW3BhdGgsIGtpbmRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVzb2x2ZXJfZXhhY3RfcGF0aHMucHVzaChleGFjdF9wYXRocyk7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcl9wcmVmaXhfcGF0aHMucHVzaChwcmVmaXhfcGF0aHMpO1xuICAgIH07XG5cbiAgICBCYXNlUmVzb2x2ZXIucHJvdG90eXBlLmFzY2VuZF9yZXNvbHZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHV0aWwuaXNfZW1wdHkodGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlc29sdmVyX2V4YWN0X3BhdGhzLnBvcCgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXJfcHJlZml4X3BhdGhzLnBvcCgpO1xuICAgIH07XG5cbiAgICBCYXNlUmVzb2x2ZXIucHJvdG90eXBlLmNoZWNrX3Jlc29sdmVyX3ByZWZpeCA9IGZ1bmN0aW9uKGRlcHRoLCBwYXRoLCBraW5kLCBjdXJyZW50X25vZGUsIGN1cnJlbnRfaW5kZXgpIHtcbiAgICAgIHZhciBpbmRleF9jaGVjaywgbm9kZV9jaGVjaywgX3JlZjE7XG4gICAgICBfcmVmMSA9IHBhdGhbZGVwdGggLSAxXSwgbm9kZV9jaGVjayA9IF9yZWYxWzBdLCBpbmRleF9jaGVjayA9IF9yZWYxWzFdO1xuICAgICAgaWYgKHR5cGVvZiBub2RlX2NoZWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY3VycmVudF9ub2RlLnRhZyAhPT0gbm9kZV9jaGVjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlX2NoZWNrICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghKGN1cnJlbnRfbm9kZSBpbnN0YW5jZW9mIG5vZGVfY2hlY2spKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhfY2hlY2sgPT09IHRydWUgJiYgY3VycmVudF9pbmRleCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKGluZGV4X2NoZWNrID09PSBmYWxzZSB8fCBpbmRleF9jaGVjayA9PT0gbnVsbCkgJiYgY3VycmVudF9pbmRleCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluZGV4X2NoZWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIShjdXJyZW50X2luZGV4IGluc3RhbmNlb2Ygbm9kZXMuU2NhbGFyTm9kZSkgJiYgaW5kZXhfY2hlY2sgPT09IGN1cnJlbnRfaW5kZXgudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluZGV4X2NoZWNrID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaW5kZXhfY2hlY2sgIT09IGN1cnJlbnRfaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBCYXNlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihraW5kLCB2YWx1ZSwgaW1wbGljaXQpIHtcbiAgICAgIHZhciBlbXB0eSwgZXhhY3RfcGF0aHMsIGssIHJlZ2V4cCwgcmVzb2x2ZXJzLCB0YWcsIF9pLCBfbGVuLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNDtcbiAgICAgIGlmIChraW5kID09PSBub2Rlcy5TY2FsYXJOb2RlICYmIGltcGxpY2l0WzBdKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICByZXNvbHZlcnMgPSAoX3JlZjEgPSB0aGlzLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzWycnXSkgIT0gbnVsbCA/IF9yZWYxIDogW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZXJzID0gKF9yZWYyID0gdGhpcy55YW1sX2ltcGxpY2l0X3Jlc29sdmVyc1t2YWx1ZVswXV0pICE9IG51bGwgPyBfcmVmMiA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVycyA9IHJlc29sdmVycy5jb25jYXQoKF9yZWYzID0gdGhpcy55YW1sX2ltcGxpY2l0X3Jlc29sdmVyc1tudWxsXSkgIT0gbnVsbCA/IF9yZWYzIDogW10pO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHJlc29sdmVycy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIF9yZWY0ID0gcmVzb2x2ZXJzW19pXSwgdGFnID0gX3JlZjRbMF0sIHJlZ2V4cCA9IF9yZWY0WzFdO1xuICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaChyZWdleHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbXBsaWNpdCA9IGltcGxpY2l0WzFdO1xuICAgICAgfVxuICAgICAgZW1wdHkgPSB0cnVlO1xuICAgICAgZm9yIChrIGluIHRoaXMueWFtbF9wYXRoX3Jlc29sdmVycykge1xuICAgICAgICBpZiAoe31ba10gPT0gbnVsbCkge1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgZXhhY3RfcGF0aHMgPSB0aGlzLnJlc29sdmVyX2V4YWN0X3BhdGhzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGV4YWN0X3BhdGhzLCBraW5kKSA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGV4YWN0X3BhdGhzW2tpbmRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChleGFjdF9wYXRocywgbnVsbCkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiBleGFjdF9wYXRoc1tudWxsXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IG5vZGVzLlNjYWxhck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfU0NBTEFSX1RBRztcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBub2Rlcy5TZXF1ZW5jZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfU0VRVUVOQ0VfVEFHO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX01BUFBJTkdfVEFHO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQmFzZVJlc29sdmVyO1xuXG4gIH0pKCk7XG5cbiAgdGhpcy5SZXNvbHZlciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzb2x2ZXIsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBSZXNvbHZlcigpIHtcbiAgICAgIF9yZWYxID0gUmVzb2x2ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlc29sdmVyO1xuXG4gIH0pKHRoaXMuQmFzZVJlc29sdmVyKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIC9eKD86dHJ1ZXxUcnVlfFRSVUV8ZmFsc2V8RmFsc2V8RkFMU0UpJC8sICd0VGZGJyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JywgL14oPzpbLStdPyg/OlswLTldWzAtOV9dKilcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspP3xcXC5bMC05X10rKD86W2VFXVstK11bMC05XSspP3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKnxbLStdP1xcLig/OmluZnxJbmZ8SU5GKXxcXC4oPzpuYW58TmFOfE5BTikpJC8sICctKzAxMjM0NTY3ODkuJyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIC9eKD86Wy0rXT8wYlswMV9dK3xbLStdPzBbMC03X10rfFstK10/KD86MHxbMS05XVswLTlfXSopfFstK10/MHhbMC05YS1mQS1GX10rfFstK10/MG9bMC03X10rfFstK10/WzEtOV1bMC05X10qKD86OlswLTVdP1swLTldKSspJC8sICctKzAxMjM0NTY3ODknKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCAvXig/Ojw8KSQvLCAnPCcpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywgL14oPzp+fG51bGx8TnVsbHxOVUxMfCkkLywgWyd+JywgJ24nLCAnTicsICcnXSk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIC9eKD86WzAtOV1bMC05XVswLTldWzAtOV0tWzAtOV1bMC05XS1bMC05XVswLTldfFswLTldWzAtOV1bMC05XVswLTldLVswLTldWzAtOV0/LVswLTldWzAtOV0/KD86W1R0XXxbXFx4MjBcXHRdKylbMC05XVswLTldPzpbMC05XVswLTldOlswLTldWzAtOV0oPzpcXC5bMC05XSopPyg/OltcXHgyMFxcdF0qKD86WnxbLStdWzAtOV1bMC05XT8oPzo6WzAtOV1bMC05XSk/KSk/KSQvLCAnMDEyMzQ1Njc4OScpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjp2YWx1ZScsIC9eKD86PSkkLywgJz0nKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6eWFtbCcsIC9eKD86IXwmfFxcKikkLywgJyEmKicpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBub2RlcywgdXRpbCwgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKlxuICBUaGUgUmVzb3VyY2VUeXBlcyB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLlJlc291cmNlVHlwZUVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNvdXJjZVR5cGVFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFJlc291cmNlVHlwZUVycm9yKCkge1xuICAgICAgX3JlZiA9IFJlc291cmNlVHlwZUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlc291cmNlVHlwZUVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgVGhlIFJlc291cmNlVHlwZXMgY2xhc3MgZGVhbHMgd2l0aCBhcHBseWluZyBSZXNvdXJjZVR5cGVzIHRvIHJlc291cmNlcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgKi9cblxuXG4gIHRoaXMuUmVzb3VyY2VUeXBlcyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZVR5cGVzKCkge1xuICAgICAgdGhpcy5hcHBseV9wYXJhbWV0ZXJzX3RvX3R5cGUgPSBfX2JpbmQodGhpcy5hcHBseV9wYXJhbWV0ZXJzX3RvX3R5cGUsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBseV90eXBlID0gX19iaW5kKHRoaXMuYXBwbHlfdHlwZSwgdGhpcyk7XG4gICAgICB0aGlzLmFwcGx5X3R5cGVzID0gX19iaW5kKHRoaXMuYXBwbHlfdHlwZXMsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRfdHlwZSA9IF9fYmluZCh0aGlzLmdldF90eXBlLCB0aGlzKTtcbiAgICAgIHRoaXMuaGFzX3R5cGVzID0gX19iaW5kKHRoaXMuaGFzX3R5cGVzLCB0aGlzKTtcbiAgICAgIHRoaXMubG9hZF90eXBlcyA9IF9fYmluZCh0aGlzLmxvYWRfdHlwZXMsIHRoaXMpO1xuICAgICAgdGhpcy5kZWNsYXJlZFR5cGVzID0ge307XG4gICAgfVxuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUubG9hZF90eXBlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBhbGxUeXBlcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5sb2FkX2RlZmF1bHRfbWVkaWFfdHlwZShub2RlKTtcbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShub2RlLCAncmVzb3VyY2VUeXBlcycpKSB7XG4gICAgICAgIGFsbFR5cGVzID0gdGhpcy5wcm9wZXJ0eV92YWx1ZShub2RlLCAncmVzb3VyY2VUeXBlcycpO1xuICAgICAgICBpZiAoYWxsVHlwZXMgJiYgdHlwZW9mIGFsbFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiBhbGxUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGVfaXRlbSkge1xuICAgICAgICAgICAgaWYgKHR5cGVfaXRlbSAmJiB0eXBlb2YgdHlwZV9pdGVtID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHlwZV9pdGVtLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZV9pdGVtLnZhbHVlLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5kZWNsYXJlZFR5cGVzW3R5cGVbMF0udmFsdWVdID0gdHlwZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUuaGFzX3R5cGVzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZGVjbGFyZWRUeXBlcykubGVuZ3RoID09PSAwICYmIHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsICdyZXNvdXJjZVR5cGVzJykpIHtcbiAgICAgICAgdGhpcy5sb2FkX3R5cGVzKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGVjbGFyZWRUeXBlcykubGVuZ3RoID4gMDtcbiAgICB9O1xuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUuZ2V0X3R5cGUgPSBmdW5jdGlvbih0eXBlTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyZWRUeXBlc1t0eXBlTmFtZV07XG4gICAgfTtcblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLmFwcGx5X3R5cGVzID0gZnVuY3Rpb24obm9kZSwgcmVzb3VyY2VVcmkpIHtcbiAgICAgIHZhciByZXNvdXJjZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChyZXNvdXJjZVVyaSA9PSBudWxsKSB7XG4gICAgICAgIHJlc291cmNlVXJpID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzX3R5cGVzKG5vZGUpKSB7XG4gICAgICAgIHJlc291cmNlcyA9IHRoaXMuY2hpbGRfcmVzb3VyY2VzKG5vZGUpO1xuICAgICAgICByZXR1cm4gcmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICBfdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UocmVzb3VyY2VbMV0pO1xuICAgICAgICAgIGlmIChfdGhpcy5oYXNfcHJvcGVydHkocmVzb3VyY2VbMV0sICd0eXBlJykpIHtcbiAgICAgICAgICAgIHR5cGUgPSBfdGhpcy5nZXRfcHJvcGVydHkocmVzb3VyY2VbMV0sICd0eXBlJyk7XG4gICAgICAgICAgICBfdGhpcy5hcHBseV90eXBlKHJlc291cmNlVXJpICsgcmVzb3VyY2VbMF0udmFsdWUsIHJlc291cmNlLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGx5X3R5cGVzKHJlc291cmNlWzFdLCByZXNvdXJjZVVyaSArIHJlc291cmNlWzBdLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvdXJjZXMgPSB0aGlzLmNoaWxkX3Jlc291cmNlcyhub2RlKTtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZShyZXNvdXJjZVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5hcHBseV90eXBlID0gZnVuY3Rpb24ocmVzb3VyY2VVcmksIHJlc291cmNlLCB0eXBlS2V5KSB7XG4gICAgICB2YXIgdGVtcFR5cGU7XG4gICAgICB0ZW1wVHlwZSA9IHRoaXMucmVzb2x2ZV9pbmhlcml0YW5jZV9jaGFpbihyZXNvdXJjZVVyaSwgdHlwZUtleSk7XG4gICAgICB0ZW1wVHlwZS5jb21iaW5lKHJlc291cmNlWzFdKTtcbiAgICAgIHJlc291cmNlWzFdID0gdGVtcFR5cGU7XG4gICAgICByZXR1cm4gcmVzb3VyY2VbMV0ucmVtb3ZlX3F1ZXN0aW9uX21hcmtfcHJvcGVydGllcygpO1xuICAgIH07XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5yZXNvbHZlX2luaGVyaXRhbmNlX2NoYWluID0gZnVuY3Rpb24ocmVzb3VyY2VVcmksIHR5cGVLZXkpIHtcbiAgICAgIHZhciBiYXNlVHlwZSwgY2hpbGRUeXBlLCBjaGlsZFR5cGVOYW1lLCBjaGlsZFR5cGVQcm9wZXJ0eSwgY29tcGlsZWRUeXBlcywgaW5oZXJpdHNGcm9tLCBwYXJlbnRUeXBlLCBwYXJlbnRUeXBlTmFtZSwgcGF0aFRvQ2lyY3VsYXJSZWYsIHJlc3VsdCwgcm9vdFR5cGUsIHR5cGVzVG9BcHBseTtcbiAgICAgIGNoaWxkVHlwZU5hbWUgPSB0aGlzLmtleV9vcl92YWx1ZSh0eXBlS2V5KTtcbiAgICAgIGNoaWxkVHlwZSA9IHRoaXMuYXBwbHlfcGFyYW1ldGVyc190b190eXBlKHJlc291cmNlVXJpLCBjaGlsZFR5cGVOYW1lLCB0eXBlS2V5KTtcbiAgICAgIHR5cGVzVG9BcHBseSA9IFtjaGlsZFR5cGVOYW1lXTtcbiAgICAgIGNvbXBpbGVkVHlwZXMgPSB7fTtcbiAgICAgIGNvbXBpbGVkVHlwZXNbY2hpbGRUeXBlTmFtZV0gPSBjaGlsZFR5cGU7XG4gICAgICB0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZShjaGlsZFR5cGUpO1xuICAgICAgdGhpcy5hcHBseV90cmFpdHNfdG9fcmVzb3VyY2UocmVzb3VyY2VVcmksIGNoaWxkVHlwZSwgZmFsc2UpO1xuICAgICAgd2hpbGUgKHRoaXMuaGFzX3Byb3BlcnR5KGNoaWxkVHlwZSwgJ3R5cGUnKSkge1xuICAgICAgICB0eXBlS2V5ID0gdGhpcy5nZXRfcHJvcGVydHkoY2hpbGRUeXBlLCAndHlwZScpO1xuICAgICAgICBwYXJlbnRUeXBlTmFtZSA9IHRoaXMua2V5X29yX3ZhbHVlKHR5cGVLZXkpO1xuICAgICAgICBpZiAocGFyZW50VHlwZU5hbWUgaW4gY29tcGlsZWRUeXBlcykge1xuICAgICAgICAgIHBhdGhUb0NpcmN1bGFyUmVmID0gdHlwZXNUb0FwcGx5LmNvbmNhdChwYXJlbnRUeXBlTmFtZSkuam9pbignIC0+ICcpO1xuICAgICAgICAgIGNoaWxkVHlwZVByb3BlcnR5ID0gdGhpcy5nZXRfdHlwZShjaGlsZFR5cGVOYW1lKVswXTtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5SZXNvdXJjZVR5cGVFcnJvcignd2hpbGUgYXBwbHlpbmcgcmVzb3VyY2VUeXBlcycsIG51bGwsIFwiY2lyY3VsYXIgcmVmZXJlbmNlIG9mIFxcXCJcIiArIHBhcmVudFR5cGVOYW1lICsgXCJcXFwiIGhhcyBiZWVuIGRldGVjdGVkOiBcIiArIHBhdGhUb0NpcmN1bGFyUmVmLCBjaGlsZFR5cGVQcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRUeXBlID0gdGhpcy5hcHBseV9wYXJhbWV0ZXJzX3RvX3R5cGUocmVzb3VyY2VVcmksIHBhcmVudFR5cGVOYW1lLCB0eXBlS2V5KTtcbiAgICAgICAgdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UocGFyZW50VHlwZSk7XG4gICAgICAgIHRoaXMuYXBwbHlfdHJhaXRzX3RvX3Jlc291cmNlKHJlc291cmNlVXJpLCBwYXJlbnRUeXBlLCBmYWxzZSk7XG4gICAgICAgIGNoaWxkVHlwZU5hbWUgPSBwYXJlbnRUeXBlTmFtZTtcbiAgICAgICAgY2hpbGRUeXBlID0gcGFyZW50VHlwZTtcbiAgICAgICAgY29tcGlsZWRUeXBlc1tjaGlsZFR5cGVOYW1lXSA9IGNoaWxkVHlwZTtcbiAgICAgICAgdHlwZXNUb0FwcGx5LnB1c2goY2hpbGRUeXBlTmFtZSk7XG4gICAgICB9XG4gICAgICByb290VHlwZSA9IHR5cGVzVG9BcHBseS5wb3AoKTtcbiAgICAgIGJhc2VUeXBlID0gY29tcGlsZWRUeXBlc1tyb290VHlwZV0uY2xvbmVGb3JSZXNvdXJjZVR5cGUoKTtcbiAgICAgIHJlc3VsdCA9IGJhc2VUeXBlO1xuICAgICAgd2hpbGUgKGluaGVyaXRzRnJvbSA9IHR5cGVzVG9BcHBseS5wb3AoKSkge1xuICAgICAgICBiYXNlVHlwZSA9IGNvbXBpbGVkVHlwZXNbaW5oZXJpdHNGcm9tXS5jbG9uZUZvclJlc291cmNlVHlwZSgpO1xuICAgICAgICByZXN1bHQuY29tYmluZShiYXNlVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5hcHBseV9wYXJhbWV0ZXJzX3RvX3R5cGUgPSBmdW5jdGlvbihyZXNvdXJjZVVyaSwgdHlwZU5hbWUsIHR5cGVLZXkpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXJzLCB0eXBlO1xuICAgICAgaWYgKCEodHlwZU5hbWUgIT0gbnVsbCA/IHR5cGVOYW1lLnRyaW0oKSA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUmVzb3VyY2VUeXBlRXJyb3IoJ3doaWxlIGFwcGx5aW5nIHJlc291cmNlIHR5cGUnLCBudWxsLCAncmVzb3VyY2UgdHlwZSBuYW1lIG11c3QgYmUgcHJvdmlkZWQnLCB0eXBlS2V5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCEodHlwZSA9IHRoaXMuZ2V0X3R5cGUodHlwZU5hbWUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5SZXNvdXJjZVR5cGVFcnJvcignd2hpbGUgYXBwbHlpbmcgcmVzb3VyY2UgdHlwZScsIG51bGwsIFwidGhlcmUgaXMgbm8gcmVzb3VyY2UgdHlwZSBuYW1lZCBcIiArIHR5cGVOYW1lLCB0eXBlS2V5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHR5cGVbMV0uY2xvbmUoKTtcbiAgICAgIHBhcmFtZXRlcnMgPSB0aGlzLl9nZXRfcGFyYW1ldGVyc19mcm9tX3R5cGVfa2V5KHJlc291cmNlVXJpLCB0eXBlS2V5KTtcbiAgICAgIHRoaXMuYXBwbHlfcGFyYW1ldGVycyh0eXBlLCBwYXJhbWV0ZXJzLCB0eXBlS2V5KTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5fZ2V0X3BhcmFtZXRlcnNfZnJvbV90eXBlX2tleSA9IGZ1bmN0aW9uKHJlc291cmNlVXJpLCB0eXBlS2V5KSB7XG4gICAgICB2YXIgcGFyYW1ldGVyLCBwYXJhbWV0ZXJzLCByZXNlcnZlZCwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIHJlc2VydmVkID0ge1xuICAgICAgICByZXNvdXJjZVBhdGg6IHJlc291cmNlVXJpLnJlcGxhY2UoL1xcL1xcLyovZywgJy8nKSxcbiAgICAgICAgcmVzb3VyY2VQYXRoTmFtZTogdGhpcy5leHRyYWN0UmVzb3VyY2VQYXRoTmFtZShyZXNvdXJjZVVyaSlcbiAgICAgIH07XG4gICAgICBpZiAodXRpbC5pc01hcHBpbmcodHlwZUtleSkpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHRoaXMudmFsdWVfb3JfdW5kZWZpbmVkKHR5cGVLZXkpO1xuICAgICAgICBpZiAodXRpbC5pc01hcHBpbmcocGFyYW1ldGVyc1swXVsxXSkpIHtcbiAgICAgICAgICBfcmVmMSA9IHBhcmFtZXRlcnNbMF1bMV0udmFsdWU7XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgcGFyYW1ldGVyID0gX3JlZjFbX2ldO1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXS52YWx1ZSBpbiByZXNlcnZlZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5SZXNvdXJjZVR5cGVFcnJvcignd2hpbGUgYXBwbHlpbmcgcGFyYW1ldGVycycsIG51bGwsIFwiaW52YWxpZCBwYXJhbWV0ZXIgbmFtZTogXCIgKyBwYXJhbWV0ZXJbMF0udmFsdWUgKyBcIiBpcyByZXNlcnZlZFwiLCBwYXJhbWV0ZXJbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbcGFyYW1ldGVyWzBdLnZhbHVlXSA9IHBhcmFtZXRlclsxXS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGlsLmV4dGVuZChyZXN1bHQsIHJlc2VydmVkKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlc291cmNlVHlwZXM7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgU2ltcGxlS2V5LCB0b2tlbnMsIHV0aWwsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIHRva2VucyA9IHJlcXVpcmUoJy4vdG9rZW5zJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qXG4gIFRoZSBTY2FubmVyIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuU2Nhbm5lckVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FubmVyRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTY2FubmVyRXJyb3IoKSB7XG4gICAgICBfcmVmID0gU2Nhbm5lckVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNjYW5uZXJFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIFJlcHJlc2VudHMgYSBwb3NzaWJsZSBzaW1wbGUga2V5LlxuICAqL1xuXG5cbiAgU2ltcGxlS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZUtleSh0b2tlbl9udW1iZXIsIHJlcXVpcmVkLCBpbmRleCwgbGluZSwgY29sdW1uLCBtYXJrKSB7XG4gICAgICB0aGlzLnRva2VuX251bWJlciA9IHRva2VuX251bWJlcjtcbiAgICAgIHRoaXMucmVxdWlyZWQgPSByZXF1aXJlZDtcbiAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNpbXBsZUtleTtcblxuICB9KSgpO1xuXG4gIC8qXG4gIFRoZSBTY2FubmVyIGNsYXNzIGRlYWxzIHdpdGggY29udmVydGluZyBhIFlBTUwgc3RyZWFtIGludG8gYSB0b2tlbiBzdHJlYW0uXG4gICovXG5cblxuICB0aGlzLlNjYW5uZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIENfTEIsIENfTlVNQkVSUywgQ19XUywgRVNDQVBFX0NPREVTLCBFU0NBUEVfUkVQTEFDRU1FTlRTLCBSQU1MX1ZFUlNJT04sIFJBTUxfVkVSU0lPTl9SRTtcblxuICAgIENfTEIgPSAnXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOSc7XG5cbiAgICBDX1dTID0gJ1xcdCAnO1xuXG4gICAgQ19OVU1CRVJTID0gJzAxMjM0NTY3ODknO1xuXG4gICAgRVNDQVBFX1JFUExBQ0VNRU5UUyA9IHtcbiAgICAgICcwJzogJ1xceDAwJyxcbiAgICAgICdhJzogJ1xceDA3JyxcbiAgICAgICdiJzogJ1xceDA4JyxcbiAgICAgICd0JzogJ1xceDA5JyxcbiAgICAgICdcXHQnOiAnXFx4MDknLFxuICAgICAgJ24nOiAnXFx4MEEnLFxuICAgICAgJ3YnOiAnXFx4MEInLFxuICAgICAgJ2YnOiAnXFx4MEMnLFxuICAgICAgJ3InOiAnXFx4MEQnLFxuICAgICAgJ2UnOiAnXFx4MUInLFxuICAgICAgJyAnOiAnXFx4MjAnLFxuICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgJ04nOiAnXFx4ODUnLFxuICAgICAgJ18nOiAnXFx4QTAnLFxuICAgICAgJ0wnOiAnXFx1MjAyOCcsXG4gICAgICAnUCc6ICdcXHUyMDI5J1xuICAgIH07XG5cbiAgICBFU0NBUEVfQ09ERVMgPSB7XG4gICAgICAneCc6IDIsXG4gICAgICAndSc6IDQsXG4gICAgICAnVSc6IDhcbiAgICB9O1xuXG4gICAgUkFNTF9WRVJTSU9OID0gJyMlUkFNTCAwLjgnO1xuXG4gICAgUkFNTF9WRVJTSU9OX1JFID0gL14jJVJBTUwgLiskLztcblxuICAgIC8qXG4gICAgSW5pdGlhbGlzZSB0aGUgU2Nhbm5lclxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIFNjYW5uZXIoc2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5yYW1sSGVhZGVyRm91bmQgPSAhdGhpcy5zZXR0aW5ncy52YWxpZGF0ZTtcbiAgICAgIHRoaXMuZmxvd19sZXZlbCA9IDA7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy5mZXRjaF9zdHJlYW1fc3RhcnQoKTtcbiAgICAgIHRoaXMudG9rZW5zX3Rha2VuID0gMDtcbiAgICAgIHRoaXMuaW5kZW50ID0gLTE7XG4gICAgICB0aGlzLmluZGVudHMgPSBbXTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzID0ge307XG4gICAgfVxuXG4gICAgLypcbiAgICBDaGVjayBpZiB0aGUgbmV4dCB0b2tlbiBpcyBvbmUgb2YgdGhlIGdpdmVuIHR5cGVzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hvaWNlLCBjaG9pY2VzLCBfaSwgX2xlbjtcbiAgICAgIGNob2ljZXMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgd2hpbGUgKHRoaXMubmVlZF9tb3JlX3Rva2VucygpKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hfbW9yZV90b2tlbnMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaWYgKGNob2ljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjaG9pY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgY2hvaWNlID0gY2hvaWNlc1tfaV07XG4gICAgICAgICAgaWYgKHRoaXMudG9rZW5zWzBdIGluc3RhbmNlb2YgY2hvaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIG5leHQgdG9rZW4sIGJ1dCBkbyBub3QgZGVsZXRlIGl0IGZyb20gdGhlIHF1ZXVlLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnBlZWtfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHdoaWxlICh0aGlzLm5lZWRfbW9yZV90b2tlbnMoKSkge1xuICAgICAgICB0aGlzLmZldGNoX21vcmVfdG9rZW5zKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1swXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIG5leHQgdG9rZW4sIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcXVldWUuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZ2V0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICB3aGlsZSAodGhpcy5uZWVkX21vcmVfdG9rZW5zKCkpIHtcbiAgICAgICAgdGhpcy5mZXRjaF9tb3JlX3Rva2VucygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLnRva2Vuc190YWtlbisrO1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUubmVlZF9tb3JlX3Rva2VucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFsZV9wb3NzaWJsZV9zaW1wbGVfa2V5cygpO1xuICAgICAgaWYgKHRoaXMubmV4dF9wb3NzaWJsZV9zaW1wbGVfa2V5KCkgPT09IHRoaXMudG9rZW5zX3Rha2VuKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9tb3JlX3Rva2VucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXI7XG4gICAgICB0aGlzLnNjYW5fdG9fbmV4dF90b2tlbigpO1xuICAgICAgdGhpcy5zdGFsZV9wb3NzaWJsZV9zaW1wbGVfa2V5cygpO1xuICAgICAgdGhpcy51bndpbmRfaW5kZW50KHRoaXMuY29sdW1uKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChjaGFyID09PSAnXFx4MDAnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX3N0cmVhbV9lbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnJScgJiYgdGhpcy5jaGVja19kaXJlY3RpdmUoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9kaXJlY3RpdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnLScgJiYgdGhpcy5jaGVja19kb2N1bWVudF9zdGFydCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvY3VtZW50X3N0YXJ0KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJy4nICYmIHRoaXMuY2hlY2tfZG9jdW1lbnRfZW5kKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZG9jdW1lbnRfZW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJ1snKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfc2VxdWVuY2Vfc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAneycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19tYXBwaW5nX3N0YXJ0KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJ10nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfc2VxdWVuY2VfZW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJ30nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfbWFwcGluZ19lbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnLCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19lbnRyeSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICctJyAmJiB0aGlzLmNoZWNrX2Jsb2NrX2VudHJ5KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfYmxvY2tfZW50cnkoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnPycgJiYgdGhpcy5jaGVja19rZXkoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9rZXkoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnOicgJiYgdGhpcy5jaGVja192YWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX3ZhbHVlKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2FsaWFzKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJyYnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2FuY2hvcigpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICchJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF90YWcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnfCcgJiYgdGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2xpdGVyYWwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnPicgJiYgdGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2ZvbGRlZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICdcXCcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX3NpbmdsZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZG91YmxlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jaGVja19wbGFpbigpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX3BsYWluKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGZvciB0aGUgbmV4dCB0b2tlbicsIG51bGwsIFwiZm91bmQgY2hhcmFjdGVyIFwiICsgY2hhciArIFwiIHRoYXQgY2Fubm90IHN0YXJ0IGFueSB0b2tlblwiLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgbnVtYmVyIG9mIHRoZSBuZWFyZXN0IHBvc3NpYmxlIHNpbXBsZSBrZXkuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUubmV4dF9wb3NzaWJsZV9zaW1wbGVfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5LCBsZXZlbCwgbWluX3Rva2VuX251bWJlciwgX3JlZjE7XG4gICAgICBtaW5fdG9rZW5fbnVtYmVyID0gbnVsbDtcbiAgICAgIF9yZWYxID0gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5cztcbiAgICAgIGZvciAobGV2ZWwgaW4gX3JlZjEpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChfcmVmMSwgbGV2ZWwpKSBjb250aW51ZTtcbiAgICAgICAga2V5ID0gX3JlZjFbbGV2ZWxdO1xuICAgICAgICBpZiAobWluX3Rva2VuX251bWJlciA9PT0gbnVsbCB8fCBrZXkudG9rZW5fbnVtYmVyIDwgbWluX3Rva2VuX251bWJlcikge1xuICAgICAgICAgIG1pbl90b2tlbl9udW1iZXIgPSBrZXkudG9rZW5fbnVtYmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluX3Rva2VuX251bWJlcjtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZW1vdmUgZW50cmllcyB0aGF0IGFyZSBubyBsb25nZXIgcG9zc2libGUgc2ltcGxlIGtleXMuICBBY2NvcmRpbmcgdG8gdGhlXG4gICAgWUFNTCBzcGVjLCBzaW1wbGUga2V5czpcbiAgICAgIHNob3VsZCBiZSBsaW1pdGVkIHRvIGEgc2luZ2xlIGxpbmVcbiAgICAgIHNob3VsZCBiZSBubyBsb25nZXIgdGhhbiAxMDI0IGNoYXJhY3RlcnNcbiAgICBEaXNhYmxpbmcgdGhpcyBwcm9jZWR1cmUgd2lsbCBhbGxvdyBzaW1wbGUga2V5cyBvZiBhbnkgbGVuZ3RoIGFuZCBoZWlnaHRcbiAgICAobWF5IGNhdXNlIHByb2JsZW1zIGlmIGluZGVudGF0aW9uIGlzIGJyb2tlbiB0aG91Z2gpLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnN0YWxlX3Bvc3NpYmxlX3NpbXBsZV9rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5LCBsZXZlbCwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgX3JlZjEgPSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAobGV2ZWwgaW4gX3JlZjEpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChfcmVmMSwgbGV2ZWwpKSBjb250aW51ZTtcbiAgICAgICAga2V5ID0gX3JlZjFbbGV2ZWxdO1xuICAgICAgICBpZiAoa2V5LmxpbmUgPT09IHRoaXMubGluZSAmJiB0aGlzLmluZGV4IC0ga2V5LmluZGV4IDw9IDEwMjQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtleS5yZXF1aXJlZCkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZGVsZXRlIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbbGV2ZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgc2ltcGxlIGtleScsIGtleS5tYXJrLCAnY291bGQgbm90IGZpbmQgZXhwZWN0ZWQgXFwnOlxcJycsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgLypcbiAgICBUaGUgbmV4dCB0b2tlbiBtYXkgc3RhcnQgYSBzaW1wbGUga2V5LiAgV2UgY2hlY2sgaWYgaXQncyBwb3NzaWJsZSBhbmQgc2F2ZVxuICAgIGl0cyBwb3NpdGlvbi4gIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBBTElBUywgQU5DSE9SLCBUQUcsXG4gICAgU0NBTEFSIChmbG93KSwnWycgYW5kICd7Jy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXF1aXJlZCwgdG9rZW5fbnVtYmVyO1xuICAgICAgcmVxdWlyZWQgPSB0aGlzLmZsb3dfbGV2ZWwgPT09IDAgJiYgdGhpcy5pbmRlbnQgPT09IHRoaXMuY29sdW1uO1xuICAgICAgaWYgKHJlcXVpcmVkICYmICF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2dpYyBmYWlsdXJlJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYWxsb3dfc2ltcGxlX2tleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0b2tlbl9udW1iZXIgPSB0aGlzLnRva2Vuc190YWtlbiArIHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW3RoaXMuZmxvd19sZXZlbF0gPSBuZXcgU2ltcGxlS2V5KHRva2VuX251bWJlciwgcmVxdWlyZWQsIHRoaXMuaW5kZXgsIHRoaXMubGluZSwgdGhpcy5jb2x1bW4sIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmVtb3ZlIHRoZSBzYXZlZCBwb3NzaWJsZSBzaW1wbGUga2V5IGF0IHRoZSBjdXJyZW50IGZsb3cgbGV2ZWwuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBpZiAoIShrZXkgPSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW3RoaXMuZmxvd19sZXZlbF0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5LnJlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5c1t0aGlzLmZsb3dfbGV2ZWxdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHNpbXBsZSBrZXknLCBrZXkubWFyaywgJ2NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFxcJzpcXCcnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEluIGZsb3cgY29udGV4dCwgdG9rZW5zIHNob3VsZCByZXNwZWN0IGluZGVudGF0aW9uLlxuICAgIEFjdHVhbGx5IHRoZSBjb25kaXRpb24gc2hvdWxkIGJlIGBzZWxmLmluZGVudCA+PSBjb2x1bW5gIGFjY29yZGluZyB0b1xuICAgIHRoZSBzcGVjLiBCdXQgdGhpcyBjb25kaXRpb24gd2lsbCBwcm9oaWJpdCBpbnR1aXRpdmVseSBjb3JyZWN0XG4gICAgY29uc3RydWN0aW9ucyBzdWNoIGFzXG4gICAgICBrZXkgOiB7XG4gICAgICB9XG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUudW53aW5kX2luZGVudCA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgdmFyIG1hcmssIF9yZXN1bHRzO1xuICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgd2hpbGUgKHRoaXMuaW5kZW50ID4gY29sdW1uKSB7XG4gICAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5pbmRlbnRzLnBvcCgpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5CbG9ja0VuZFRva2VuKG1hcmssIG1hcmspKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2sgaWYgd2UgbmVlZCB0byBpbmNyZWFzZSBpbmRlbnRhdGlvbi5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5hZGRfaW5kZW50ID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICBpZiAoIShjb2x1bW4gPiB0aGlzLmluZGVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbmRlbnRzLnB1c2godGhpcy5pbmRlbnQpO1xuICAgICAgdGhpcy5pbmRlbnQgPSBjb2x1bW47XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfc3RyZWFtX3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFyaztcbiAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLlN0cmVhbVN0YXJ0VG9rZW4obWFyaywgbWFyaywgdGhpcy5lbmNvZGluZykpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9zdHJlYW1fZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFyaztcbiAgICAgIHRoaXMudW53aW5kX2luZGVudCgtMSk7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3Bvc3NpYmxlX3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXMgPSB7fTtcbiAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuU3RyZWFtRW5kVG9rZW4obWFyaywgbWFyaykpO1xuICAgICAgcmV0dXJuIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy51bndpbmRfaW5kZW50KC0xKTtcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX2RpcmVjdGl2ZSgpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZG9jdW1lbnRfc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvY3VtZW50X2luZGljYXRvcih0b2tlbnMuRG9jdW1lbnRTdGFydFRva2VuKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZG9jdW1lbnRfZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9kb2N1bWVudF9pbmRpY2F0b3IodG9rZW5zLkRvY3VtZW50RW5kVG9rZW4pO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9kb2N1bWVudF9pbmRpY2F0b3IgPSBmdW5jdGlvbihUb2tlbkNsYXNzKSB7XG4gICAgICB2YXIgc3RhcnRfbWFyaztcbiAgICAgIHRoaXMudW53aW5kX2luZGVudCgtMSk7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoMyk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgVG9rZW5DbGFzcyhzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19zZXF1ZW5jZV9zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX3N0YXJ0KHRva2Vucy5GbG93U2VxdWVuY2VTdGFydFRva2VuKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19tYXBwaW5nX3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X2NvbGxlY3Rpb25fc3RhcnQodG9rZW5zLkZsb3dNYXBwaW5nU3RhcnRUb2tlbik7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfY29sbGVjdGlvbl9zdGFydCA9IGZ1bmN0aW9uKFRva2VuQ2xhc3MpIHtcbiAgICAgIHZhciBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuZmxvd19sZXZlbCsrO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyBUb2tlbkNsYXNzKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X3NlcXVlbmNlX2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX2VuZCh0b2tlbnMuRmxvd1NlcXVlbmNlRW5kVG9rZW4pO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X21hcHBpbmdfZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X2NvbGxlY3Rpb25fZW5kKHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX2VuZCA9IGZ1bmN0aW9uKFRva2VuQ2xhc3MpIHtcbiAgICAgIHZhciBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5mbG93X2xldmVsLS07XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyBUb2tlbkNsYXNzKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLkZsb3dFbnRyeVRva2VuKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9ibG9ja19lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmssIHN0YXJ0X21hcms7XG4gICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd19zaW1wbGVfa2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKG51bGwsIG51bGwsICdzZXF1ZW5jZSBlbnRyaWVzIGFyZSBub3QgYWxsb3dlZCBoZXJlJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hZGRfaW5kZW50KHRoaXMuY29sdW1uKSkge1xuICAgICAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgICAgdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLkJsb2NrU2VxdWVuY2VTdGFydFRva2VuKG1hcmssIG1hcmspKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tFbnRyeVRva2VuKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrLCBzdGFydF9tYXJrO1xuICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dfc2ltcGxlX2tleSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihudWxsLCBudWxsLCAnbWFwcGluZyBrZXlzIGFyZSBub3QgYWxsb3dlZCBoZXJlJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hZGRfaW5kZW50KHRoaXMuY29sdW1uKSkge1xuICAgICAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgICAgdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLkJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4obWFyaywgbWFyaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSAhdGhpcy5mbG93X2xldmVsO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5LZXlUb2tlbihzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXksIG1hcmssIHN0YXJ0X21hcms7XG4gICAgICBpZiAoa2V5ID0gdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5c1t0aGlzLmZsb3dfbGV2ZWxdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW3RoaXMuZmxvd19sZXZlbF07XG4gICAgICAgIHRoaXMudG9rZW5zLnNwbGljZShrZXkudG9rZW5fbnVtYmVyIC0gdGhpcy50b2tlbnNfdGFrZW4sIDAsIG5ldyB0b2tlbnMuS2V5VG9rZW4oa2V5Lm1hcmssIGtleS5tYXJrKSk7XG4gICAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5hZGRfaW5kZW50KGtleS5jb2x1bW4pKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vucy5zcGxpY2Uoa2V5LnRva2VuX251bWJlciAtIHRoaXMudG9rZW5zX3Rha2VuLCAwLCBuZXcgdG9rZW5zLkJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4oa2V5Lm1hcmssIGtleS5tYXJrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICAgIGlmICghdGhpcy5hbGxvd19zaW1wbGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IobnVsbCwgbnVsbCwgJ21hcHBpbmcgdmFsdWVzIGFyZSBub3QgYWxsb3dlZCBoZXJlJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuYWRkX2luZGVudCh0aGlzLmNvbHVtbikpIHtcbiAgICAgICAgICAgIG1hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbihtYXJrLCBtYXJrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9ICF0aGlzLmZsb3dfbGV2ZWw7XG4gICAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuVmFsdWVUb2tlbihzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfYWxpYXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9hbmNob3IodG9rZW5zLkFsaWFzVG9rZW4pKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfYW5jaG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fYW5jaG9yKHRva2Vucy5BbmNob3JUb2tlbikpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF90YWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl90YWcoKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2xpdGVyYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Jsb2NrX3NjYWxhcignfCcpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mb2xkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Jsb2NrX3NjYWxhcignPicpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9ibG9ja19zY2FsYXIgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9ibG9ja19zY2FsYXIoc3R5bGUpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfc2luZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X3NjYWxhcignXFwnJyk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2RvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19zY2FsYXIoJ1wiJyk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfc2NhbGFyID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9mbG93X3NjYWxhcihzdHlsZSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9wbGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX3BsYWluKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIERJUkVDVElWRTogXiAnJSdcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja19kaXJlY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbHVtbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBET0NVTUVOVC1TVEFSVDogXiAnLS0tJyAoJyAnfCdcXG4nKVxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX2RvY3VtZW50X3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjE7XG4gICAgICBpZiAodGhpcy5jb2x1bW4gPT09IDAgJiYgdGhpcy5wcmVmaXgoMykgPT09ICctLS0nICYmIChfcmVmMSA9IHRoaXMucGVlaygzKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPj0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRE9DVU1FTlQtRU5EOiBeICcuLi4nICgnICd8J1xcbicpXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfZG9jdW1lbnRfZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjE7XG4gICAgICBpZiAodGhpcy5jb2x1bW4gPT09IDAgJiYgdGhpcy5wcmVmaXgoMykgPT09ICcuLi4nICYmIChfcmVmMSA9IHRoaXMucGVlaygzKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPj0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQkxPQ0stRU5UUlk6ICctJyAoJyAnfCdcXG4nKVxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX2Jsb2NrX2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjE7XG4gICAgICByZXR1cm4gX3JlZjEgPSB0aGlzLnBlZWsoMSksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpID49IDA7XG4gICAgfTtcblxuICAgIC8qXG4gICAgS0VZIChmbG93IGNvbnRleHQpOiAgJz8nXG4gICAgS0VZIChibG9jayBjb250ZXh0KTogJz8nICgnICd8J1xcbicpXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjE7XG4gICAgICBpZiAodGhpcy5mbG93X2xldmVsICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZWYxID0gdGhpcy5wZWVrKDEpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFZBTFVFIChmbG93IGNvbnRleHQpOiAgJzonXG4gICAgVkFMVUUgKGJsb2NrIGNvbnRleHQpOiAnOicgKCcgJ3wnXFxuJylcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja192YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYxO1xuICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVmMSA9IHRoaXMucGVlaygxKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPj0gMDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBIHBsYWluIHNjYWxhciBtYXkgc3RhcnQgd2l0aCBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlciBleGNlcHQ6XG4gICAgICAnLScsICc/JywgJzonLCAnLCcsICdbJywgJ10nLCAneycsICd9JyxcbiAgICAgICcjJywgJyYnLCAnKicsICchJywgJ3wnLCAnPicsICdcXCcnLCAnXCInLFxuICAgICAgJyUnLCAnQCcsICdgJy5cbiAgICBcbiAgICBJdCBtYXkgYWxzbyBzdGFydCB3aXRoXG4gICAgICAnLScsICc/JywgJzonXG4gICAgaWYgaXQgaXMgZm9sbG93ZWQgYnkgYSBub24tc3BhY2UgY2hhcmFjdGVyLlxuICAgIFxuICAgIE5vdGUgdGhhdCB3ZSBsaW1pdCB0aGUgbGFzdCBydWxlIHRvIHRoZSBibG9jayBjb250ZXh0IChleGNlcHQgdGhlICctJ1xuICAgIGNoYXJhY3RlcikgYmVjYXVzZSB3ZSB3YW50IHRoZSBmbG93IGNvbnRleHQgdG8gYmUgc3BhY2UgaW5kZXBlbmRlbnQuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfcGxhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFyLCBfcmVmMTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIHJldHVybiBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMC0/OixbXXt9IyYqIXw+XFwnXCIlQGAnLCBjaGFyKSA8IDAgfHwgKChfcmVmMSA9IHRoaXMucGVlaygxKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPCAwKSAmJiAoY2hhciA9PT0gJy0nIHx8ICh0aGlzLmZsb3dfbGV2ZWwgPT09IDAgJiYgX19pbmRleE9mLmNhbGwoJz86JywgY2hhcikgPj0gMCkpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBXZSBpZ25vcmUgc3BhY2VzLCBsaW5lIGJyZWFrcyBhbmQgY29tbWVudHMuXG4gICAgSWYgd2UgZmluZCBhIGxpbmUgYnJlYWsgaW4gdGhlIGJsb2NrIGNvbnRleHQsIHdlIHNldCB0aGUgZmxhZ1xuICAgIGBhbGxvd19zaW1wbGVfa2V5YCBvbi5cbiAgICBUaGUgYnl0ZSBvcmRlciBtYXJrIGlzIHN0cmlwcGVkIGlmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyZWFtLlxuICAgIFdlIGRvIG5vdCB5ZXQgc3VwcG9ydCBCT00gaW5zaWRlIHRoZSBzdHJlYW0gYXMgdGhlIHNwZWNpZmljYXRpb24gcmVxdWlyZXMuXG4gICAgQW55IHN1Y2ggbWFyayB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAgICBcbiAgICBUT0RPOiBXZSBuZWVkIHRvIG1ha2UgdGFiIGhhbmRsaW5nIHJ1bGVzIG1vcmUgc2FuZS4gIEEgZ29vZCBydWxlIGlzXG4gICAgICBUYWJzIGNhbm5vdCBwcmVjZWRlIHRva2VucyBCTE9DSy1TRVFVRU5DRS1TVEFSVCwgQkxPQ0stTUFQUElORy1TVEFSVCxcbiAgICAgIEJMT0NLLUVORCwgS0VZIChibG9jayBjb250ZXh0KSwgVkFMVUUgKGJsb2NrIGNvbnRleHQpLCBCTE9DSy1FTlRSWVxuICAgIFNvIHRoZSB0YWIgY2hlY2tpbmcgY29kZSBpc1xuICAgICAgQGFsbG93X3NpbXBsZV9rZXkgPSBvZmYgaWYgPFRBQj5cbiAgICBXZSBhbHNvIG5lZWQgdG8gYWRkIHRoZSBjaGVjayBmb3IgYGFsbG93X3NpbXBsZV9rZXkgaXMgb25gIHRvXG4gICAgYHVud2luZF9pbmRlbnRgIGJlZm9yZSBpc3N1aW5nIEJMT0NLLUVORC4gIFNjYW5uZXJzIGZvciBibG9jaywgZmxvdyBhbmRcbiAgICBwbGFpbiBzY2FsYXJzIG5lZWQgdG8gYmUgbW9kaWZpZWQuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl90b19uZXh0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tbWVudCwgZm91bmQsIHRyaW1tZWRDb21tZW50LCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAodGhpcy5pbmRleCA9PT0gMCAmJiB0aGlzLnBlZWsoKSA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAoIWZvdW5kKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWVudCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09ICcjJykge1xuICAgICAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgX3JlZjEpIDwgMCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbWxIZWFkZXJGb3VuZCkge1xuICAgICAgICAgICAgICBjb21tZW50ICs9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yYW1sSGVhZGVyRm91bmQpIHtcbiAgICAgICAgICB0cmltbWVkQ29tbWVudCA9IGNvbW1lbnQudHJpbSgpO1xuICAgICAgICAgIGlmICh0cmltbWVkQ29tbWVudCAmJiBSQU1MX1ZFUlNJT05fUkUudGVzdCh0cmltbWVkQ29tbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0cmltbWVkQ29tbWVudCA9PT0gUkFNTF9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFtbEhlYWRlckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcigndmVyc2lvbiB2YWxpZGF0aW9uJywgbnVsbCwgXCJVbnN1cHBvcnRlZCBSQU1MIHZlcnNpb246ICdcIiArIGNvbW1lbnQgKyBcIidcIiwgdGhpcy5jcmVhdGVfbWFyaygwLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcigndmVyc2lvbiB2YWxpZGF0aW9uJywgbnVsbCwgXCJUaGUgZmlyc3QgbGluZSBtdXN0IGJlOiAnXCIgKyBSQU1MX1ZFUlNJT04gKyBcIidcIiwgdGhpcy5jcmVhdGVfbWFyaygwLCAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjYW5fbGluZV9icmVhaygpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGZvdW5kID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9kaXJlY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbmRfbWFyaywgbmFtZSwgc3RhcnRfbWFyaywgdmFsdWUsIF9yZWYxO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgbmFtZSA9IHRoaXMuc2Nhbl9kaXJlY3RpdmVfbmFtZShzdGFydF9tYXJrKTtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmIChuYW1lID09PSAnWUFNTCcpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNjYW5feWFtbF9kaXJlY3RpdmVfdmFsdWUoc3RhcnRfbWFyayk7XG4gICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnVEFHJykge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuc2Nhbl90YWdfZGlyZWN0aXZlX3ZhbHVlKHN0YXJ0X21hcmspO1xuICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIF9yZWYxKSA8IDApIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zY2FuX2RpcmVjdGl2ZV9pZ25vcmVkX2xpbmUoc3RhcnRfbWFyayk7XG4gICAgICByZXR1cm4gbmV3IHRva2Vucy5EaXJlY3RpdmVUb2tlbihuYW1lLCB2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2RpcmVjdGl2ZV9uYW1lID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIGxlbmd0aCwgdmFsdWU7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgd2hpbGUgKCgnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc5JykgfHwgKCdBJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1onKSB8fCAoJ2EnIDw9IGNoYXIgJiYgY2hhciA8PSAneicpIHx8IF9faW5kZXhPZi5jYWxsKCctXycsIGNoYXIpID49IDApIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYWxwaGFudW1lcmljIG9yIG51bWVyaWMgY2hhcmFjdGVyIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRoaXMucHJlZml4KGxlbmd0aCk7XG4gICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwICcsIGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhbHBoYW51bWVyaWMgb3IgbnVtZXJpYyBjaGFyYWN0ZXIgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl95YW1sX2RpcmVjdGl2ZV92YWx1ZSA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBtYWpvciwgbWlub3IsIF9yZWYxO1xuICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgICBtYWpvciA9IHRoaXMuc2Nhbl95YW1sX2RpcmVjdGl2ZV9udW1iZXIoc3RhcnRfbWFyayk7XG4gICAgICBpZiAodGhpcy5wZWVrKCkgIT09ICcuJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIGRpZ2l0IG9yICcuJyBidXQgZm91bmQgXCIgKyAodGhpcy5wZWVrKCkpLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICBtaW5vciA9IHRoaXMuc2Nhbl95YW1sX2RpcmVjdGl2ZV9udW1iZXIoc3RhcnRfbWFyayk7XG4gICAgICBpZiAoX3JlZjEgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBfcmVmMSkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgZGlnaXQgb3IgJyAnIGJ1dCBmb3VuZCBcIiArICh0aGlzLnBlZWsoKSksIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW21ham9yLCBtaW5vcl07XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5feWFtbF9kaXJlY3RpdmVfbnVtYmVyID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIGxlbmd0aCwgdmFsdWUsIF9yZWYxO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKCEoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBkaWdpdCBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIHdoaWxlICgoJzAnIDw9IChfcmVmMSA9IHRoaXMucGVlayhsZW5ndGgpKSAmJiBfcmVmMSA8PSAnOScpKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJzZUludCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3RhZ19kaXJlY3RpdmVfdmFsdWUgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG4gICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZSA9IHRoaXMuc2Nhbl90YWdfZGlyZWN0aXZlX2hhbmRsZShzdGFydF9tYXJrKTtcbiAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgICAgcHJlZml4ID0gdGhpcy5zY2FuX3RhZ19kaXJlY3RpdmVfcHJlZml4KHN0YXJ0X21hcmspO1xuICAgICAgcmV0dXJuIFtoYW5kbGUsIHByZWZpeF07XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdGFnX2RpcmVjdGl2ZV9oYW5kbGUgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgdmFsdWU7XG4gICAgICB2YWx1ZSA9IHRoaXMuc2Nhbl90YWdfaGFuZGxlKCdkaXJlY3RpdmUnLCBzdGFydF9tYXJrKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgJyAnIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdGFnX2RpcmVjdGl2ZV9wcmVmaXggPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgdmFsdWU7XG4gICAgICB2YWx1ZSA9IHRoaXMuc2Nhbl90YWdfdXJpKCdkaXJlY3RpdmUnLCBzdGFydF9tYXJrKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwICcsIGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCAnICcgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9kaXJlY3RpdmVfaWdub3JlZF9saW5lID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIF9yZWYxO1xuICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZWVrKCkgPT09ICcjJykge1xuICAgICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIF9yZWYxKSA8IDApIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBjb21tZW50IG9yIGEgbGluZSBicmVhayBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2Nhbl9saW5lX2JyZWFrKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVGhlIHNwZWNpZmljYXRpb24gZG9lcyBub3QgcmVzdHJpY3QgY2hhcmFjdGVycyBmb3IgYW5jaG9ycyBhbmQgYWxpYXNlcy5cbiAgICBUaGlzIG1heSBsZWFkIHRvIHByb2JsZW1zLCBmb3IgaW5zdGFuY2UsIHRoZSBkb2N1bWVudDpcbiAgICAgIFsgKmFsaWFzLCB2YWx1ZSBdXG4gICAgY2FuIGJlIGludGVycHRldGVkIGluIHR3byB3YXlzLCBhc1xuICAgICAgWyBcInZhbHVlXCIgXVxuICAgIGFuZFxuICAgICAgWyAqYWxpYXMgLCBcInZhbHVlXCIgXVxuICAgIFRoZXJlZm9yZSB3ZSByZXN0cmljdCBhbGlhc2VzIHRvIG51bWJlcnMgYW5kIEFTQ0lJIGxldHRlcnMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9hbmNob3IgPSBmdW5jdGlvbihUb2tlbkNsYXNzKSB7XG4gICAgICB2YXIgY2hhciwgaW5kaWNhdG9yLCBsZW5ndGgsIG5hbWUsIHN0YXJ0X21hcmssIHZhbHVlO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIGluZGljYXRvciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKGluZGljYXRvciA9PT0gJyonKSB7XG4gICAgICAgIG5hbWUgPSAnYWxpYXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9ICdhbmNob3InO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgd2hpbGUgKCgnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc5JykgfHwgKCdBJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1onKSB8fCAoJ2EnIDw9IGNoYXIgJiYgY2hhciA8PSAneicpIHx8IF9faW5kZXhPZi5jYWxsKCctXycsIGNoYXIpID49IDApIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKFwid2hpbGUgc2Nhbm5pbmcgYW4gXCIgKyBuYW1lLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGFscGhhYmV0aWMgb3IgbnVtZXJpYyBjaGFyYWN0ZXIgYnV0IGZvdW5kICdcIiArIGNoYXIgKyBcIidcIiwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdGhpcy5wcmVmaXgobGVuZ3RoKTtcbiAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJyArICc/OixdfSVAYCcsIGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoXCJ3aGlsZSBzY2FubmluZyBhbiBcIiArIG5hbWUsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYWxwaGFiZXRpYyBvciBudW1lcmljIGNoYXJhY3RlciBidXQgZm91bmQgJ1wiICsgY2hhciArIFwiJ1wiLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUb2tlbkNsYXNzKHZhbHVlLCBzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3RhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXIsIGhhbmRsZSwgbGVuZ3RoLCBzdGFydF9tYXJrLCBzdWZmaXgsIHVzZV9oYW5kbGU7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygxKTtcbiAgICAgIGlmIChjaGFyID09PSAnPCcpIHtcbiAgICAgICAgaGFuZGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3J3YXJkKDIpO1xuICAgICAgICBzdWZmaXggPSB0aGlzLnNjYW5fdGFnX3VyaSgndGFnJywgc3RhcnRfbWFyayk7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSAhPT0gJz4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBwYXJzaW5nIGEgdGFnJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCAnPicgYnV0IGZvdW5kIFwiICsgKHRoaXMucGVlaygpKSwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGhhbmRsZSA9IG51bGw7XG4gICAgICAgIHN1ZmZpeCA9ICchJztcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB1c2VfaGFuZGxlID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwICcsIGNoYXIpIDwgMCkge1xuICAgICAgICAgIGlmIChjaGFyID09PSAnIScpIHtcbiAgICAgICAgICAgIHVzZV9oYW5kbGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlX2hhbmRsZSkge1xuICAgICAgICAgIGhhbmRsZSA9IHRoaXMuc2Nhbl90YWdfaGFuZGxlKCd0YWcnLCBzdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGUgPSAnISc7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VmZml4ID0gdGhpcy5zY2FuX3RhZ191cmkoJ3RhZycsIHN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSB0YWcnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkICcgJyBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0b2tlbnMuVGFnVG9rZW4oW2hhbmRsZSwgc3VmZml4XSwgc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9ibG9ja19zY2FsYXIgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdmFyIGJyZWFrcywgY2hvbXBpbmcsIGNodW5rcywgZW5kX21hcmssIGZvbGRlZCwgaW5jcmVtZW50LCBpbmRlbnQsIGxlYWRpbmdfbm9uX3NwYWNlLCBsZW5ndGgsIGxpbmVfYnJlYWssIG1heF9pbmRlbnQsIG1pbl9pbmRlbnQsIHN0YXJ0X21hcmssIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0LCBfcmVmNSwgX3JlZjYsIF9yZWY3O1xuICAgICAgZm9sZGVkID0gc3R5bGUgPT09ICc+JztcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgX3JlZjEgPSB0aGlzLnNjYW5fYmxvY2tfc2NhbGFyX2luZGljYXRvcnMoc3RhcnRfbWFyayksIGNob21waW5nID0gX3JlZjFbMF0sIGluY3JlbWVudCA9IF9yZWYxWzFdO1xuICAgICAgdGhpcy5zY2FuX2Jsb2NrX3NjYWxhcl9pZ25vcmVkX2xpbmUoc3RhcnRfbWFyayk7XG4gICAgICBtaW5faW5kZW50ID0gdGhpcy5pbmRlbnQgKyAxO1xuICAgICAgaWYgKG1pbl9pbmRlbnQgPCAxKSB7XG4gICAgICAgIG1pbl9pbmRlbnQgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKGluY3JlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIF9yZWYyID0gdGhpcy5zY2FuX2Jsb2NrX3NjYWxhcl9pbmRlbnRhdGlvbigpLCBicmVha3MgPSBfcmVmMlswXSwgbWF4X2luZGVudCA9IF9yZWYyWzFdLCBlbmRfbWFyayA9IF9yZWYyWzJdO1xuICAgICAgICBpbmRlbnQgPSBNYXRoLm1heChtaW5faW5kZW50LCBtYXhfaW5kZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudCA9IG1pbl9pbmRlbnQgKyBpbmNyZW1lbnQgLSAxO1xuICAgICAgICBfcmVmMyA9IHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfYnJlYWtzKGluZGVudCksIGJyZWFrcyA9IF9yZWYzWzBdLCBlbmRfbWFyayA9IF9yZWYzWzFdO1xuICAgICAgfVxuICAgICAgbGluZV9icmVhayA9ICcnO1xuICAgICAgd2hpbGUgKHRoaXMuY29sdW1uID09PSBpbmRlbnQgJiYgdGhpcy5wZWVrKCkgIT09ICdcXHgwMCcpIHtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChicmVha3MpO1xuICAgICAgICBsZWFkaW5nX25vbl9zcGFjZSA9IChfcmVmNCA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbCgnIFxcdCcsIF9yZWY0KSA8IDApO1xuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoX3JlZjUgPSB0aGlzLnBlZWsobGVuZ3RoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIF9yZWY1KSA8IDApIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBjaHVua3MucHVzaCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgIGxpbmVfYnJlYWsgPSB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgICAgICBfcmVmNiA9IHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfYnJlYWtzKGluZGVudCksIGJyZWFrcyA9IF9yZWY2WzBdLCBlbmRfbWFyayA9IF9yZWY2WzFdO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4gPT09IGluZGVudCAmJiB0aGlzLnBlZWsoKSAhPT0gJ1xceDAwJykge1xuICAgICAgICAgIGlmIChmb2xkZWQgJiYgbGluZV9icmVhayA9PT0gJ1xcbicgJiYgbGVhZGluZ19ub25fc3BhY2UgJiYgKF9yZWY3ID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKCcgXFx0JywgX3JlZjcpIDwgMCkpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzX2VtcHR5KGJyZWFrcykpIHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2gobGluZV9icmVhayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hvbXBpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGxpbmVfYnJlYWspO1xuICAgICAgfVxuICAgICAgaWYgKGNob21waW5nID09PSB0cnVlKSB7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQoYnJlYWtzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdG9rZW5zLlNjYWxhclRva2VuKGNodW5rcy5qb2luKCcnKSwgZmFsc2UsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBzdHlsZSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fYmxvY2tfc2NhbGFyX2luZGljYXRvcnMgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgY2hvbXBpbmcsIGluY3JlbWVudDtcbiAgICAgIGNob21waW5nID0gbnVsbDtcbiAgICAgIGluY3JlbWVudCA9IG51bGw7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoJystJywgY2hhcikgPj0gMCkge1xuICAgICAgICBjaG9tcGluZyA9IGNoYXIgPT09ICcrJztcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTlVNQkVSUywgY2hhcikgPj0gMCkge1xuICAgICAgICAgIGluY3JlbWVudCA9IHBhcnNlSW50KGNoYXIpO1xuICAgICAgICAgIGlmIChpbmNyZW1lbnQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBibG9jayBzY2FsYXInLCBzdGFydF9tYXJrLCAnZXhwZWN0ZWQgaW5kZW50YXRpb24gaW5kaWNhdG9yIGluIHRoZSByYW5nZSAxLTkgYnV0IGZvdW5kIDAnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfX2luZGV4T2YuY2FsbChDX05VTUJFUlMsIGNoYXIpID49IDApIHtcbiAgICAgICAgaW5jcmVtZW50ID0gcGFyc2VJbnQoY2hhcik7XG4gICAgICAgIGlmIChpbmNyZW1lbnQgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgYmxvY2sgc2NhbGFyJywgc3RhcnRfbWFyaywgJ2V4cGVjdGVkIGluZGVudGF0aW9uIGluZGljYXRvciBpbiB0aGUgcmFuZ2UgMS05IGJ1dCBmb3VuZCAwJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoJystJywgY2hhcikgPj0gMCkge1xuICAgICAgICAgIGNob21waW5nID0gY2hhciA9PT0gJysnO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGJsb2NrIHNjYWxhcicsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgY2hvbXBpbmcgb3IgaW5kZW50YXRpb24gaW5kaWNhdG9ycywgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbY2hvbXBpbmcsIGluY3JlbWVudF07XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fYmxvY2tfc2NhbGFyX2lnbm9yZWRfbGluZSA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBfcmVmMTtcbiAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVlaygpID09PSAnIycpIHtcbiAgICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCBfcmVmMSkgPCAwKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBibG9jayBzY2FsYXInLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgY29tbWVudCBvciBhIGxpbmUgYnJlYWsgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Jsb2NrX3NjYWxhcl9pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNodW5rcywgZW5kX21hcmssIG1heF9pbmRlbnQsIF9yZWYxO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBtYXhfaW5kZW50ID0gMDtcbiAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnICcsIF9yZWYxKSA+PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSAhPT0gJyAnKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5zY2FuX2xpbmVfYnJlYWsoKSk7XG4gICAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgaWYgKHRoaXMuY29sdW1uID4gbWF4X2luZGVudCkge1xuICAgICAgICAgICAgbWF4X2luZGVudCA9IHRoaXMuY29sdW1uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtjaHVua3MsIG1heF9pbmRlbnQsIGVuZF9tYXJrXTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9ibG9ja19zY2FsYXJfYnJlYWtzID0gZnVuY3Rpb24oaW5kZW50KSB7XG4gICAgICB2YXIgY2h1bmtzLCBlbmRfbWFyaywgX3JlZjE7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgd2hpbGUgKHRoaXMuY29sdW1uIDwgaW5kZW50ICYmIHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiwgX3JlZjEpID49IDApIHtcbiAgICAgICAgY2h1bmtzLnB1c2godGhpcy5zY2FuX2xpbmVfYnJlYWsoKSk7XG4gICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICB3aGlsZSAodGhpcy5jb2x1bW4gPCBpbmRlbnQgJiYgdGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NodW5rcywgZW5kX21hcmtdO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICBOb3RlIHRoYXQgd2UgbG9vc2UgaW5kZW50YXRpb24gcnVsZXMgZm9yIHF1b3RlZCBzY2FsYXJzLiBRdW90ZWQgc2NhbGFyc1xuICAgIGRvbid0IG5lZWQgdG8gYWRoZXJlIGluZGVudGF0aW9uIGJlY2F1c2UgXCIgYW5kICcgY2xlYXJseSBtYXJrIHRoZSBiZWdpbm5pbmdcbiAgICBhbmQgdGhlIGVuZCBvZiB0aGVtLiBUaGVyZWZvcmUgd2UgYXJlIGxlc3MgcmVzdHJpY3RpdmUgdGhhbiB0aGVcbiAgICBzcGVjaWZpY2F0aW9uIHJlcXVpcmVzLiBXZSBvbmx5IG5lZWQgdG8gY2hlY2sgdGhhdCBkb2N1bWVudCBzZXBhcmF0b3JzIGFyZVxuICAgIG5vdCBpbmNsdWRlZCBpbiBzY2FsYXJzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fZmxvd19zY2FsYXIgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdmFyIGNodW5rcywgZG91YmxlLCBxdW90ZSwgc3RhcnRfbWFyaztcbiAgICAgIGRvdWJsZSA9IHN0eWxlID09PSAnXCInO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgcXVvdGUgPSB0aGlzLnBlZWsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdCh0aGlzLnNjYW5fZmxvd19zY2FsYXJfbm9uX3NwYWNlcyhkb3VibGUsIHN0YXJ0X21hcmspKTtcbiAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSAhPT0gcXVvdGUpIHtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdCh0aGlzLnNjYW5fZmxvd19zY2FsYXJfc3BhY2VzKGRvdWJsZSwgc3RhcnRfbWFyaykpO1xuICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KHRoaXMuc2Nhbl9mbG93X3NjYWxhcl9ub25fc3BhY2VzKGRvdWJsZSwgc3RhcnRfbWFyaykpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICByZXR1cm4gbmV3IHRva2Vucy5TY2FsYXJUb2tlbihjaHVua3Muam9pbignJyksIGZhbHNlLCBzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCksIHN0eWxlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9mbG93X3NjYWxhcl9ub25fc3BhY2VzID0gZnVuY3Rpb24oZG91YmxlLCBzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgY2h1bmtzLCBjb2RlLCBrLCBsZW5ndGgsIF9pLCBfcmVmMSwgX3JlZjI7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlayhsZW5ndGgpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXCdcIlxcXFxcXHgwMCcsIF9yZWYxKSA8IDApIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoIWRvdWJsZSAmJiBjaGFyID09PSAnXFwnJyAmJiB0aGlzLnBlZWsoMSkgPT09ICdcXCcnKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goJ1xcJycpO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgyKTtcbiAgICAgICAgfSBlbHNlIGlmICgoZG91YmxlICYmIGNoYXIgPT09ICdcXCcnKSB8fCAoIWRvdWJsZSAmJiBfX2luZGV4T2YuY2FsbCgnXCJcXFxcJywgY2hhcikgPj0gMCkpIHtcbiAgICAgICAgICBjaHVua3MucHVzaChjaGFyKTtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb3VibGUgJiYgY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICAgIGlmIChjaGFyIGluIEVTQ0FQRV9SRVBMQUNFTUVOVFMpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKEVTQ0FQRV9SRVBMQUNFTUVOVFNbY2hhcl0pO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyIGluIEVTQ0FQRV9DT0RFUykge1xuICAgICAgICAgICAgbGVuZ3RoID0gRVNDQVBFX0NPREVTW2NoYXJdO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgICBmb3IgKGsgPSBfaSA9IDA7IDAgPD0gbGVuZ3RoID8gX2kgPCBsZW5ndGggOiBfaSA+IGxlbmd0aDsgayA9IDAgPD0gbGVuZ3RoID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgICAgICAgaWYgKF9yZWYyID0gdGhpcy5wZWVrKGspLCBfX2luZGV4T2YuY2FsbChDX05VTUJFUlMgKyAnQUJDREVGYWJjZGVmJywgX3JlZjIpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkb3VibGUtcXVvdGVkIHNjYWxhcicsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgZXNjYXBlIHNlcXVlbmNlIG9mIFwiICsgbGVuZ3RoICsgXCIgaGV4YWRlY2ltYWwgbnVtYmVycywgYnV0IGZvdW5kIFwiICsgKHRoaXMucGVlayhrKSksIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSBwYXJzZUludCh0aGlzLnByZWZpeChsZW5ndGgpLCAxNik7XG4gICAgICAgICAgICBjaHVua3MucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiwgY2hhcikgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQodGhpcy5zY2FuX2Zsb3dfc2NhbGFyX2JyZWFrcyhkb3VibGUsIHN0YXJ0X21hcmspKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRvdWJsZS1xdW90ZWQgc2NhbGFyJywgc3RhcnRfbWFyaywgXCJmb3VuZCB1bmtub3duIGVzY2FwZSBjaGFyYWN0ZXIgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2h1bmtzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fZmxvd19zY2FsYXJfc3BhY2VzID0gZnVuY3Rpb24oZG91YmxlLCBzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgYnJlYWtzLCBjaGFyLCBjaHVua3MsIGxlbmd0aCwgbGluZV9icmVhaywgd2hpdGVzcGFjZXMsIF9yZWYxO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKGxlbmd0aCksIF9faW5kZXhPZi5jYWxsKENfV1MsIF9yZWYxKSA+PSAwKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgfVxuICAgICAgd2hpdGVzcGFjZXMgPSB0aGlzLnByZWZpeChsZW5ndGgpO1xuICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoY2hhciA9PT0gJ1xceDAwJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgcXVvdGVkIHNjYWxhcicsIHN0YXJ0X21hcmssICdmb3VuZCB1bmV4cGVjdGVkIGVuZCBvZiBzdHJlYW0nLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIsIGNoYXIpID49IDApIHtcbiAgICAgICAgbGluZV9icmVhayA9IHRoaXMuc2Nhbl9saW5lX2JyZWFrKCk7XG4gICAgICAgIGJyZWFrcyA9IHRoaXMuc2Nhbl9mbG93X3NjYWxhcl9icmVha3MoZG91YmxlLCBzdGFydF9tYXJrKTtcbiAgICAgICAgaWYgKGxpbmVfYnJlYWsgIT09ICdcXG4nKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2gobGluZV9icmVhayk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWJyZWFrcykge1xuICAgICAgICAgIGNodW5rcy5wdXNoKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChicmVha3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmtzLnB1c2god2hpdGVzcGFjZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9mbG93X3NjYWxhcl9icmVha3MgPSBmdW5jdGlvbihkb3VibGUsIHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaHVua3MsIHByZWZpeCwgX3JlZjEsIF9yZWYyLCBfcmVmMztcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5wcmVmaXgoMyk7XG4gICAgICAgIGlmIChwcmVmaXggPT09ICctLS0nIHx8IHByZWZpeCA9PT0gJy4uLicgJiYgKF9yZWYxID0gdGhpcy5wZWVrKDMpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA+PSAwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBxdW90ZWQgc2NhbGFyJywgc3RhcnRfbWFyaywgJ2ZvdW5kIHVuZXhwZWN0ZWQgZG9jdW1lbnQgc2VwYXJhdG9yJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoX3JlZjIgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19XUywgX3JlZjIpID49IDApIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3JlZjMgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiwgX3JlZjMpID49IDApIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnNjYW5fbGluZV9icmVhaygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2h1bmtzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgIFdlIGFkZCBhbiBhZGRpdGlvbmFsIHJlc3RyaWN0aW9uIGZvciB0aGUgZmxvdyBjb250ZXh0OlxuICAgICAgcGxhaW4gc2NhbGFycyBpbiB0aGUgZmxvdyBjb250ZXh0IGNhbm5vdCBjb250YWluICcsJywgJzonIGFuZCAnPycuXG4gICAgV2UgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBgYWxsb3dfc2ltcGxlX2tleWAgZmxhZyBoZXJlLlxuICAgIEluZGVudGF0aW9uIHJ1bGVzIGFyZSBsb29zZWQgZm9yIHRoZSBmbG93IGNvbnRleHQuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9wbGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXIsIGNodW5rcywgZW5kX21hcmssIGluZGVudCwgbGVuZ3RoLCBzcGFjZXMsIHN0YXJ0X21hcmssIF9yZWYxLCBfcmVmMjtcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgc3RhcnRfbWFyayA9IGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgaW5kZW50ID0gdGhpcy5pbmRlbnQgKyAxO1xuICAgICAgc3BhY2VzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09ICcjJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIGNoYXIpID49IDAgfHwgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCAmJiBjaGFyID09PSAnOicgJiYgKF9yZWYxID0gdGhpcy5wZWVrKGxlbmd0aCArIDEpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA+PSAwKSkgfHwgKHRoaXMuZmxvd19sZXZlbCAhPT0gMCAmJiBfX2luZGV4T2YuY2FsbCgnLDo/W117fScsIGNoYXIpID49IDApKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCAhPT0gMCAmJiBjaGFyID09PSAnOicgJiYgKF9yZWYyID0gdGhpcy5wZWVrKGxlbmd0aCArIDEpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCxbXXt9JywgX3JlZjIpIDwgMCkpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgcGxhaW4gc2NhbGFyJywgc3RhcnRfbWFyaywgJ2ZvdW5kIHVuZXhwZWN0ZWQgXFwnOlxcJycsIHRoaXMuZ2V0X21hcmsoKSwgJ1BsZWFzZSBjaGVjayBodHRwOi8vcHl5YW1sLm9yZy93aWtpL1lBTUxDb2xvbkluRmxvd0NvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQoc3BhY2VzKTtcbiAgICAgICAgY2h1bmtzLnB1c2godGhpcy5wcmVmaXgobGVuZ3RoKSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgc3BhY2VzID0gdGhpcy5zY2FuX3BsYWluX3NwYWNlcyhpbmRlbnQsIHN0YXJ0X21hcmspO1xuICAgICAgICBpZiAoKHNwYWNlcyA9PSBudWxsKSB8fCBzcGFjZXMubGVuZ3RoID09PSAwIHx8IHRoaXMucGVlaygpID09PSAnIycgfHwgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCAmJiB0aGlzLmNvbHVtbiA8IGluZGVudCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0b2tlbnMuU2NhbGFyVG9rZW4oY2h1bmtzLmpvaW4oJycpLCB0cnVlLCBzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgIFRoZSBzcGVjaWZpY2F0aW9uIGlzIHJlYWxseSBjb25mdXNpbmcgYWJvdXQgdGFicyBpbiBwbGFpbiBzY2FsYXJzLlxuICAgIFdlIGp1c3QgZm9yYmlkIHRoZW0gY29tcGxldGVseS4gRG8gbm90IHVzZSB0YWJzIGluIFlBTUwhXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9wbGFpbl9zcGFjZXMgPSBmdW5jdGlvbihpbmRlbnQsIHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBicmVha3MsIGNoYXIsIGNodW5rcywgbGVuZ3RoLCBsaW5lX2JyZWFrLCBwcmVmaXgsIHdoaXRlc3BhY2VzLCBfcmVmMSwgX3JlZjI7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsobGVuZ3RoKSwgX19pbmRleE9mLmNhbGwoJyAnLCBfcmVmMSkgPj0gMCkge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgIH1cbiAgICAgIHdoaXRlc3BhY2VzID0gdGhpcy5wcmVmaXgobGVuZ3RoKTtcbiAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIsIGNoYXIpID49IDApIHtcbiAgICAgICAgbGluZV9icmVhayA9IHRoaXMuc2Nhbl9saW5lX2JyZWFrKCk7XG4gICAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWU7XG4gICAgICAgIHByZWZpeCA9IHRoaXMucHJlZml4KDMpO1xuICAgICAgICBpZiAocHJlZml4ID09PSAnLS0tJyB8fCBwcmVmaXggPT09ICcuLi4nICYmIHRoaXMucGVlayhfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIDMpID49IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrcyA9IFtdO1xuICAgICAgICB3aGlsZSAoX3JlZjIgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICcgJywgX3JlZjIpID49IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrcy5wdXNoKHRoaXMuc2Nhbl9saW5lX2JyZWFrKCkpO1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5wcmVmaXgoMyk7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSAnLS0tJyB8fCBwcmVmaXggPT09ICcuLi4nICYmIHRoaXMucGVlayhfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIDMpID49IDApKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVfYnJlYWsgIT09ICdcXG4nKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2gobGluZV9icmVhayk7XG4gICAgICAgIH0gZWxzZSBpZiAoYnJlYWtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChicmVha3MpO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlcykge1xuICAgICAgICBjaHVua3MucHVzaCh3aGl0ZXNwYWNlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICBGb3Igc29tZSBzdHJhbmdlIHJlYXNvbnMsIHRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGFsbG93ICdfJyBpbiB0YWdcbiAgICBoYW5kbGVzLiBJIGhhdmUgYWxsb3dlZCBpdCBhbnl3YXkuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl90YWdfaGFuZGxlID0gZnVuY3Rpb24obmFtZSwgc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIGxlbmd0aCwgdmFsdWU7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoY2hhciAhPT0gJyEnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihcIndoaWxlIHNjYW5uaW5nIGEgXCIgKyBuYW1lLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkICchJyBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgd2hpbGUgKCgnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc5JykgfHwgKCdBJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1onKSB8fCAoJ2EnIDw9IGNoYXIgJiYgY2hhciA8PSAneicpIHx8IF9faW5kZXhPZi5jYWxsKCctXycsIGNoYXIpID49IDApIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgIT09ICchJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihcIndoaWxlIHNjYW5uaW5nIGEgXCIgKyBuYW1lLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkICchJyBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0aGlzLnByZWZpeChsZW5ndGgpO1xuICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgIE5vdGU6IHdlIGRvIG5vdCBjaGVjayBpZiBVUkkgaXMgd2VsbC1mb3JtZWQuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl90YWdfdXJpID0gZnVuY3Rpb24obmFtZSwgc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIGNodW5rcywgbGVuZ3RoO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgd2hpbGUgKCgnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc5JykgfHwgKCdBJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1onKSB8fCAoJ2EnIDw9IGNoYXIgJiYgY2hhciA8PSAneicpIHx8IF9faW5kZXhPZi5jYWxsKCctOy8/OkAmPSskLF8uIX4qXFwnKClbXSUnLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGlmIChjaGFyID09PSAnJScpIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMuc2Nhbl91cmlfZXNjYXBlcyhuYW1lLCBzdGFydF9tYXJrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjaHVua3MucHVzaCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoXCJ3aGlsZSBwYXJzaW5nIGEgXCIgKyBuYW1lLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIFVSSSBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNodW5rcy5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl91cmlfZXNjYXBlcyA9IGZ1bmN0aW9uKG5hbWUsIHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBieXRlcywgaywgbWFyaywgX2k7XG4gICAgICBieXRlcyA9IFtdO1xuICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyUnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICBmb3IgKGsgPSBfaSA9IDA7IF9pIDw9IDI7IGsgPSArK19pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKFwid2hpbGUgc2Nhbm5pbmcgYSBcIiArIG5hbWUsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgVVJJIGVzY2FwZSBzZXF1ZW5jZSBvZiAyIGhleGFkZWNpbWFsIG51bWJlcnMgYnV0IGZvdW5kICAgICAgICAgIFwiICsgKHRoaXMucGVlayhrKSksIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHRoaXMucHJlZml4KDIpLCAxNikpKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFRyYW5zZm9ybXM6XG4gICAgICAnXFxyXFxuJyAgICAgIDogICAnXFxuJ1xuICAgICAgJ1xccicgICAgICAgIDogICAnXFxuJ1xuICAgICAgJ1xcbicgICAgICAgIDogICAnXFxuJ1xuICAgICAgJ1xceDg1JyAgICAgIDogICAnXFxuJ1xuICAgICAgJ1xcdTIwMjgnICAgIDogICAnXFx1MjAyOCdcbiAgICAgICdcXHUyMDI5ICAgICA6ICAgJ1xcdTIwMjknXG4gICAgICBkZWZhdWx0ICAgICA6ICAgJydcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2xpbmVfYnJlYWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFyO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKCdcXHJcXG5cXHg4NScsIGNoYXIpID49IDApIHtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4KDIpID09PSAnXFxyXFxuJykge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1xcbic7XG4gICAgICB9IGVsc2UgaWYgKF9faW5kZXhPZi5jYWxsKCdcXHUyMDI4XFx1MjAyOScsIGNoYXIpID49IDApIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIHJldHVybiBjaGFyO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2Nhbm5lcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBub2RlcywgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIC8qXG4gIFRoZSBTY2hlbWFzIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuU2NoZW1hRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjaGVtYUVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2NoZW1hRXJyb3IoKSB7XG4gICAgICBfcmVmID0gU2NoZW1hRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gU2NoZW1hRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICAgIFRoZSBTY2hlbWFzIGNsYXNzIGRlYWxzIHdpdGggYXBwbHlpbmcgc2NoZW1hcyB0byByZXNvdXJjZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICovXG5cblxuICB0aGlzLlNjaGVtYXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2NoZW1hcygpIHtcbiAgICAgIHRoaXMuZ2V0X3NjaGVtYXNfdXNlZCA9IF9fYmluZCh0aGlzLmdldF9zY2hlbWFzX3VzZWQsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBseV9zY2hlbWFzID0gX19iaW5kKHRoaXMuYXBwbHlfc2NoZW1hcywgdGhpcyk7XG4gICAgICB0aGlzLmdldF9hbGxfc2NoZW1hcyA9IF9fYmluZCh0aGlzLmdldF9hbGxfc2NoZW1hcywgdGhpcyk7XG4gICAgICB0aGlzLmhhc19zY2hlbWFzID0gX19iaW5kKHRoaXMuaGFzX3NjaGVtYXMsIHRoaXMpO1xuICAgICAgdGhpcy5sb2FkX3NjaGVtYXMgPSBfX2JpbmQodGhpcy5sb2FkX3NjaGVtYXMsIHRoaXMpO1xuICAgICAgdGhpcy5kZWNsYXJlZFNjaGVtYXMgPSB7fTtcbiAgICB9XG5cbiAgICBTY2hlbWFzLnByb3RvdHlwZS5sb2FkX3NjaGVtYXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgYWxsU2NoZW1hcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsIFwic2NoZW1hc1wiKSkge1xuICAgICAgICBhbGxTY2hlbWFzID0gdGhpcy5wcm9wZXJ0eV92YWx1ZShub2RlLCAnc2NoZW1hcycpO1xuICAgICAgICBpZiAoYWxsU2NoZW1hcyAmJiB0eXBlb2YgYWxsU2NoZW1hcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiBhbGxTY2hlbWFzLmZvckVhY2goZnVuY3Rpb24oc2NoZW1hX2VudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hX2VudHJ5ICYmIHR5cGVvZiBzY2hlbWFfZW50cnkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHNjaGVtYV9lbnRyeS52YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICByZXR1cm4gc2NoZW1hX2VudHJ5LnZhbHVlLmZvckVhY2goZnVuY3Rpb24oc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlY2xhcmVkU2NoZW1hc1tzY2hlbWFbMF0udmFsdWVdID0gc2NoZW1hO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBTY2hlbWFzLnByb3RvdHlwZS5oYXNfc2NoZW1hcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmRlY2xhcmVkU2NoZW1hcy5sZW5ndGggPT09IDAgJiYgdGhpcy5oYXNfcHJvcGVydHkobm9kZSwgXCJzY2hlbWFzXCIpKSB7XG4gICAgICAgIHRoaXMubG9hZF9zY2hlbWFzKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGVjbGFyZWRTY2hlbWFzKS5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICBTY2hlbWFzLnByb3RvdHlwZS5nZXRfYWxsX3NjaGVtYXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmVkU2NoZW1hcztcbiAgICB9O1xuXG4gICAgU2NoZW1hcy5wcm90b3R5cGUuYXBwbHlfc2NoZW1hcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZXNvdXJjZXMsIHNjaGVtYXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHJlc291cmNlcyA9IHRoaXMuY2hpbGRfcmVzb3VyY2VzKG5vZGUpO1xuICAgICAgc2NoZW1hcyA9IHRoaXMuZ2V0X3NjaGVtYXNfdXNlZChyZXNvdXJjZXMpO1xuICAgICAgcmV0dXJuIHNjaGVtYXMuZm9yRWFjaChmdW5jdGlvbihzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVsxXS52YWx1ZSBpbiBfdGhpcy5kZWNsYXJlZFNjaGVtYXMpIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hWzFdLnZhbHVlID0gX3RoaXMuZGVjbGFyZWRTY2hlbWFzW3NjaGVtYVsxXS52YWx1ZV1bMV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTY2hlbWFzLnByb3RvdHlwZS5nZXRfc2NoZW1hc191c2VkID0gZnVuY3Rpb24ocmVzb3VyY2VzKSB7XG4gICAgICB2YXIgc2NoZW1hcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgc2NoZW1hcyA9IFtdO1xuICAgICAgcmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXM7XG4gICAgICAgIHByb3BlcnRpZXMgPSBfdGhpcy5nZXRfcHJvcGVydGllcyhyZXNvdXJjZVsxXSwgXCJzY2hlbWFcIik7XG4gICAgICAgIHJldHVybiBzY2hlbWFzID0gc2NoZW1hcy5jb25jYXQocHJvcGVydGllcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzY2hlbWFzO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2NoZW1hcztcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBub2RlcywgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIC8qXG4gIFRoZSBTY2hlbWFzIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuU2VjdXJpdHlTY2hlbWVFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VjdXJpdHlTY2hlbWVFcnJvciwgX3N1cGVyKTtcblxuICAgIC8qXG4gICAgICBUaGUgU2NoZW1hcyBjbGFzcyBkZWFscyB3aXRoIGFwcGx5aW5nIHNjaGVtYXMgdG8gcmVzb3VyY2VzIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIFNlY3VyaXR5U2NoZW1lRXJyb3IoKSB7XG4gICAgICBfcmVmID0gU2VjdXJpdHlTY2hlbWVFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBTZWN1cml0eVNjaGVtZUVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgdGhpcy5TZWN1cml0eVNjaGVtZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2VjdXJpdHlTY2hlbWVzKCkge1xuICAgICAgdGhpcy5nZXRfc2VjdXJpdHlfc2NoZW1lID0gX19iaW5kKHRoaXMuZ2V0X3NlY3VyaXR5X3NjaGVtZSwgdGhpcyk7XG4gICAgICB0aGlzLmdldF9hbGxfc2NoZW1lcyA9IF9fYmluZCh0aGlzLmdldF9hbGxfc2NoZW1lcywgdGhpcyk7XG4gICAgICB0aGlzLmxvYWRfc2VjdXJpdHlfc2NoZW1lcyA9IF9fYmluZCh0aGlzLmxvYWRfc2VjdXJpdHlfc2NoZW1lcywgdGhpcyk7XG4gICAgICB0aGlzLmRlY2xhcmVkU2NoZW1lcyA9IHt9O1xuICAgIH1cblxuICAgIFNlY3VyaXR5U2NoZW1lcy5wcm90b3R5cGUubG9hZF9zZWN1cml0eV9zY2hlbWVzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGFsbHNjaGVtZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShub2RlLCBcInNlY3VyaXR5U2NoZW1lc1wiKSkge1xuICAgICAgICBhbGxzY2hlbWVzID0gdGhpcy5wcm9wZXJ0eV92YWx1ZShub2RlLCAnc2VjdXJpdHlTY2hlbWVzJyk7XG4gICAgICAgIGlmIChhbGxzY2hlbWVzICYmIHR5cGVvZiBhbGxzY2hlbWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGFsbHNjaGVtZXMuZm9yRWFjaChmdW5jdGlvbihzY2hlbWVfZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWVfZW50cnkudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWFwJykge1xuICAgICAgICAgICAgICByZXR1cm4gc2NoZW1lX2VudHJ5LnZhbHVlLmZvckVhY2goZnVuY3Rpb24oc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlY2xhcmVkU2NoZW1lc1tzY2hlbWVbMF0udmFsdWVdID0gc2NoZW1lWzFdLnZhbHVlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWN1cml0eVNjaGVtZXMucHJvdG90eXBlLmdldF9hbGxfc2NoZW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyZWRTY2hlbWVzO1xuICAgIH07XG5cbiAgICBTZWN1cml0eVNjaGVtZXMucHJvdG90eXBlLmdldF9zZWN1cml0eV9zY2hlbWUgPSBmdW5jdGlvbihzY2hlbWFOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJlZFNjaGVtZXNbc2NoZW1hTmFtZV07XG4gICAgfTtcblxuICAgIHJldHVybiBTZWN1cml0eVNjaGVtZXM7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIF9yZWYsIF9yZWYxLCBfcmVmMTAsIF9yZWYxMSwgX3JlZjEyLCBfcmVmMTMsIF9yZWYyLCBfcmVmMywgX3JlZjQsIF9yZWY1LCBfcmVmNiwgX3JlZjcsIF9yZWY4LCBfcmVmOSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICB0aGlzLlRva2VuID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuKHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBUb2tlbjtcblxuICB9KSgpO1xuXG4gIHRoaXMuRGlyZWN0aXZlVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpcmVjdGl2ZVRva2VuLCBfc3VwZXIpO1xuXG4gICAgRGlyZWN0aXZlVG9rZW4ucHJvdG90eXBlLmlkID0gJzxkaXJlY3RpdmU+JztcblxuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVRva2VuKG5hbWUsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIERpcmVjdGl2ZVRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuRG9jdW1lbnRTdGFydFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb2N1bWVudFN0YXJ0VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBEb2N1bWVudFN0YXJ0VG9rZW4oKSB7XG4gICAgICBfcmVmID0gRG9jdW1lbnRTdGFydFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgRG9jdW1lbnRTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICc8ZG9jdW1lbnQgc3RhcnQ+JztcblxuICAgIHJldHVybiBEb2N1bWVudFN0YXJ0VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5Eb2N1bWVudEVuZFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb2N1bWVudEVuZFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRFbmRUb2tlbigpIHtcbiAgICAgIF9yZWYxID0gRG9jdW1lbnRFbmRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICBEb2N1bWVudEVuZFRva2VuLnByb3RvdHlwZS5pZCA9ICc8ZG9jdW1lbnQgZW5kPic7XG5cbiAgICByZXR1cm4gRG9jdW1lbnRFbmRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLlN0cmVhbVN0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmVhbVN0YXJ0VG9rZW4sIF9zdXBlcik7XG5cbiAgICBTdHJlYW1TdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICc8c3RyZWFtIHN0YXJ0Pic7XG5cbiAgICBmdW5jdGlvbiBTdHJlYW1TdGFydFRva2VuKHN0YXJ0X21hcmssIGVuZF9tYXJrLCBlbmNvZGluZykge1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtU3RhcnRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLlN0cmVhbUVuZFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJlYW1FbmRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFN0cmVhbUVuZFRva2VuKCkge1xuICAgICAgX3JlZjIgPSBTdHJlYW1FbmRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMjtcbiAgICB9XG5cbiAgICBTdHJlYW1FbmRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPHN0cmVhbSBlbmQ+JztcblxuICAgIHJldHVybiBTdHJlYW1FbmRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkJsb2NrU2VxdWVuY2VTdGFydFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja1NlcXVlbmNlU3RhcnRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEJsb2NrU2VxdWVuY2VTdGFydFRva2VuKCkge1xuICAgICAgX3JlZjMgPSBCbG9ja1NlcXVlbmNlU3RhcnRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMztcbiAgICB9XG5cbiAgICBCbG9ja1NlcXVlbmNlU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGJsb2NrIHNlcXVlbmNlIHN0YXJ0Pic7XG5cbiAgICByZXR1cm4gQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5CbG9ja01hcHBpbmdTdGFydFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja01hcHBpbmdTdGFydFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQmxvY2tNYXBwaW5nU3RhcnRUb2tlbigpIHtcbiAgICAgIF9yZWY0ID0gQmxvY2tNYXBwaW5nU3RhcnRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmNDtcbiAgICB9XG5cbiAgICBCbG9ja01hcHBpbmdTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICc8YmxvY2sgbWFwcGluZyBlbmQ+JztcblxuICAgIHJldHVybiBCbG9ja01hcHBpbmdTdGFydFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuQmxvY2tFbmRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tFbmRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEJsb2NrRW5kVG9rZW4oKSB7XG4gICAgICBfcmVmNSA9IEJsb2NrRW5kVG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjU7XG4gICAgfVxuXG4gICAgQmxvY2tFbmRUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGJsb2NrIGVuZD4nO1xuXG4gICAgcmV0dXJuIEJsb2NrRW5kVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5GbG93U2VxdWVuY2VTdGFydFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGbG93U2VxdWVuY2VTdGFydFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRmxvd1NlcXVlbmNlU3RhcnRUb2tlbigpIHtcbiAgICAgIF9yZWY2ID0gRmxvd1NlcXVlbmNlU3RhcnRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmNjtcbiAgICB9XG5cbiAgICBGbG93U2VxdWVuY2VTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICdbJztcblxuICAgIHJldHVybiBGbG93U2VxdWVuY2VTdGFydFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuRmxvd01hcHBpbmdTdGFydFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGbG93TWFwcGluZ1N0YXJ0VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBGbG93TWFwcGluZ1N0YXJ0VG9rZW4oKSB7XG4gICAgICBfcmVmNyA9IEZsb3dNYXBwaW5nU3RhcnRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmNztcbiAgICB9XG5cbiAgICBGbG93TWFwcGluZ1N0YXJ0VG9rZW4ucHJvdG90eXBlLmlkID0gJ3snO1xuXG4gICAgcmV0dXJuIEZsb3dNYXBwaW5nU3RhcnRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkZsb3dTZXF1ZW5jZUVuZFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGbG93U2VxdWVuY2VFbmRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEZsb3dTZXF1ZW5jZUVuZFRva2VuKCkge1xuICAgICAgX3JlZjggPSBGbG93U2VxdWVuY2VFbmRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmODtcbiAgICB9XG5cbiAgICBGbG93U2VxdWVuY2VFbmRUb2tlbi5wcm90b3R5cGUuaWQgPSAnXSc7XG5cbiAgICByZXR1cm4gRmxvd1NlcXVlbmNlRW5kVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5GbG93TWFwcGluZ0VuZFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGbG93TWFwcGluZ0VuZFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRmxvd01hcHBpbmdFbmRUb2tlbigpIHtcbiAgICAgIF9yZWY5ID0gRmxvd01hcHBpbmdFbmRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmOTtcbiAgICB9XG5cbiAgICBGbG93TWFwcGluZ0VuZFRva2VuLnByb3RvdHlwZS5pZCA9ICd9JztcblxuICAgIHJldHVybiBGbG93TWFwcGluZ0VuZFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuS2V5VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEtleVRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gS2V5VG9rZW4oKSB7XG4gICAgICBfcmVmMTAgPSBLZXlUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTA7XG4gICAgfVxuXG4gICAgS2V5VG9rZW4ucHJvdG90eXBlLmlkID0gJz8nO1xuXG4gICAgcmV0dXJuIEtleVRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuVmFsdWVUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsdWVUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFZhbHVlVG9rZW4oKSB7XG4gICAgICBfcmVmMTEgPSBWYWx1ZVRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxMTtcbiAgICB9XG5cbiAgICBWYWx1ZVRva2VuLnByb3RvdHlwZS5pZCA9ICc6JztcblxuICAgIHJldHVybiBWYWx1ZVRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuQmxvY2tFbnRyeVRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja0VudHJ5VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBCbG9ja0VudHJ5VG9rZW4oKSB7XG4gICAgICBfcmVmMTIgPSBCbG9ja0VudHJ5VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjEyO1xuICAgIH1cblxuICAgIEJsb2NrRW50cnlUb2tlbi5wcm90b3R5cGUuaWQgPSAnLSc7XG5cbiAgICByZXR1cm4gQmxvY2tFbnRyeVRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuRmxvd0VudHJ5VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsb3dFbnRyeVRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRmxvd0VudHJ5VG9rZW4oKSB7XG4gICAgICBfcmVmMTMgPSBGbG93RW50cnlUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTM7XG4gICAgfVxuXG4gICAgRmxvd0VudHJ5VG9rZW4ucHJvdG90eXBlLmlkID0gJywnO1xuXG4gICAgcmV0dXJuIEZsb3dFbnRyeVRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuQWxpYXNUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxpYXNUb2tlbiwgX3N1cGVyKTtcblxuICAgIEFsaWFzVG9rZW4ucHJvdG90eXBlLmlkID0gJzxhbGlhcz4nO1xuXG4gICAgZnVuY3Rpb24gQWxpYXNUb2tlbih2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFsaWFzVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5BbmNob3JUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5jaG9yVG9rZW4sIF9zdXBlcik7XG5cbiAgICBBbmNob3JUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGFuY2hvcj4nO1xuXG4gICAgZnVuY3Rpb24gQW5jaG9yVG9rZW4odmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBBbmNob3JUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLlRhZ1Rva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWdUb2tlbiwgX3N1cGVyKTtcblxuICAgIFRhZ1Rva2VuLnByb3RvdHlwZS5pZCA9ICc8dGFnPic7XG5cbiAgICBmdW5jdGlvbiBUYWdUb2tlbih2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRhZ1Rva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuU2NhbGFyVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhclRva2VuLCBfc3VwZXIpO1xuXG4gICAgU2NhbGFyVG9rZW4ucHJvdG90eXBlLmlkID0gJzxzY2FsYXI+JztcblxuICAgIGZ1bmN0aW9uIFNjYWxhclRva2VuKHZhbHVlLCBwbGFpbiwgc3RhcnRfbWFyaywgZW5kX21hcmssIHN0eWxlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnBsYWluID0gcGxhaW47XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBTY2FsYXJUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgaW5mbGVjdGlvbiwgbm9kZXMsIHV0aWwsIF9yZWYsIF9yZWYxLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIGluZmxlY3Rpb24gPSByZXF1aXJlKCdpbmZsZWN0aW9uJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qXG4gIFRoZSBUcmFpdHMgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5UcmFpdEVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFpdEVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gVHJhaXRFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBUcmFpdEVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRyYWl0RXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICAqL1xuXG5cbiAgdGhpcy5QYXJhbWV0ZXJFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFyYW1ldGVyRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBQYXJhbWV0ZXJFcnJvcigpIHtcbiAgICAgIF9yZWYxID0gUGFyYW1ldGVyRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBhcmFtZXRlckVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgVGhlIFRyYWl0cyBjbGFzcyBkZWFscyB3aXRoIGFwcGx5aW5nIHRyYWl0cyB0byByZXNvdXJjZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICovXG5cblxuICB0aGlzLlRyYWl0cyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBUcmFpdHMoKSB7XG4gICAgICB0aGlzLmRlY2xhcmVkVHJhaXRzID0ge307XG4gICAgfVxuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5sb2FkX3RyYWl0cyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBhbGxUcmFpdHMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShub2RlLCAndHJhaXRzJykpIHtcbiAgICAgICAgYWxsVHJhaXRzID0gdGhpcy5wcm9wZXJ0eV92YWx1ZShub2RlLCAndHJhaXRzJyk7XG4gICAgICAgIGlmIChhbGxUcmFpdHMgJiYgdHlwZW9mIGFsbFRyYWl0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiBhbGxUcmFpdHMuZm9yRWFjaChmdW5jdGlvbih0cmFpdF9pdGVtKSB7XG4gICAgICAgICAgICBpZiAodHJhaXRfaXRlbSAmJiB0eXBlb2YgdHJhaXRfaXRlbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdHJhaXRfaXRlbS52YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhaXRfaXRlbS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlY2xhcmVkVHJhaXRzW3RyYWl0WzBdLnZhbHVlXSA9IHRyYWl0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmhhc190cmFpdHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAodGhpcy5kZWNsYXJlZFRyYWl0cy5sZW5ndGggPT09IDAgJiYgdGhpcy5oYXNfcHJvcGVydHkobm9kZSwgJ3RyYWl0cycpKSB7XG4gICAgICAgIHRoaXMubG9hZF90cmFpdHMobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kZWNsYXJlZFRyYWl0cykubGVuZ3RoID4gMDtcbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5nZXRfdHJhaXQgPSBmdW5jdGlvbih0cmFpdE5hbWUpIHtcbiAgICAgIGlmICh0cmFpdE5hbWUgaW4gdGhpcy5kZWNsYXJlZFRyYWl0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNsYXJlZFRyYWl0c1t0cmFpdE5hbWVdWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuYXBwbHlfdHJhaXRzID0gZnVuY3Rpb24obm9kZSwgcmVzb3VyY2VVcmksIHJlbW92ZVFzKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAocmVzb3VyY2VVcmkgPT0gbnVsbCkge1xuICAgICAgICByZXNvdXJjZVVyaSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZlUXMgPT0gbnVsbCkge1xuICAgICAgICByZW1vdmVRcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc190cmFpdHMobm9kZSkpIHtcbiAgICAgICAgcmVzb3VyY2VzID0gdGhpcy5jaGlsZF9yZXNvdXJjZXMobm9kZSk7XG4gICAgICAgIHJldHVybiByZXNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseV90cmFpdHNfdG9fcmVzb3VyY2UocmVzb3VyY2VVcmkgKyByZXNvdXJjZVswXS52YWx1ZSwgcmVzb3VyY2VbMV0sIHJlbW92ZVFzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuYXBwbHlfdHJhaXRzX3RvX3Jlc291cmNlID0gZnVuY3Rpb24ocmVzb3VyY2VVcmksIHJlc291cmNlLCByZW1vdmVRcykge1xuICAgICAgdmFyIG1ldGhvZHMsIHVzZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcocmVzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1ldGhvZHMgPSB0aGlzLmNoaWxkX21ldGhvZHMocmVzb3VyY2UpO1xuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KHJlc291cmNlLCAnaXMnKSkge1xuICAgICAgICB1c2VzID0gdGhpcy5wcm9wZXJ0eV92YWx1ZShyZXNvdXJjZSwgJ2lzJyk7XG4gICAgICAgIHVzZXMuZm9yRWFjaChmdW5jdGlvbih1c2UpIHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGx5X3RyYWl0KHJlc291cmNlVXJpLCBtZXRob2QsIHVzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBpZiAoX3RoaXMuaGFzX3Byb3BlcnR5KG1ldGhvZFsxXSwgJ2lzJykpIHtcbiAgICAgICAgICB1c2VzID0gX3RoaXMucHJvcGVydHlfdmFsdWUobWV0aG9kWzFdLCAnaXMnKTtcbiAgICAgICAgICByZXR1cm4gdXNlcy5mb3JFYWNoKGZ1bmN0aW9uKHVzZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGx5X3RyYWl0KHJlc291cmNlVXJpLCBtZXRob2QsIHVzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlbW92ZVFzKSB7XG4gICAgICAgIHJlc291cmNlLnJlbW92ZV9xdWVzdGlvbl9tYXJrX3Byb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFwcGx5X3RyYWl0cyhyZXNvdXJjZSwgcmVzb3VyY2VVcmksIHJlbW92ZVFzKTtcbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5hcHBseV90cmFpdCA9IGZ1bmN0aW9uKHJlc291cmNlVXJpLCBtZXRob2QsIHVzZUtleSkge1xuICAgICAgdmFyIHBsYWluUGFyYW1ldGVycywgdGVtcCwgdHJhaXQsIHRyYWl0TmFtZTtcbiAgICAgIHRyYWl0TmFtZSA9IHRoaXMua2V5X29yX3ZhbHVlKHVzZUtleSk7XG4gICAgICBpZiAoISh0cmFpdE5hbWUgIT0gbnVsbCA/IHRyYWl0TmFtZS50cmltKCkgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlRyYWl0RXJyb3IoJ3doaWxlIGFwcGx5aW5nIHRyYWl0JywgbnVsbCwgJ3RyYWl0IG5hbWUgbXVzdCBiZSBwcm92aWRlZCcsIHVzZUtleS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRyYWl0ID0gdGhpcy5nZXRfdHJhaXQodHJhaXROYW1lKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVHJhaXRFcnJvcignd2hpbGUgYXBwbHlpbmcgdHJhaXQnLCBudWxsLCBcInRoZXJlIGlzIG5vIHRyYWl0IG5hbWVkIFwiICsgdHJhaXROYW1lLCB1c2VLZXkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBwbGFpblBhcmFtZXRlcnMgPSB0aGlzLmdldF9wYXJhbWV0ZXJzX2Zyb21faXNfa2V5KHJlc291cmNlVXJpLCBtZXRob2RbMF0udmFsdWUsIHVzZUtleSk7XG4gICAgICB0ZW1wID0gdHJhaXQuY2xvbmVGb3JUcmFpdCgpO1xuICAgICAgdGhpcy5hcHBseV9wYXJhbWV0ZXJzKHRlbXAsIHBsYWluUGFyYW1ldGVycywgdXNlS2V5KTtcbiAgICAgIHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX21ldGhvZCh0ZW1wKTtcbiAgICAgIHRlbXAuY29tYmluZShtZXRob2RbMV0pO1xuICAgICAgcmV0dXJuIG1ldGhvZFsxXSA9IHRlbXA7XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuYXBwbHlfcGFyYW1ldGVycyA9IGZ1bmN0aW9uKHJlc291cmNlLCBwYXJhbWV0ZXJzLCB1c2VLZXkpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXJOYW1lLCB1c2VkUGFyYW1ldGVycywgX3Jlc3VsdHM7XG4gICAgICB0aGlzLl9hcHBseV9wYXJhbWV0ZXJzKHJlc291cmNlLCBwYXJhbWV0ZXJzLCB1c2VLZXksIHVzZWRQYXJhbWV0ZXJzID0ge1xuICAgICAgICByZXNvdXJjZVBhdGg6IHRydWUsXG4gICAgICAgIHJlc291cmNlUGF0aE5hbWU6IHRydWUsXG4gICAgICAgIG1ldGhvZE5hbWU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAocGFyYW1ldGVyTmFtZSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICghdXNlZFBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJhbWV0ZXJFcnJvcignd2hpbGUgYXBwbHlpbmcgcGFyYW1ldGVycycsIG51bGwsIFwidW51c2VkIHBhcmFtZXRlcjogXCIgKyBwYXJhbWV0ZXJOYW1lLCB1c2VLZXkuc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuX2FwcGx5X3BhcmFtZXRlcnMgPSBmdW5jdGlvbihyZXNvdXJjZSwgcGFyYW1ldGVycywgdXNlS2V5LCB1c2VkUGFyYW1ldGVycykge1xuICAgICAgdmFyIHBhcmFtZXRlclVzZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc1N0cmluZyhyZXNvdXJjZSkpIHtcbiAgICAgICAgaWYgKHBhcmFtZXRlclVzZSA9IHJlc291cmNlLnZhbHVlLm1hdGNoKC88PFxccyooW15cXHxcXHM+XSspXFxzKihcXHwuKik/XFxzKj4+L2cpKSB7XG4gICAgICAgICAgcGFyYW1ldGVyVXNlLmZvckVhY2goZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kLCBwYXJhbWV0ZXJOYW1lLCB2YWx1ZSwgX3JlZjIsIF9yZWYzO1xuICAgICAgICAgICAgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlciAhPSBudWxsID8gKF9yZWYyID0gcGFyYW1ldGVyLnRyaW0oKSkgIT0gbnVsbCA/IF9yZWYyLnJlcGxhY2UoL1s8Pl0rL2csICcnKS50cmltKCkgOiB2b2lkIDAgOiB2b2lkIDA7XG4gICAgICAgICAgICBfcmVmMyA9IHBhcmFtZXRlck5hbWUuc3BsaXQoL1xccypcXHxcXHMqLyksIHBhcmFtZXRlck5hbWUgPSBfcmVmM1swXSwgbWV0aG9kID0gX3JlZjNbMV07XG4gICAgICAgICAgICBpZiAoIShwYXJhbWV0ZXJOYW1lIGluIHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcmFtZXRlckVycm9yKCd3aGlsZSBhcHBseWluZyBwYXJhbWV0ZXJzJywgbnVsbCwgXCJ2YWx1ZSB3YXMgbm90IHByb3ZpZGVkIGZvciBwYXJhbWV0ZXI6IFwiICsgcGFyYW1ldGVyTmFtZSwgdXNlS2V5LnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBwYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdO1xuICAgICAgICAgICAgdXNlZFBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICBpZiAobWV0aG9kLm1hdGNoKC8hXFxzKnNpbmd1bGFyaXplLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGluZmxlY3Rpb24uc2luZ3VsYXJpemUodmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5tYXRjaCgvIVxccypwbHVyYWxpemUvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaW5mbGVjdGlvbi5wbHVyYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcmFtZXRlckVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlcicsIG51bGwsICd1bmtub3duIGZ1bmN0aW9uIGFwcGxpZWQgdG8gcGFyYW1ldGVyJywgcmVzb3VyY2Uuc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZS52YWx1ZSA9IHJlc291cmNlLnZhbHVlLnJlcGxhY2UocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNTZXF1ZW5jZShyZXNvdXJjZSkpIHtcbiAgICAgICAgcmVzb3VyY2UudmFsdWUuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9hcHBseV9wYXJhbWV0ZXJzKG5vZGUsIHBhcmFtZXRlcnMsIHVzZUtleSwgdXNlZFBhcmFtZXRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHJlc291cmNlKSkge1xuICAgICAgICByZXNvdXJjZS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgX3RoaXMuX2FwcGx5X3BhcmFtZXRlcnMocHJvcGVydHlbMF0sIHBhcmFtZXRlcnMsIHVzZUtleSwgdXNlZFBhcmFtZXRlcnMpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fYXBwbHlfcGFyYW1ldGVycyhwcm9wZXJ0eVsxXSwgcGFyYW1ldGVycywgdXNlS2V5LCB1c2VkUGFyYW1ldGVycyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmdldF9wYXJhbWV0ZXJzX2Zyb21faXNfa2V5ID0gZnVuY3Rpb24ocmVzb3VyY2VVcmksIG1ldGhvZE5hbWUsIHR5cGVLZXkpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXIsIHBhcmFtZXRlcnMsIHJlc2VydmVkLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmMjtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzZXJ2ZWQgPSB7XG4gICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIHJlc291cmNlUGF0aDogcmVzb3VyY2VVcmkucmVwbGFjZSgvXFwvXFwvKi9nLCAnLycpLFxuICAgICAgICByZXNvdXJjZVBhdGhOYW1lOiB0aGlzLmV4dHJhY3RSZXNvdXJjZVBhdGhOYW1lKHJlc291cmNlVXJpKVxuICAgICAgfTtcbiAgICAgIGlmICh1dGlsLmlzTWFwcGluZyh0eXBlS2V5KSkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gdGhpcy52YWx1ZV9vcl91bmRlZmluZWQodHlwZUtleSk7XG4gICAgICAgIGlmICh1dGlsLmlzTWFwcGluZyhwYXJhbWV0ZXJzWzBdWzFdKSkge1xuICAgICAgICAgIF9yZWYyID0gcGFyYW1ldGVyc1swXVsxXS52YWx1ZTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXIgPSBfcmVmMltfaV07XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyWzBdLnZhbHVlIGluIHJlc2VydmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlRyYWl0RXJyb3IoJ3doaWxlIGFwcGx5aW5nIHBhcmFtZXRlcnMnLCBudWxsLCBcImludmFsaWQgcGFyYW1ldGVyIG5hbWU6IFwiICsgcGFyYW1ldGVyWzBdLnZhbHVlICsgXCIgaXMgcmVzZXJ2ZWRcIiwgcGFyYW1ldGVyWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3BhcmFtZXRlclswXS52YWx1ZV0gPSBwYXJhbWV0ZXJbMV0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRpbC5leHRlbmQocmVzdWx0LCByZXNlcnZlZCk7XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuZXh0cmFjdFJlc291cmNlUGF0aE5hbWUgPSBmdW5jdGlvbihyZXNvdXJjZVVyaSkge1xuICAgICAgdmFyIHBhdGhTZWdtZW50cywgc2VnbWVudDtcbiAgICAgIHBhdGhTZWdtZW50cyA9IHJlc291cmNlVXJpLnNwbGl0KC9cXC8vKTtcbiAgICAgIHdoaWxlIChzZWdtZW50ID0gcGF0aFNlZ21lbnRzLnBvcCgpKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBzZWdtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHNlZ21lbnQgIT09IG51bGwgPyBzZWdtZW50Lm1hdGNoKC9be31dLykgOiB2b2lkIDApKSB7XG4gICAgICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG5cbiAgICByZXR1cm4gVHJhaXRzO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcywgdXJpdGVtcGxhdGUsIHV0aWwsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICB1cml0ZW1wbGF0ZSA9IHJlcXVpcmUoJ3VyaXRlbXBsYXRlJyk7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qXG4gICAgIEFwcGxpZXMgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBSQU1MXG4gICovXG5cblxuICB0aGlzLlRyYW5zZm9ybWF0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbnMoc2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgIHRoaXMuaXNDb250ZW50VHlwZVN0cmluZyA9IF9fYmluZCh0aGlzLmlzQ29udGVudFR5cGVTdHJpbmcsIHRoaXMpO1xuICAgICAgdGhpcy5hZGRfa2V5X3ZhbHVlX3RvX25vZGUgPSBfX2JpbmQodGhpcy5hZGRfa2V5X3ZhbHVlX3RvX25vZGUsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UgPSBfX2JpbmQodGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fcmVzb3VyY2UsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRfbWVkaWFfdHlwZSA9IF9fYmluZCh0aGlzLmdldF9tZWRpYV90eXBlLCB0aGlzKTtcbiAgICAgIHRoaXMubG9hZF9kZWZhdWx0X21lZGlhX3R5cGUgPSBfX2JpbmQodGhpcy5sb2FkX2RlZmF1bHRfbWVkaWFfdHlwZSwgdGhpcyk7XG4gICAgICB0aGlzLmFwcGx5QXN0VHJhbnNmb3JtYXRpb25zID0gX19iaW5kKHRoaXMuYXBwbHlBc3RUcmFuc2Zvcm1hdGlvbnMsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9ucyA9IF9fYmluZCh0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb25zLCB0aGlzKTtcbiAgICAgIHRoaXMuZGVjbGFyZWRTY2hlbWFzID0ge307XG4gICAgfVxuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybWF0aW9ucyA9IGZ1bmN0aW9uKHJvb3RPYmplY3QpIHtcbiAgICAgIHZhciByZXNvdXJjZXM7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uc1RvUm9vdChyb290T2JqZWN0KTtcbiAgICAgICAgcmVzb3VyY2VzID0gcm9vdE9iamVjdC5yZXNvdXJjZXM7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb25zVG9SZXNvdXJjZXMocm9vdE9iamVjdCwgcmVzb3VyY2VzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hcHBseUFzdFRyYW5zZm9ybWF0aW9ucyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtX2RvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5sb2FkX2RlZmF1bHRfbWVkaWFfdHlwZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobm9kZSB8fCAobm9kZSAhPSBudWxsID8gbm9kZS52YWx1ZSA6IHZvaWQgMCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1lZGlhVHlwZSA9IHRoaXMucHJvcGVydHlfdmFsdWUobm9kZSwgJ21lZGlhVHlwZScpO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmdldF9tZWRpYV90eXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYVR5cGU7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1hdGlvbnNUb1Jvb3QgPSBmdW5jdGlvbihyb290T2JqZWN0KSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnMsIHRlbXBsYXRlO1xuICAgICAgaWYgKHJvb3RPYmplY3QuYmFzZVVyaSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHVyaXRlbXBsYXRlLnBhcnNlKHJvb3RPYmplY3QuYmFzZVVyaSk7XG4gICAgICAgIGV4cHJlc3Npb25zID0gdGVtcGxhdGUuZXhwcmVzc2lvbnMuZmlsdGVyKGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICByZXR1cm4gJ3RlbXBsYXRlVGV4dCcgaW4gZXhwcjtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50ZW1wbGF0ZVRleHQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFyb290T2JqZWN0LmJhc2VVcmlQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICByb290T2JqZWN0LmJhc2VVcmlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgICBpZiAoIShwYXJhbWV0ZXJOYW1lIGluIHJvb3RPYmplY3QuYmFzZVVyaVBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICByb290T2JqZWN0LmJhc2VVcmlQYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IHBhcmFtZXRlck5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyTmFtZSA9PT0gXCJ2ZXJzaW9uXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvb3RPYmplY3QuYmFzZVVyaVBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV1bXCJlbnVtXCJdID0gW3Jvb3RPYmplY3QudmVyc2lvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybWF0aW9uc1RvUmVzb3VyY2VzID0gZnVuY3Rpb24ocm9vdE9iamVjdCwgcmVzb3VyY2VzKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnMsIGluaGVyaXRlZFNlY1NjaGVtZSwgbWV0aG9kLCBwYXJhbWV0ZXJOYW1lLCBwYXRoUGFydHMsIHJlc291cmNlLCB0ZW1wbGF0ZSwgX2ksIF9qLCBfaywgX2xlbiwgX2xlbjEsIF9sZW4yLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAocmVzb3VyY2VzICE9IG51bGwgPyByZXNvdXJjZXMubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcmVzb3VyY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZXNbX2ldO1xuICAgICAgICAgIGluaGVyaXRlZFNlY1NjaGVtZSA9IHJlc291cmNlLnNlY3VyZWRCeSA/IHJlc291cmNlLnNlY3VyZWRCeSA6IHJvb3RPYmplY3QgIT0gbnVsbCA/IHJvb3RPYmplY3Quc2VjdXJlZEJ5IDogdm9pZCAwO1xuICAgICAgICAgIGlmICgoX3JlZiA9IHJlc291cmNlLm1ldGhvZHMpICE9IG51bGwgPyBfcmVmLmxlbmd0aCA6IHZvaWQgMCkge1xuICAgICAgICAgICAgX3JlZjEgPSByZXNvdXJjZS5tZXRob2RzO1xuICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICAgIG1ldGhvZCA9IF9yZWYxW19qXTtcbiAgICAgICAgICAgICAgaWYgKCEoXCJzZWN1cmVkQnlcIiBpbiBtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaGVyaXRlZFNlY1NjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgbWV0aG9kLnNlY3VyZWRCeSA9IGluaGVyaXRlZFNlY1NjaGVtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aFBhcnRzID0gcmVzb3VyY2UucmVsYXRpdmVVcmkuc3BsaXQoJ1xcLycpO1xuICAgICAgICAgIHdoaWxlICghcGF0aFBhcnRzWzBdICYmIHBhdGhQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhdGhQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvdXJjZS5yZWxhdGl2ZVVyaVBhdGhTZWdtZW50cyA9IHBhdGhQYXJ0cztcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHVyaXRlbXBsYXRlLnBhcnNlKHJlc291cmNlLnJlbGF0aXZlVXJpKTtcbiAgICAgICAgICBleHByZXNzaW9ucyA9IHRlbXBsYXRlLmV4cHJlc3Npb25zLmZpbHRlcihmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RlbXBsYXRlVGV4dCcgaW4gZXhwcjtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udGVtcGxhdGVUZXh0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghcmVzb3VyY2UudXJpUGFyYW1ldGVycykge1xuICAgICAgICAgICAgICByZXNvdXJjZS51cmlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IGV4cHJlc3Npb25zLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgcGFyYW1ldGVyTmFtZSA9IGV4cHJlc3Npb25zW19rXTtcbiAgICAgICAgICAgIGlmICghKHBhcmFtZXRlck5hbWUgaW4gcmVzb3VyY2UudXJpUGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgcmVzb3VyY2UudXJpUGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBwYXJhbWV0ZXJOYW1lXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uc1RvUmVzb3VyY2VzKHJvb3RPYmplY3QsIHJlc291cmNlLnJlc291cmNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBNZWRpYSBUeXBlIHBpdm90IHdoZW4gdXNpbmcgZGVmYXVsdCBtZWRpYVR5cGUgcHJvcGVydHlcbiAgICAqL1xuXG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZSA9IGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICB2YXIgY2hpbGRSZXNvdXJjZSwgbWV0aG9kLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIXRoaXMubWVkaWFUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcocmVzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9yZWYgPSB0aGlzLmNoaWxkX3Jlc291cmNlcyhyZXNvdXJjZSk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY2hpbGRSZXNvdXJjZSA9IF9yZWZbX2ldO1xuICAgICAgICB0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZShjaGlsZFJlc291cmNlWzFdKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gdGhpcy5jaGlsZF9tZXRob2RzKHJlc291cmNlKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgbWV0aG9kID0gX3JlZjFbX2pdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX21ldGhvZChtZXRob2RbMV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fbWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICB2YXIgcmVzcG9uc2VzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMubWVkaWFUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobWV0aG9kKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkobWV0aG9kLCAnYm9keScpKSB7XG4gICAgICAgIHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX2JvZHkodGhpcy5nZXRfcHJvcGVydHkobWV0aG9kLCAnYm9keScpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShtZXRob2QsICdyZXNwb25zZXMnKSkge1xuICAgICAgICByZXNwb25zZXMgPSB0aGlzLmdldF9wcm9wZXJ0eShtZXRob2QsICdyZXNwb25zZXMnKTtcbiAgICAgICAgaWYgKCEocmVzcG9uc2VzICYmIHJlc3BvbnNlcy52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlcy52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmhhc19wcm9wZXJ0eShyZXNwb25zZVsxXSwgJ2JvZHknKSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19ib2R5KF90aGlzLmdldF9wcm9wZXJ0eShyZXNwb25zZVsxXSwgJ2JvZHknKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fYm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHZhciBrZXksIHJlc3BvbnNlVHlwZSwgcmVzcG9uc2VUeXBlS2V5LCBfcmVmLCBfcmVmMSwgX3JlZjI7XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKGJvZHkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChib2R5ICE9IG51bGwgPyAoX3JlZiA9IGJvZHkudmFsdWUpICE9IG51bGwgPyAoX3JlZjEgPSBfcmVmWzBdKSAhPSBudWxsID8gKF9yZWYyID0gX3JlZjFbMF0pICE9IG51bGwgPyBfcmVmMi52YWx1ZSA6IHZvaWQgMCA6IHZvaWQgMCA6IHZvaWQgMCA6IHZvaWQgMCkge1xuICAgICAgICBrZXkgPSBib2R5LnZhbHVlWzBdWzBdLnZhbHVlO1xuICAgICAgICBpZiAoIWtleS5tYXRjaCgvXFwvLykpIHtcbiAgICAgICAgICByZXNwb25zZVR5cGUgPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCBib2R5LnN0YXJ0X21hcmssIGJvZHkuZW5kX21hcmspO1xuICAgICAgICAgIHJlc3BvbnNlVHlwZUtleSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB0aGlzLm1lZGlhVHlwZSwgYm9keS5zdGFydF9tYXJrLCBib2R5LmVuZF9tYXJrKTtcbiAgICAgICAgICByZXNwb25zZVR5cGUudmFsdWUucHVzaChbcmVzcG9uc2VUeXBlS2V5LCBib2R5LmNsb25lKCldKTtcbiAgICAgICAgICByZXR1cm4gYm9keS52YWx1ZSA9IHJlc3BvbnNlVHlwZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fdHlwZXMgPSBmdW5jdGlvbih0eXBlUHJvcGVydHkpIHtcbiAgICAgIHZhciB0eXBlcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgdHlwZXMgPSB0eXBlUHJvcGVydHkudmFsdWU7XG4gICAgICByZXR1cm4gdHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlX2VudHJ5KSB7XG4gICAgICAgIHJldHVybiB0eXBlX2VudHJ5LnZhbHVlLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fcmVzb3VyY2UodHlwZSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX3RyYWl0cyA9IGZ1bmN0aW9uKHRyYWl0UHJvcGVydHkpIHtcbiAgICAgIHZhciB0cmFpdHMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHRyYWl0cyA9IHRyYWl0UHJvcGVydHkudmFsdWU7XG4gICAgICByZXR1cm4gdHJhaXRzLmZvckVhY2goZnVuY3Rpb24odHJhaXRfZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHRyYWl0X2VudHJ5LnZhbHVlLmZvckVhY2goZnVuY3Rpb24odHJhaXQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX21ldGhvZCh0cmFpdFsxXSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX25hbWVkX3BhcmFtcyA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIHJlcXVpcmVkQnlEZWZhdWx0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHJlcXVpcmVkQnlEZWZhdWx0ID09IG51bGwpIHtcbiAgICAgICAgcmVxdWlyZWRCeURlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHlbMV0udmFsdWUuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICBpZiAodXRpbC5pc051bGwocGFyYW1bMV0pKSB7XG4gICAgICAgICAgcGFyYW1bMV0gPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCBwYXJhbVsxXS5zdGFydF9tYXJrLCBwYXJhbVsxXS5lbmRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9jb21tb25fcGFyYW1ldGVyX3Byb3BlcnRpZXMocGFyYW1bMF0udmFsdWUsIHBhcmFtWzFdLCBhbGxvd1BhcmFtZXRlcktleXMsIHJlcXVpcmVkQnlEZWZhdWx0KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9jb21tb25fcGFyYW1ldGVyX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwYXJhbWV0ZXJOYW1lLCBub2RlLCBhbGxvd1BhcmFtZXRlcktleXMsIHJlcXVpcmVkQnlEZWZhdWx0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHV0aWwuaXNTZXF1ZW5jZShub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1ldGVyKHBhcmFtZXRlck5hbWUsIHBhcmFtZXRlciwgYWxsb3dQYXJhbWV0ZXJLZXlzLCByZXF1aXJlZEJ5RGVmYXVsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtZXRlcihwYXJhbWV0ZXJOYW1lLCBub2RlLCBhbGxvd1BhcmFtZXRlcktleXMsIHJlcXVpcmVkQnlEZWZhdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fbmFtZWRfcGFyYW1ldGVyID0gZnVuY3Rpb24ocGFyYW1ldGVyTmFtZSwgbm9kZSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCByZXF1aXJlZEJ5RGVmYXVsdCkge1xuICAgICAgdmFyIGhhc0Rpc3BsYXlOYW1lLCBoYXNSZXF1aXJlZCwgaGFzVHlwZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaGFzRGlzcGxheU5hbWUgPSBmYWxzZTtcbiAgICAgIGhhc1JlcXVpcmVkID0gZmFsc2U7XG4gICAgICBoYXNUeXBlID0gZmFsc2U7XG4gICAgICBub2RlLnZhbHVlLmZvckVhY2goZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHZhciBjYW5vbmljYWxQcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChhbGxvd1BhcmFtZXRlcktleXMgJiYgX3RoaXMuaXNQYXJhbWV0ZXJLZXkoY2hpbGROb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW5vbmljYWxQcm9wZXJ0eU5hbWUgPSBfdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUoY2hpbGROb2RlWzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbFByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJkZWZhdWx0XCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwiZXhhbXBsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwibWluTGVuZ3RoXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJtYXhMZW5ndGhcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcIm1pbmltdW1cIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcIm1heGltdW1cIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcInJlcGVhdFwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwiZGlzcGxheU5hbWVcIjpcbiAgICAgICAgICAgIHJldHVybiBoYXNEaXNwbGF5TmFtZSA9IHRydWU7XG4gICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgIHJldHVybiBoYXNUeXBlID0gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBoYXNSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFoYXNEaXNwbGF5TmFtZSkge1xuICAgICAgICB0aGlzLmFkZF9rZXlfdmFsdWVfdG9fbm9kZShub2RlLCAnZGlzcGxheU5hbWUnLCAndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocGFyYW1ldGVyTmFtZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1JlcXVpcmVkKSB7XG4gICAgICAgIGlmIChyZXF1aXJlZEJ5RGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMuYWRkX2tleV92YWx1ZV90b19ub2RlKG5vZGUsICdyZXF1aXJlZCcsICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZF9rZXlfdmFsdWVfdG9fbm9kZShub2RlLCAndHlwZScsICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCAnc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYWRkX2tleV92YWx1ZV90b19ub2RlID0gZnVuY3Rpb24obm9kZSwga2V5TmFtZSwgdmFsdWVUYWcsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlO1xuICAgICAgcHJvcGVydHlOYW1lID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIGtleU5hbWUsIG5vZGUuc3RhcnRfbWFyaywgbm9kZS5lbmRfbWFyayk7XG4gICAgICBwcm9wZXJ0eVZhbHVlID0gbmV3IG5vZGVzLlNjYWxhck5vZGUodmFsdWVUYWcsIHZhbHVlLCBub2RlLnN0YXJ0X21hcmssIG5vZGUuZW5kX21hcmspO1xuICAgICAgcmV0dXJuIG5vZGUudmFsdWUucHVzaChbcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlXSk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX2RvY3VtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChub2RlICE9IG51bGwgPyBub2RlLnZhbHVlIDogdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJzZWN1cml0eVNjaGVtZXNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJzY2hlbWFzXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwidmVyc2lvblwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcImRvY3VtZW50YXRpb25cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJtZWRpYVR5cGVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJzZWN1cmVkQnlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlVXJpXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwidHJhaXRzXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fdHJhaXRzKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlVXJpUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhwcm9wZXJ0eSwgZmFsc2UpO1xuICAgICAgICAgICAgY2FzZSBcInJlc291cmNlVHlwZXNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV90eXBlcyhwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VzXCI6XG4gICAgICAgICAgICAgIHJldHVybiAoX3JlZiA9IHByb3BlcnR5WzFdKSAhPSBudWxsID8gX3JlZi52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9yZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9yZXNvdXJjZSA9IGZ1bmN0aW9uKHJlc291cmNlLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoYWxsb3dQYXJhbWV0ZXJLZXlzID09IG51bGwpIHtcbiAgICAgICAgYWxsb3dQYXJhbWV0ZXJLZXlzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocmVzb3VyY2UudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgY2Fub25pY2FsS2V5LCBpc0tub3duQ29tbW9uUHJvcGVydHksIF9yZWYsIF9yZWYxO1xuICAgICAgICAgIGlzS25vd25Db21tb25Qcm9wZXJ0eSA9IF90aGlzLnRyYW5zZm9ybV9jb21tb25fcHJvcGVydGllcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICBpZiAoIWlzS25vd25Db21tb25Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzSHR0cE1ldGhvZChwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX21ldGhvZChwcm9wZXJ0eVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbm9uaWNhbEtleSA9IF90aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChjYW5vbmljYWxLZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXNhZ2VcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlY3VyZWRCeVwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXJpUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJhc2VVcmlQYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VzXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKF9yZWYgPSBwcm9wZXJ0eVsxXSkgIT0gbnVsbCA/IF9yZWYudmFsdWUuZm9yRWFjaChmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX3Jlc291cmNlKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRob2RzXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKF9yZWYxID0gcHJvcGVydHlbMV0pICE9IG51bGwgPyBfcmVmMS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX21ldGhvZChtZXRob2QsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX21ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHV0aWwuaXNOdWxsKG1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZC52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBjYW5vbmljYWxLZXk7XG4gICAgICAgIGlmIChfdGhpcy50cmFuc2Zvcm1fY29tbW9uX3Byb3BlcnRpZXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2Fub25pY2FsS2V5ID0gX3RoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbEtleSkge1xuICAgICAgICAgIGNhc2UgXCJzZWN1cmVkQnlcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcInVzYWdlXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJoZWFkZXJzXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcInF1ZXJ5UGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJiYXNlVXJpUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fYm9keShwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICBjYXNlIFwicmVzcG9uc2VzXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX3Jlc3BvbnNlcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX3Jlc3BvbnNlcyA9IGZ1bmN0aW9uKHJlc3BvbnNlcywgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHV0aWwuaXNOdWxsKHJlc3BvbnNlc1sxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlc1sxXS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fcmVzcG9uc2UocmVzcG9uc2UsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fcmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHJlc3BvbnNlWzFdKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VbMV0udmFsdWUuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBjYW5vbmljYWxLZXk7XG4gICAgICAgICAgY2Fub25pY2FsS2V5ID0gX3RoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIHN3aXRjaCAoY2Fub25pY2FsS2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fYm9keShwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgIGNhc2UgXCJoZWFkZXJzXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIGZhbHNlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5pc0NvbnRlbnRUeXBlU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUubWF0Y2goL15bXlxcL10rXFwvW15cXC9dKyQvKSA6IHZvaWQgMDtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fYm9keSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBfcmVmLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodXRpbC5pc051bGwocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3JlZiA9IHByb3BlcnR5WzFdLnZhbHVlKSAhPSBudWxsID8gX3JlZi5mb3JFYWNoKGZ1bmN0aW9uKGJvZHlQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgY2Fub25pY2FsUHJvcGVydHk7XG4gICAgICAgIGlmIChfdGhpcy5pc1BhcmFtZXRlcktleShib2R5UHJvcGVydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5pc0NvbnRlbnRUeXBlU3RyaW5nKGJvZHlQcm9wZXJ0eVswXS52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX2JvZHkoYm9keVByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbm9uaWNhbFByb3BlcnR5ID0gX3RoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKGJvZHlQcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbFByb3BlcnR5KSB7XG4gICAgICAgICAgICBjYXNlIFwiZXhhbXBsZVwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcInNjaGVtYVwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcImZvcm1QYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKGJvZHlQcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBmYWxzZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgOiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX2NvbW1vbl9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIGNhbm9uaWNhbFByb3BlcnR5O1xuICAgICAgaWYgKHRoaXMuaXNQYXJhbWV0ZXJLZXkocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2Fub25pY2FsUHJvcGVydHkgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgc3dpdGNoIChjYW5vbmljYWxQcm9wZXJ0eSkge1xuICAgICAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFwiaXNcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm5vb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gVHJhbnNmb3JtYXRpb25zO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBfX3NsaWNlID0gW10uc2xpY2UsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgdGhpcy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdGluYXRpb24sIGssIHNvdXJjZSwgc291cmNlcywgdiwgX2ksIF9sZW47XG4gICAgZGVzdGluYXRpb24gPSBhcmd1bWVudHNbMF0sIHNvdXJjZXMgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc291cmNlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgc291cmNlID0gc291cmNlc1tfaV07XG4gICAgICBmb3IgKGsgaW4gc291cmNlKSB7XG4gICAgICAgIHYgPSBzb3VyY2Vba107XG4gICAgICAgIGRlc3RpbmF0aW9uW2tdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9O1xuXG4gIHRoaXMuaXNfZW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmICghX19oYXNQcm9wLmNhbGwob2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdGhpcy5pc05vb3AgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgdGhpcy5pc01hcHBpbmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09IFwidGFnOnlhbWwub3JnLDIwMDI6bWFwXCI7XG4gIH07XG5cbiAgdGhpcy5pc051bGwgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09IFwidGFnOnlhbWwub3JnLDIwMDI6bnVsbFwiO1xuICB9O1xuXG4gIHRoaXMuaXNTZXF1ZW5jZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gXCJ0YWc6eWFtbC5vcmcsMjAwMjpzZXFcIjtcbiAgfTtcblxuICB0aGlzLmlzU3RyaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSBcInRhZzp5YW1sLm9yZywyMDAyOnN0clwiO1xuICB9O1xuXG4gIHRoaXMuaXNJbnRlZ2VyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSBcInRhZzp5YW1sLm9yZywyMDAyOmludFwiO1xuICB9O1xuXG4gIHRoaXMuaXNOdWxsYWJsZU1hcHBpbmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNNYXBwaW5nKG5vZGUpIHx8IHRoaXMuaXNOdWxsKG5vZGUpO1xuICB9O1xuXG4gIHRoaXMuaXNOdWxsYWJsZVN0cmluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5pc1N0cmluZyhub2RlKSB8fCB0aGlzLmlzTnVsbChub2RlKTtcbiAgfTtcblxuICB0aGlzLmlzTnVsbGFibGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NlcXVlbmNlKG5vZGUpIHx8IHRoaXMuaXNOdWxsKG5vZGUpO1xuICB9O1xuXG4gIHRoaXMuaXNOdW1iZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCc7XG4gIH07XG5cbiAgdGhpcy5pc1NjYWxhciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6aW50JyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInO1xuICB9O1xuXG4gIHRoaXMuaXNDb2xsZWN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6c2V0JyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWFwJztcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwganNvbmxpbnQsIG5vZGVzLCB0cmFpdHMsIHVyaXRlbXBsYXRlLCB1cmwsIHV0aWwsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuICB1cml0ZW1wbGF0ZSA9IHJlcXVpcmUoJ3VyaXRlbXBsYXRlJyk7XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgdHJhaXRzID0gcmVxdWlyZSgnLi90cmFpdHMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAganNvbmxpbnQgPSByZXF1aXJlKCdqc29uLWxpbnQnKTtcblxuICAvKlxuICBUaGUgVmFsaWRhdG9yIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuVmFsaWRhdGlvbkVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYWxpZGF0aW9uRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICBfcmVmID0gVmFsaWRhdGlvbkVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIEEgY29sbGVjdGlvbiBvZiBtdWx0aXBsZSB2YWxpZGF0aW9uIGVycm9yc1xuICAqL1xuXG5cbiAgdGhpcy5WYWxpZGF0aW9uRXJyb3JzID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYWxpZGF0aW9uRXJyb3JzLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9ycyh2YWxpZGF0aW9uX2Vycm9ycykge1xuICAgICAgdGhpcy52YWxpZGF0aW9uX2Vycm9ycyA9IHZhbGlkYXRpb25fZXJyb3JzO1xuICAgIH1cblxuICAgIFZhbGlkYXRpb25FcnJvcnMucHJvdG90eXBlLmdldF92YWxpZGF0aW9uX2Vycm9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvbl9lcnJvcnM7XG4gICAgfTtcblxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3JzO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgVGhlIFZhbGlkYXRvciBjbGFzcyBkZWFscyB3aXRoIHZhbGlkYXRpbmcgYSBZQU1MIGZpbGUgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICovXG5cblxuICB0aGlzLlZhbGlkYXRvciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBWYWxpZGF0b3IoKSB7XG4gICAgICB0aGlzLmdldF9wcm9wZXJ0aWVzID0gX19iaW5kKHRoaXMuZ2V0X3Byb3BlcnRpZXMsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRfbGlzdF92YWx1ZXMgPSBfX2JpbmQodGhpcy5nZXRfbGlzdF92YWx1ZXMsIHRoaXMpO1xuICAgICAgdGhpcy52YWxpZGF0aW9ucyA9IFt0aGlzLnZhbGlkYXRlX3Jvb3QsIHRoaXMudmFsaWRhdGVfcm9vdF9wcm9wZXJ0aWVzLCB0aGlzLnZhbGlkYXRlX2Jhc2VfdXJpX3BhcmFtZXRlcnMsIHRoaXMudmFsaWRfYWJzb2x1dGVfdXJpc107XG4gICAgfVxuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9kb2N1bWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciB2YWxpZGF0aW9uLCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICBfcmVmMSA9IHRoaXMudmFsaWRhdGlvbnM7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHZhbGlkYXRpb24gPSBfcmVmMVtfaV07XG4gICAgICAgIHZhbGlkYXRpb24uY2FsbCh0aGlzLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3NlY3VyaXR5X3NjaGVtZXMgPSBmdW5jdGlvbihzY2hlbWVzUHJvcGVydHkpIHtcbiAgICAgIHZhciBzY2hlbWUsIHNjaGVtZV9lbnRyeSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghdXRpbC5pc1NlcXVlbmNlKHNjaGVtZXNQcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5U2NoZW1lcycsIG51bGwsICdpbnZhbGlkIHNlY3VyaXR5IHNjaGVtZXMgcHJvcGVydHksIGl0IG11c3QgYmUgYW4gYXJyYXknLCBzY2hlbWVzUHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IHNjaGVtZXNQcm9wZXJ0eS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHNjaGVtZV9lbnRyeSA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhzY2hlbWVfZW50cnkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5U2NoZW1lcycsIG51bGwsICdpbnZhbGlkIHNlY3VyaXR5IHNjaGVtZSBwcm9wZXJ0eSwgaXQgbXVzdCBiZSBhIG1hcCcsIHNjaGVtZV9lbnRyeS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVzdWx0cy5wdXNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVmMiwgX3Jlc3VsdHMxO1xuICAgICAgICAgIF9yZWYyID0gc2NoZW1lX2VudHJ5LnZhbHVlO1xuICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgc2NoZW1lID0gX3JlZjJbX2pdO1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhzY2hlbWVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eVNjaGVtZXMnLCBudWxsLCAnaW52YWxpZCBzZWN1cml0eSBzY2hlbWUgcHJvcGVydHksIGl0IG11c3QgYmUgYSBtYXAnLCBzY2hlbWVbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcmVzdWx0czEucHVzaCh0aGlzLnZhbGlkYXRlX3NlY3VyaXR5X3NjaGVtZShzY2hlbWVbMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBrZXksIHByb3BlcnR5LCBzZWN0aW9uLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgIGlmIChzZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgc2VjdGlvbiA9IFwiUkFNTFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yTWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IFwiYSBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHNcIjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoXCJ3aGlsZSB2YWxpZGF0aW5nIFwiICsgc2VjdGlvbiwgbnVsbCwgXCJcIiArIGVycm9yTWVzc2FnZSArIFwiOiAnXCIgKyBrZXkgKyBcIidcIiwgcHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydGllc1trZXldID0gcHJvcGVydHk7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfc2VjdXJpdHlfc2NoZW1lID0gZnVuY3Rpb24oc2NoZW1lKSB7XG4gICAgICB2YXIgcHJvcGVydHksIHNjaGVtZVByb3BlcnRpZXMsIHNldHRpbmdzLCB0eXBlLCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIHNldHRpbmdzID0gbnVsbDtcbiAgICAgIHNjaGVtZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gc2NoZW1lLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYxW19pXTtcbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhzY2hlbWVQcm9wZXJ0aWVzLCBwcm9wZXJ0eVswXS52YWx1ZSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIFwicHJvcGVydHkgYWxyZWFkeSB1c2VkIGluIHNlY3VyaXR5IHNjaGVtZVwiKTtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ3NjaGVtZXMgZGVzY3JpcHRpb24gbXVzdCBiZSBhIHN0cmluZycsIHByb3BlcnR5WzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgICAgIHR5cGUgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgICAgICAgIGlmICghKHV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pICYmIHR5cGUubWF0Y2goL14oT0F1dGggMS4wfE9BdXRoIDIuMHxCYXNpYyBBdXRoZW50aWNhdGlvbnxEaWdlc3QgQXV0aGVudGljYXRpb258eC0uKykkLykpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnc2NoZW1lcyB0eXBlIG11c3QgYmUgYW55IG9mOiBcIk9BdXRoIDEuMFwiLCBcIk9BdXRoIDIuMFwiLCBcIkJhc2ljIEF1dGhlbnRpY2F0aW9uXCIsIFwiRGlnZXN0IEF1dGhlbnRpY2F0aW9uXCIsIFwieC1cXHsuK1xcfVwiJywgcHJvcGVydHlbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGVzY3JpYmVkQnlcIjpcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfbWV0aG9kKHByb3BlcnR5LCB0cnVlLCBcInNlY3VyaXR5IHNjaGVtZVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzZXR0aW5nc1wiOlxuICAgICAgICAgICAgc2V0dGluZ3MgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdzY2hlbWVzIHNldHRpbmdzIG11c3QgYmUgYSBtYXAnLCBwcm9wZXJ0eVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgXCJwcm9wZXJ0eTogJ1wiICsgcHJvcGVydHlbMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIHNlY3VyaXR5IHNjaGVtZVwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnc2NoZW1lcyB0eXBlIG11c3QgYmUgYW55IG9mOiBcIk9BdXRoIDEuMFwiLCBcIk9BdXRoIDIuMFwiLCBcIkJhc2ljIEF1dGhlbnRpY2F0aW9uXCIsIFwiRGlnZXN0IEF1dGhlbnRpY2F0aW9uXCIsIFwieC1cXHsuK1xcfVwiJywgc2NoZW1lLnN0YXJ0X21hcmspO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIk9BdXRoIDIuMFwiKSB7XG4gICAgICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ2ZvciBPQXV0aCAyLjAgc2V0dGluZ3MgbXVzdCBiZSBhIG1hcCcsIHNjaGVtZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZV9vYXV0aDJfc2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIk9BdXRoIDEuMFwiKSB7XG4gICAgICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ2ZvciBPQXV0aCAxLjAgc2V0dGluZ3MgbXVzdCBiZSBhIG1hcCcsIHNjaGVtZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZV9vYXV0aDFfc2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX29hdXRoMl9zZXR0aW5ncyA9IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJvcGVydHksIHByb3BlcnR5TmFtZSwgc2V0dGluZ1Byb3BlcnRpZXMsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYxLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBzZXR0aW5nUHJvcGVydGllcyA9IHt9O1xuICAgICAgX3JlZjEgPSBzZXR0aW5nc1sxXS52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmMVtfaV07XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMoc2V0dGluZ1Byb3BlcnRpZXMsIHByb3BlcnR5WzBdLnZhbHVlLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgXCJzZXR0aW5nIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJhdXRob3JpemF0aW9uVXJpXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnYXV0aG9yaXphdGlvblVyaSBtdXN0IGJlIGEgVVJMJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYWNjZXNzVG9rZW5VcmlcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdhY2Nlc3NUb2tlblVyaSBtdXN0IGJlIGEgVVJMJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9yZWYyID0gWydhY2Nlc3NUb2tlblVyaScsICdhdXRob3JpemF0aW9uVXJpJ107XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjIubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgIHByb3BlcnR5TmFtZSA9IF9yZWYyW19qXTtcbiAgICAgICAgaWYgKCEocHJvcGVydHlOYW1lIGluIHNldHRpbmdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCBcIk9BdXRoIDIuMCBzZXR0aW5ncyBtdXN0IGhhdmUgXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIiBwcm9wZXJ0eVwiLCBzZXR0aW5nc1swXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9vYXV0aDFfc2V0dGluZ3MgPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgICAgdmFyIHByb3BlcnR5LCBwcm9wZXJ0eU5hbWUsIHNldHRpbmdQcm9wZXJ0aWVzLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgc2V0dGluZ1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gc2V0dGluZ3NbMV0udmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjFbX2ldO1xuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHNldHRpbmdQcm9wZXJ0aWVzLCBwcm9wZXJ0eVswXS52YWx1ZSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIFwic2V0dGluZyB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwicmVxdWVzdFRva2VuVXJpXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAncmVxdWVzdFRva2VuVXJpIG11c3QgYmUgYSBVUkwnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhdXRob3JpemF0aW9uVXJpXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnYXV0aG9yaXphdGlvblVyaSBtdXN0IGJlIGEgVVJMJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9rZW5DcmVkZW50aWFsc1VyaVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ3Rva2VuQ3JlZGVudGlhbHNVcmkgbXVzdCBiZSBhIFVSTCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfcmVmMiA9IFsncmVxdWVzdFRva2VuVXJpJywgJ2F1dGhvcml6YXRpb25VcmknLCAndG9rZW5DcmVkZW50aWFsc1VyaSddO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICBwcm9wZXJ0eU5hbWUgPSBfcmVmMltfal07XG4gICAgICAgIGlmICghKHByb3BlcnR5TmFtZSBpbiBzZXR0aW5nUHJvcGVydGllcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgXCJPQXV0aCAxLjAgc2V0dGluZ3MgbXVzdCBoYXZlIFwiICsgcHJvcGVydHlOYW1lICsgXCIgcHJvcGVydHlcIiwgc2V0dGluZ3NbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcm9vdF9zY2hlbWFzID0gZnVuY3Rpb24oc2NoZW1hcykge1xuICAgICAgdmFyIHNjaGVtYSwgc2NoZW1hTGlzdCwgc2NoZW1hTmFtZSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIXV0aWwuaXNTZXF1ZW5jZShzY2hlbWFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2NoZW1hcycsIG51bGwsICdzY2hlbWFzIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXknLCBzY2hlbWFzLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgc2NoZW1hTGlzdCA9IHRoaXMuZ2V0X2FsbF9zY2hlbWFzKCk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChzY2hlbWFOYW1lIGluIHNjaGVtYUxpc3QpIHtcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hTGlzdFtzY2hlbWFOYW1lXTtcbiAgICAgICAgaWYgKCEoc2NoZW1hWzFdLnRhZyAmJiB1dGlsLmlzU3RyaW5nKHNjaGVtYVsxXSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNjaGVtYXMnLCBudWxsLCAnc2NoZW1hICcgKyBzY2hlbWFOYW1lICsgJyBtdXN0IGJlIGEgc3RyaW5nJywgc2NoZW1hWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWFbMV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9yb290ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCEobm9kZSB8fCB1dGlsLmlzTnVsbChub2RlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QnLCBudWxsLCAnZW1wdHkgZG9jdW1lbnQnLCBub2RlICE9IG51bGwgPyBub2RlLnN0YXJ0X21hcmsgOiB2b2lkIDApO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCcsIG51bGwsICdkb2N1bWVudCBtdXN0IGJlIGEgbWFwJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9iYXNlX3VyaV9wYXJhbWV0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuYmFzZVVyaVBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmJhc2VVcmkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgJ3VyaSBwYXJhbWV0ZXJzIGRlZmluZWQgd2hlbiB0aGVyZSBpcyBubyBiYXNlVXJpJywgdGhpcy5iYXNlVXJpUGFyYW1ldGVycy5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyh0aGlzLmJhc2VVcmlQYXJhbWV0ZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCAnYmFzZSB1cmkgcGFyYW1ldGVycyBtdXN0IGJlIGEgbWFwJywgdGhpcy5iYXNlVXJpUGFyYW1ldGVycy5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlX3VyaV9wYXJhbWV0ZXJzKHRoaXMuYmFzZVVyaSwgdGhpcy5iYXNlVXJpUGFyYW1ldGVycywgZmFsc2UsIGZhbHNlLCBbXCJ2ZXJzaW9uXCJdKTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV91cmlfcGFyYW1ldGVycyA9IGZ1bmN0aW9uKHVyaSwgdXJpUHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgc2tpcFBhcmFtZXRlclVzZUNoZWNrLCByZXNlcnZlZE5hbWVzKSB7XG4gICAgICB2YXIgZXJyLCBleHByZXNzaW9ucywgcGFyYW1ldGVyTmFtZSwgdGVtcGxhdGUsIHVyaVBhcmFtZXRlciwgdXJpUGFyYW1ldGVycywgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBpZiAocmVzZXJ2ZWROYW1lcyA9PSBudWxsKSB7XG4gICAgICAgIHJlc2VydmVkTmFtZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRlbXBsYXRlID0gdXJpdGVtcGxhdGUucGFyc2UodXJpKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsIGVyciAhPSBudWxsID8gKF9yZWYxID0gZXJyLm9wdGlvbnMpICE9IG51bGwgPyBfcmVmMS5tZXNzYWdlIDogdm9pZCAwIDogdm9pZCAwLCB1cmlQcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGV4cHJlc3Npb25zID0gdGVtcGxhdGUuZXhwcmVzc2lvbnMuZmlsdGVyKGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIFwidGVtcGxhdGVUZXh0XCIgaW4gZXhwcjtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLnRlbXBsYXRlVGV4dDtcbiAgICAgIH0pO1xuICAgICAgdXJpUGFyYW1ldGVycyA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiB1cmlQcm9wZXJ0eS52YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBfcmVmMiA9IHVyaVByb3BlcnR5LnZhbHVlO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgdXJpUGFyYW1ldGVyID0gX3JlZjJbX2ldO1xuICAgICAgICAgIHBhcmFtZXRlck5hbWUgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZSh1cmlQYXJhbWV0ZXJbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyh1cmlQYXJhbWV0ZXJzLCBwYXJhbWV0ZXJOYW1lLCB1cmlQcm9wZXJ0eSwgJ3doaWxlIHZhbGlkYXRpbmcgVVJJIHBhcmFtZXRlcnMnLCBcIlVSSSBwYXJhbWV0ZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChyZXNlcnZlZE5hbWVzLCBwYXJhbWV0ZXJOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYmFzZVVyaScsIG51bGwsIHVyaVBhcmFtZXRlclswXS52YWx1ZSArICcgcGFyYW1ldGVyIG5vdCBhbGxvd2VkIGhlcmUnLCB1cmlQYXJhbWV0ZXJbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHV0aWwuaXNOdWxsYWJsZU1hcHBpbmcodXJpUGFyYW1ldGVyWzFdLCBhbGxvd1BhcmFtZXRlcktleXMpIHx8IHV0aWwuaXNOdWxsYWJsZVNlcXVlbmNlKHVyaVBhcmFtZXRlclsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBiYXNlVXJpJywgbnVsbCwgJ1VSSSBwYXJhbWV0ZXIgbXVzdCBiZSBhIG1hcCcsIHVyaVBhcmFtZXRlclswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbCh1cmlQYXJhbWV0ZXJbMV0pKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkX2NvbW1vbl9wYXJhbWV0ZXJfcHJvcGVydGllcyh1cmlQYXJhbWV0ZXJbMV0sIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHNraXBQYXJhbWV0ZXJVc2VDaGVjayB8fCB0aGlzLmlzUGFyYW1ldGVyS2V5KHVyaVBhcmFtZXRlcikgfHwgX19pbmRleE9mLmNhbGwoZXhwcmVzc2lvbnMsIHBhcmFtZXRlck5hbWUpID49IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYmFzZVVyaScsIG51bGwsIHVyaVBhcmFtZXRlclswXS52YWx1ZSArICcgdXJpIHBhcmFtZXRlciB1bnVzZWQnLCB1cmlQYXJhbWV0ZXJbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3R5cGVzID0gZnVuY3Rpb24odHlwZVByb3BlcnR5KSB7XG4gICAgICB2YXIgdHlwZSwgdHlwZV9lbnRyeSwgdHlwZXMsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIHR5cGVzID0gdHlwZVByb3BlcnR5LnZhbHVlO1xuICAgICAgaWYgKCF1dGlsLmlzU2VxdWVuY2UodHlwZVByb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZXMnLCBudWxsLCAnaW52YWxpZCByZXNvdXJjZVR5cGVzIGRlZmluaXRpb24sIGl0IG11c3QgYmUgYW4gYXJyYXknLCB0eXBlUHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0eXBlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB0eXBlX2VudHJ5ID0gdHlwZXNbX2ldO1xuICAgICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHR5cGVfZW50cnkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGVzJywgbnVsbCwgJ2ludmFsaWQgcmVzb3VyY2VUeXBlIGRlZmluaXRpb24sIGl0IG11c3QgYmUgYSBtYXAnLCB0eXBlX2VudHJ5LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYxLCBfcmVzdWx0czE7XG4gICAgICAgICAgX3JlZjEgPSB0eXBlX2VudHJ5LnZhbHVlO1xuICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgdHlwZSA9IF9yZWYxW19qXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGFyYW1ldGVyS2V5KHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlcycsIG51bGwsICdwYXJhbWV0ZXIga2V5IGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzb3VyY2UgdHlwZSBuYW1lJywgdHlwZVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbC5pc01hcHBpbmcodHlwZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGVzJywgbnVsbCwgJ2ludmFsaWQgcmVzb3VyY2VUeXBlIGRlZmluaXRpb24sIGl0IG11c3QgYmUgYSBtYXAnLCB0eXBlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godGhpcy52YWxpZGF0ZV9yZXNvdXJjZSh0eXBlLCB0cnVlLCAncmVzb3VyY2UgdHlwZScpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfdHJhaXRzID0gZnVuY3Rpb24odHJhaXRQcm9wZXJ0eSkge1xuICAgICAgdmFyIHRyYWl0LCB0cmFpdF9lbnRyeSwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgdHJhaXRzID0gdHJhaXRQcm9wZXJ0eS52YWx1ZTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFpdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdHMnLCBudWxsLCAnaW52YWxpZCB0cmFpdHMgZGVmaW5pdGlvbiwgaXQgbXVzdCBiZSBhbiBhcnJheScsIHRyYWl0UHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0cmFpdHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgdHJhaXRfZW50cnkgPSB0cmFpdHNbX2ldO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhaXRfZW50cnkudmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0cycsIG51bGwsICdpbnZhbGlkIHRyYWl0cyBkZWZpbml0aW9uLCBpdCBtdXN0IGJlIGFuIGFycmF5JywgdHJhaXRQcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVzdWx0cy5wdXNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVmMSwgX3Jlc3VsdHMxO1xuICAgICAgICAgIF9yZWYxID0gdHJhaXRfZW50cnkudmFsdWU7XG4gICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICB0cmFpdCA9IF9yZWYxW19qXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGFyYW1ldGVyS2V5KHRyYWl0KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXRzJywgbnVsbCwgJ3BhcmFtZXRlciBrZXkgY2Fubm90IGJlIHVzZWQgYXMgYSB0cmFpdCBuYW1lJywgdHJhaXRbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHRyYWl0WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXRzJywgbnVsbCwgJ2ludmFsaWQgdHJhaXQgZGVmaW5pdGlvbiwgaXQgbXVzdCBiZSBhIG1hcCcsIHRyYWl0WzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godGhpcy52YWxpZF90cmFpdHNfcHJvcGVydGllcyh0cmFpdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZF90cmFpdHNfcHJvcGVydGllcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBpbnZhbGlkO1xuICAgICAgaWYgKCFub2RlWzFdLnZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobm9kZVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW52YWxpZCA9IG5vZGVbMV0udmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2RlWzBdLnZhbHVlID09PSBcImlzXCIgfHwgY2hpbGROb2RlWzBdLnZhbHVlID09PSBcInR5cGVcIjtcbiAgICAgIH0pO1xuICAgICAgaWYgKGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgcHJvcGVydGllcycsIG51bGwsIFwicHJvcGVydHk6ICdcIiArIGludmFsaWRbMF1bMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIHRyYWl0XCIsIGludmFsaWRbMF1bMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZV9tZXRob2Qobm9kZSwgdHJ1ZSwgJ3RyYWl0Jyk7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lID0gZnVuY3Rpb24ocHJvcGVydHlOYW1lLCBtdXN0UmVtb3ZlUXVlc3Rpb25NYXJrKSB7XG4gICAgICBpZiAobXVzdFJlbW92ZVF1ZXN0aW9uTWFyayAmJiBwcm9wZXJ0eU5hbWUuc2xpY2UoLTEpID09PSAnPycpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5TmFtZS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHlOYW1lO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkX2NvbW1vbl9wYXJhbWV0ZXJfcHJvcGVydGllcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIHBhcmFtZXRlciwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghbm9kZS52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc1NlcXVlbmNlKG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICduYW1lZCBwYXJhbWV0ZXIgbmVlZHMgYXQgbGVhc3Qgb25lIHR5cGUnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG5vZGUudmFsdWUubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAnc2luZ2xlIHR5cGUgZm9yIHZhcmlhYmx5IHR5cGVkIHBhcmFtZXRlcicsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZjEgPSBub2RlLnZhbHVlO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcGFyYW1ldGVyID0gX3JlZjFbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9uYW1lZF9wYXJhbWV0ZXIocGFyYW1ldGVyLCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZV9uYW1lZF9wYXJhbWV0ZXIobm9kZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9uYW1lZF9wYXJhbWV0ZXIgPSBmdW5jdGlvbihub2RlLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBib29sZWFuVmFsdWVzLCBjYW5vbmljYWxQcm9wZXJ0eU5hbWUsIGNoaWxkTm9kZSwgZW51bVZhbHVlcywgcGFyYW1ldGVyUHJvcGVydGllcywgcGFyYW1ldGVyVHlwZSwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlLCB1bnVzYWJsZVByb3BlcnR5LCB2YWxpZCwgdmFsaWRUeXBlcywgX2ksIF9qLCBfaywgX2xlbiwgX2xlbjEsIF9sZW4yLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVzdWx0cztcbiAgICAgIHBhcmFtZXRlclByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHBhcmFtZXRlclR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgX3JlZjEgPSBub2RlLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBfcmVmMVtfaV07XG4gICAgICAgIHByb3BlcnR5TmFtZSA9IGNoaWxkTm9kZVswXS52YWx1ZTtcbiAgICAgICAgcHJvcGVydHlWYWx1ZSA9IGNoaWxkTm9kZVsxXS52YWx1ZTtcbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhwYXJhbWV0ZXJQcm9wZXJ0aWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShjaGlsZE5vZGVbMF0udmFsdWUsIHRydWUpLCBjaGlsZE5vZGVbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgXCJwYXJhbWV0ZXIgcHJvcGVydHkgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBib29sZWFuVmFsdWVzID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdO1xuICAgICAgICBpZiAoYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNQYXJhbWV0ZXJLZXkoY2hpbGROb2RlKSB8fCB0aGlzLmlzUGFyYW1ldGVyVmFsdWUoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbm9uaWNhbFByb3BlcnR5TmFtZSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGNoaWxkTm9kZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBkaXNwbGF5TmFtZSBtdXN0IGJlIGEgc2NhbGFyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBhdHRlcm5cIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihjaGlsZE5vZGVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgcGF0dGVybiBtdXN0IGJlIGEgc2NhbGFyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihjaGlsZE5vZGVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgZGVmYXVsdCBtdXN0IGJlIGEgc2NhbGFyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoY2hpbGROb2RlWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBzY2FsYXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZXhhbXBsZVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGNoaWxkTm9kZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBleGFtcGxlIG11c3QgYmUgYSBzY2FsYXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWluTGVuZ3RoXCI6XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBtaW5MZW5ndGggbXVzdCBiZSBhIG51bWJlcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXhMZW5ndGhcIjpcbiAgICAgICAgICAgIGlmIChpc05hTihwcm9wZXJ0eVZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIG1heExlbmd0aCBtdXN0IGJlIGEgbnVtYmVyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1pbmltdW1cIjpcbiAgICAgICAgICAgIGlmIChpc05hTihwcm9wZXJ0eVZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIG1pbmltdW0gbXVzdCBiZSBhIG51bWJlcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXhpbXVtXCI6XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBtYXhpbXVtIG11c3QgYmUgYSBudW1iZXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgcGFyYW1ldGVyVHlwZSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICB2YWxpZFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2ludGVnZXInLCAnZGF0ZScsICdib29sZWFuJywgJ2ZpbGUnXTtcbiAgICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbCh2YWxpZFR5cGVzLCBwcm9wZXJ0eVZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3R5cGUgY2FuIGJlIGVpdGhlciBvZjogc3RyaW5nLCBudW1iZXIsIGludGVnZXIsIGZpbGUsIGRhdGUgb3IgYm9vbGVhbiAnLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChib29sZWFuVmFsdWVzLCBwcm9wZXJ0eVZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3JlcXVpcmVkIGNhbiBiZSBhbnkgZWl0aGVyIHRydWUgb3IgZmFsc2UnLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVwZWF0XCI6XG4gICAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoYm9vbGVhblZhbHVlcywgcHJvcGVydHlWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICdyZXBlYXQgY2FuIGJlIGFueSBlaXRoZXIgdHJ1ZSBvciBmYWxzZScsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY2Fub25pY2FsUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc051bGxhYmxlU2VxdWVuY2UoY2hpbGROb2RlWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIGVudW0gbXVzdCBiZSBhbiBhcnJheScsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlWzFdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAnZW51bSBpcyBlbXB0eScsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudW1WYWx1ZXMgPSB0aGlzLmdldF9saXN0X3ZhbHVlcyhjaGlsZE5vZGVbMV0udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRHVwbGljYXRlcyhlbnVtVmFsdWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAnZW51bSBjb250YWlucyBkdXBsaWNhdGVkIHZhbHVlcycsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsIFwidW5rbm93biBwcm9wZXJ0eSBcIiArIHByb3BlcnR5TmFtZSwgY2hpbGROb2RlWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1ldGVyVHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBfcmVmMiA9IFsnZW51bScsICdwYXR0ZXJuJywgJ21pbkxlbmd0aCcsICdtYXhMZW5ndGgnXTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjIubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgdW51c2FibGVQcm9wZXJ0eSA9IF9yZWYyW19qXTtcbiAgICAgICAgICBpZiAodW51c2FibGVQcm9wZXJ0eSBpbiBwYXJhbWV0ZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCBcInByb3BlcnR5IFwiICsgdW51c2FibGVQcm9wZXJ0eSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgaWYgdHlwZSBpcyAnc3RyaW5nJ1wiLCBwYXJhbWV0ZXJQcm9wZXJ0aWVzW3VudXNhYmxlUHJvcGVydHldLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEocGFyYW1ldGVyVHlwZSA9PT0gXCJudW1iZXJcIiB8fCBwYXJhbWV0ZXJUeXBlID09PSBcImludGVnZXJcIikpIHtcbiAgICAgICAgX3JlZjMgPSBbJ21pbmltdW0nLCAnbWF4aW11bSddO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBfcmVmMy5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgICAgICB1bnVzYWJsZVByb3BlcnR5ID0gX3JlZjNbX2tdO1xuICAgICAgICAgIGlmICh1bnVzYWJsZVByb3BlcnR5IGluIHBhcmFtZXRlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsIFwicHJvcGVydHkgXCIgKyB1bnVzYWJsZVByb3BlcnR5ICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBpZiB0eXBlIGlzICdudW1iZXInIG9yICdpbnRlZ2VyJ1wiLCBwYXJhbWV0ZXJQcm9wZXJ0aWVzW3VudXNhYmxlUHJvcGVydHldLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRfbGlzdF92YWx1ZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5vZGUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9yb290X3Byb3BlcnRpZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2hlY2tWZXJzaW9uLCBwcm9wZXJ0eSwgcm9vdFByb3BlcnRpZXMsIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIGNoZWNrVmVyc2lvbiA9IGZhbHNlO1xuICAgICAgcm9vdFByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGlmIChub2RlICE9IG51bGwgPyBub2RlLnZhbHVlIDogdm9pZCAwKSB7XG4gICAgICAgIF9yZWYxID0gbm9kZS52YWx1ZTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHByb3BlcnR5ID0gX3JlZjFbX2ldO1xuICAgICAgICAgIGlmIChwcm9wZXJ0eVswXS52YWx1ZS5tYXRjaCgvXlxcLy8pKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHJvb3RQcm9wZXJ0aWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgdHJ1ZSksIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBcInJlc291cmNlIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocm9vdFByb3BlcnRpZXMsIHByb3BlcnR5WzBdLnZhbHVlLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgJ3Jvb3QgcHJvcGVydHkgYWxyZWFkeSB1c2VkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCAndGl0bGUgbXVzdCBiZSBhIHN0cmluZycsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmFzZVVyaSc6XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ2Jhc2VVcmkgbXVzdCBiZSBhIHN0cmluZycsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuYmFzZVVyaSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgICAgICAgICBjaGVja1ZlcnNpb24gPSB0aGlzLnZhbGlkYXRlX2Jhc2VfdXJpKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWN1cml0eVNjaGVtZXMnOlxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3NlY3VyaXR5X3NjaGVtZXMocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NjaGVtYXMnOlxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3Jvb3Rfc2NoZW1hcyhwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmVyc2lvbic6XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ3ZlcnNpb24gbXVzdCBiZSBhIHN0cmluZycsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc051bGwocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlbMV0udGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0cmFpdHMnOlxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3RyYWl0cyhwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnRhdGlvbic6XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc1NlcXVlbmNlKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCAnZG9jdW1lbnRhdGlvbiBtdXN0IGJlIGFuIGFycmF5JywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9kb2N1bWVudGF0aW9uKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZWRpYVR5cGUnOlxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsICdtZWRpYVR5cGUgbXVzdCBiZSBhIHNjYWxhcicsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmFzZVVyaVBhcmFtZXRlcnMnOlxuICAgICAgICAgICAgICB0aGlzLmJhc2VVcmlQYXJhbWV0ZXJzID0gcHJvcGVydHlbMV07XG4gICAgICAgICAgICAgIHV0aWwuaXNOb29wKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXNvdXJjZVR5cGVzJzpcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV90eXBlcyhwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VjdXJlZEJ5JzpcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9zZWN1cmVkX2J5KHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcm90b2NvbHMnOlxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3Byb3RvY29sc19wcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnR5WzBdLnZhbHVlLm1hdGNoKC9eXFwvLykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3Jlc291cmNlKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgXCJ1bmtub3duIHByb3BlcnR5IFwiICsgcHJvcGVydHlbMF0udmFsdWUsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoISgndGl0bGUnIGluIHJvb3RQcm9wZXJ0aWVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ21pc3NpbmcgdGl0bGUnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrVmVyc2lvbiAmJiAhKCd2ZXJzaW9uJyBpbiByb290UHJvcGVydGllcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHZlcnNpb24nLCBudWxsLCAnbWlzc2luZyB2ZXJzaW9uJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9kb2N1bWVudGF0aW9uID0gZnVuY3Rpb24oZG9jdW1lbnRhdGlvbl9wcm9wZXJ0eSkge1xuICAgICAgdmFyIGRvY1NlY3Rpb24sIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIWRvY3VtZW50YXRpb25fcHJvcGVydHkudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBudWxsLCAndGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgZG9jdW1lbnQgaW4gdGhlIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIGRvY3VtZW50YXRpb25fcHJvcGVydHkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IGRvY3VtZW50YXRpb25fcHJvcGVydHkudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBkb2NTZWN0aW9uID0gX3JlZjFbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfZG9jX3NlY3Rpb24oZG9jU2VjdGlvbikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2RvY19zZWN0aW9uID0gZnVuY3Rpb24oZG9jU2VjdGlvbikge1xuICAgICAgdmFyIGRvY1Byb3BlcnRpZXMsIHByb3BlcnR5LCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKGRvY1NlY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBudWxsLCAnZWFjaCBkb2N1bWVudGF0aW9uIHNlY3Rpb24gbXVzdCBiZSBhIG1hcCcsIGRvY1NlY3Rpb24uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBkb2NQcm9wZXJ0aWVzID0ge307XG4gICAgICBfcmVmMSA9IGRvY1NlY3Rpb24udmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjFbX2ldO1xuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKGRvY1Byb3BlcnRpZXMsIHByb3BlcnR5WzBdLnZhbHVlLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgXCJwcm9wZXJ0eSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgICAgIGlmICghKHV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pICYmICF1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBudWxsLCAndGl0bGUgbXVzdCBiZSBhIHN0cmluZycsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNvbnRlbnRcIjpcbiAgICAgICAgICAgIGlmICghKHV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pICYmICF1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBudWxsLCAnY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsICd1bmtub3duIHByb3BlcnR5ICcgKyBwcm9wZXJ0eVswXS52YWx1ZSwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghKFwiY29udGVudFwiIGluIGRvY1Byb3BlcnRpZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBudWxsLCAnYSBkb2N1bWVudGF0aW9uIGVudHJ5IG11c3QgaGF2ZSBjb250ZW50IHByb3BlcnR5JywgZG9jU2VjdGlvbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKFwidGl0bGVcIiBpbiBkb2NQcm9wZXJ0aWVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgbnVsbCwgJ2EgZG9jdW1lbnRhdGlvbiBlbnRyeSBtdXN0IGhhdmUgdGl0bGUgcHJvcGVydHknLCBkb2NTZWN0aW9uLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmNoaWxkX3Jlc291cmNlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlICYmIHV0aWwuaXNNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGROb2RlWzBdLnZhbHVlLm1hdGNoKC9eXFwvLyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3Jlc291cmNlID0gZnVuY3Rpb24ocmVzb3VyY2UsIGFsbG93UGFyYW1ldGVyS2V5cywgY29udGV4dCkge1xuICAgICAgdmFyIGNhbm9uaWNhbEtleSwgZXJyLCBrZXksIHByb3BlcnR5LCByZXNvdXJjZVByb3BlcnRpZXMsIHRlbXBsYXRlLCB2YWxpZCwgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBpZiAoYWxsb3dQYXJhbWV0ZXJLZXlzID09IG51bGwpIHtcbiAgICAgICAgYWxsb3dQYXJhbWV0ZXJLZXlzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRleHQgPSBcInJlc291cmNlXCI7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXNvdXJjZVsxXSAmJiB1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHJlc291cmNlWzFdKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsICdyZXNvdXJjZSBpcyBub3QgYSBtYXAnLCByZXNvdXJjZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNvdXJjZVswXS52YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRlbXBsYXRlID0gdXJpdGVtcGxhdGUucGFyc2UocmVzb3VyY2VbMF0udmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlJywgbnVsbCwgXCJSZXNvdXJjZSBuYW1lIGlzIGludmFsaWQ6IFwiICsgKGVyciAhPSBudWxsID8gKF9yZWYxID0gZXJyLm9wdGlvbnMpICE9IG51bGwgPyBfcmVmMS5tZXNzYWdlIDogdm9pZCAwIDogdm9pZCAwKSwgcmVzb3VyY2VbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTnVsbChyZXNvdXJjZVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlc291cmNlWzFdLnZhbHVlKSB7XG4gICAgICAgIHJlc291cmNlUHJvcGVydGllcyA9IHt9O1xuICAgICAgICBfcmVmMiA9IHJlc291cmNlWzFdLnZhbHVlO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBfcmVmMltfaV07XG4gICAgICAgICAgaWYgKHByb3BlcnR5WzBdLnZhbHVlLm1hdGNoKC9eXFwvLykpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocmVzb3VyY2VQcm9wZXJ0aWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgdHJ1ZSksIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZScsIFwicmVzb3VyY2UgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNIdHRwTWV0aG9kKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHJlc291cmNlUHJvcGVydGllcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIHRydWUpLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UnLCBcIm1ldGhvZCBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHJlc291cmNlUHJvcGVydGllcywgdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIHRydWUpLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UnLCBcInByb3BlcnR5IGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlX2NvbW1vbl9wcm9wZXJ0aWVzKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlbMF0udmFsdWUubWF0Y2goL15cXC8vKSkge1xuICAgICAgICAgICAgICBpZiAoYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IHByb3BlcnRpZXMnLCBudWxsLCAncmVzb3VyY2UgdHlwZSBjYW5ub3QgZGVmaW5lIGNoaWxkIHJlc291cmNlcycsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9yZXNvdXJjZShwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNIdHRwTWV0aG9kKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9tZXRob2QocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgJ21ldGhvZCcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGtleSA9IHByb3BlcnR5WzBdLnZhbHVlO1xuICAgICAgICAgICAgICBjYW5vbmljYWxLZXkgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShrZXksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChjYW5vbmljYWxLZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXJpUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCAndXJpIHBhcmFtZXRlcnMgbXVzdCBiZSBhIG1hcCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV91cmlfcGFyYW1ldGVycyhyZXNvdXJjZVswXS52YWx1ZSwgcHJvcGVydHlbMV0sIGFsbG93UGFyYW1ldGVyS2V5cywgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlVXJpUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJhc2VVcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgJ2Jhc2UgdXJpIHBhcmFtZXRlcnMgZGVmaW5lZCB3aGVuIHRoZXJlIGlzIG5vIGJhc2VVcmknLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgJ2Jhc2UgdXJpIHBhcmFtZXRlcnMgbXVzdCBiZSBhIG1hcCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV91cmlfcGFyYW1ldGVycyh0aGlzLmJhc2VVcmksIHByb3BlcnR5WzFdLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX3R5cGVfcHJvcGVydHkocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVzYWdlXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoIWFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ1wiICsgcHJvcGVydHlbMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIHJlc291cmNlXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlY3VyZWRCeVwiOlxuICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX3NlY3VyZWRfYnkocHJvcGVydHkpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5OiAnXCIgKyBwcm9wZXJ0eVswXS52YWx1ZSArIChcIicgaXMgaW52YWxpZCBpbiBhIFwiICsgY29udGV4dCksIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3NlY3VyZWRfYnkgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgdmFyIHNlY1NjaGVtZSwgc2VjU2NoZW1lcywgc2VjdXJpdHlTY2hlbWVOYW1lLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCF1dGlsLmlzU2VxdWVuY2UocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eVNjaGVtZScsIG51bGwsIFwicHJvcGVydHkgJ3NlY3VyZWRCeScgbXVzdCBiZSBhbiBhcnJheVwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHNlY1NjaGVtZXMgPSB0aGlzLmdldF9saXN0X3ZhbHVlcyhwcm9wZXJ0eVsxXS52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5oYXNEdXBsaWNhdGVzKHNlY1NjaGVtZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eVNjaGVtZSBjb25zdW1wdGlvbicsIG51bGwsICdzZWN1cml0eVNjaGVtZXMgY2FuIG9ubHkgYmUgcmVmZXJlbmNlZCBvbmNlIGluIGEgc2VjdXJlZEJ5IHByb3BlcnR5JywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgc2VjU2NoZW1lID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAodXRpbC5pc1NlcXVlbmNlKHNlY1NjaGVtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHlTY2hlbWUgY29uc3VtcHRpb24nLCBudWxsLCAnc2VjdXJpdHlTY2hlbWUgcmVmZXJlbmNlIGNhbm5vdCBiZSBhbiBhcnJheScsIHNlY1NjaGVtZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHNlY1NjaGVtZSkpIHtcbiAgICAgICAgICBzZWN1cml0eVNjaGVtZU5hbWUgPSB0aGlzLmtleV9vcl92YWx1ZShzZWNTY2hlbWUpO1xuICAgICAgICAgIGlmICghdGhpcy5nZXRfc2VjdXJpdHlfc2NoZW1lKHNlY3VyaXR5U2NoZW1lTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eVNjaGVtZSBjb25zdW1wdGlvbicsIG51bGwsICd0aGVyZSBpcyBubyBzZWN1cml0eVNjaGVtZSBuYW1lZCAnICsgc2VjdXJpdHlTY2hlbWVOYW1lLCBzZWNTY2hlbWUuc3RhcnRfbWFyayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcHJvdG9jb2xzX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm90b2NvbCwgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIXV0aWwuaXNTZXF1ZW5jZShwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHByb3RvY29scycsIG51bGwsICdwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5JywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvdG9jb2wgPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwcm90b2NvbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcHJvdG9jb2xzJywgbnVsbCwgJ3ZhbHVlIG11c3QgYmUgYSBzdHJpbmcnLCBwcm90b2NvbC5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9yZWYyID0gcHJvdG9jb2wudmFsdWUpICE9PSAnSFRUUCcgJiYgX3JlZjIgIT09ICdIVFRQUycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcHJvdG9jb2xzJywgbnVsbCwgJ29ubHkgSFRUUCBhbmQgSFRUUFMgdmFsdWVzIGFyZSBhbGxvd2VkJywgcHJvdG9jb2wuc3RhcnRfbWFyayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfdHlwZV9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICB2YXIgcGFyYW1ldGVyLCB0eXBlTmFtZSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghKHV0aWwuaXNNYXBwaW5nKHByb3BlcnR5WzFdKSB8fCB1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGVzJywgbnVsbCwgXCJwcm9wZXJ0eSAndHlwZScgbXVzdCBiZSBhIHN0cmluZyBvciBhIG1hcFwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5WzFdLnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZXMnLCBudWxsLCAnYSByZXNvdXJjZSBvciByZXNvdXJjZVR5cGUgY2FuIGluaGVyaXQgZnJvbSBhIHNpbmdsZSByZXNvdXJjZVR5cGUnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZU5hbWUgPSB0aGlzLmtleV9vcl92YWx1ZShwcm9wZXJ0eVsxXSk7XG4gICAgICBpZiAoISh0eXBlTmFtZSAhPSBudWxsID8gdHlwZU5hbWUudHJpbSgpIDogdm9pZCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZSBjb25zdW1wdGlvbicsIG51bGwsICdyZXNvdXJjZSB0eXBlIG5hbWUgbXVzdCBiZSBwcm92aWRlZCcsIHByb3BlcnR5WzFdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5pc1BhcmFtZXRlcktleVZhbHVlKHR5cGVOYW1lKSB8fCB0aGlzLmdldF90eXBlKHR5cGVOYW1lKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGUgY29uc3VtcHRpb24nLCBudWxsLCBcInRoZXJlIGlzIG5vIHJlc291cmNlIHR5cGUgbmFtZWQgXCIgKyB0eXBlTmFtZSwgcHJvcGVydHlbMV0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc01hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwYXJhbWV0ZXIgPSBfcmVmMVtfaV07XG4gICAgICAgICAgaWYgKCEodXRpbC5pc051bGwocGFyYW1ldGVyWzFdKSB8fCB1dGlsLmlzTWFwcGluZyhwYXJhbWV0ZXJbMV0pKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIGNvbnN1bXB0aW9uJywgbnVsbCwgJ3Jlc291cmNlIHR5cGUgcGFyYW1ldGVycyBtdXN0IGJlIGluIGEgbWFwJywgcGFyYW1ldGVyWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9tZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGFsbG93UGFyYW1ldGVyS2V5cywgY29udGV4dCkge1xuICAgICAgdmFyIGNhbm9uaWNhbEtleSwga2V5LCBtZXRob2RQcm9wZXJ0aWVzLCBwcm9wZXJ0eSwgdmFsaWQsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRleHQgPSAnbWV0aG9kJztcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTnVsbChtZXRob2RbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobWV0aG9kWzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgbWV0aG9kcycsIG51bGwsIFwibWV0aG9kIG11c3QgYmUgYSBtYXBcIiwgbWV0aG9kWzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgbWV0aG9kUHJvcGVydGllcyA9IHt9O1xuICAgICAgX3JlZjEgPSBtZXRob2RbMV0udmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYxW19pXTtcbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhtZXRob2RQcm9wZXJ0aWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgdHJ1ZSksIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyBtZXRob2QnLCBcInByb3BlcnR5IGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVfY29tbW9uX3Byb3BlcnRpZXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgY29udGV4dCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBwcm9wZXJ0eVswXS52YWx1ZTtcbiAgICAgICAgY2Fub25pY2FsS2V5ID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUoa2V5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoY2Fub25pY2FsS2V5KSB7XG4gICAgICAgICAgY2FzZSAnaGVhZGVycyc6XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlX2hlYWRlcnMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdxdWVyeVBhcmFtZXRlcnMnOlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9xdWVyeV9wYXJhbXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfYm9keShwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZXNwb25zZXMnOlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9yZXNwb25zZXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdiYXNlVXJpUGFyYW1ldGVycyc6XG4gICAgICAgICAgICBpZiAoIXRoaXMuYmFzZVVyaSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCAnYmFzZSB1cmkgcGFyYW1ldGVycyBkZWZpbmVkIHdoZW4gdGhlcmUgaXMgbm8gYmFzZVVyaScsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCAnYmFzZSB1cmkgcGFyYW1ldGVycyBtdXN0IGJlIGEgbWFwJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3VyaV9wYXJhbWV0ZXJzKHRoaXMuYmFzZVVyaSwgcHJvcGVydHlbMV0sIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwcm90b2NvbHMnOlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9wcm90b2NvbHNfcHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdzZWN1cmVkQnknOlxuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX3NlY3VyZWRfYnkocHJvcGVydHkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3VzYWdlJzpcbiAgICAgICAgICAgIGlmICghKGFsbG93UGFyYW1ldGVyS2V5cyAmJiBjb250ZXh0ID09PSAndHJhaXQnKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ3VzYWdlJyBpcyBpbnZhbGlkIGluIGEgXCIgKyBjb250ZXh0LCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5OiAnXCIgKyBwcm9wZXJ0eVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgXCIgKyBjb250ZXh0LCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3Jlc3BvbnNlcyA9IGZ1bmN0aW9uKHJlc3BvbnNlcywgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgcmVzcG9uc2UsIHJlc3BvbnNlVmFsdWVzLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKHV0aWwuaXNOdWxsKHJlc3BvbnNlc1sxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhyZXNwb25zZXNbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBudWxsLCBcInByb3BlcnR5OiAncmVzcG9uc2VzJyBtdXN0IGJlIGEgbWFwXCIsIHJlc3BvbnNlc1swXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlVmFsdWVzID0ge307XG4gICAgICBfcmVmMSA9IHJlc3BvbnNlc1sxXS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHJlc3BvbnNlID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocmVzcG9uc2VbMV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIG51bGwsICdlYWNoIHJlc3BvbnNlIG11c3QgYmUgYSBtYXAnLCByZXNwb25zZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHJlc3BvbnNlVmFsdWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShyZXNwb25zZVswXS52YWx1ZSwgdHJ1ZSksIHJlc3BvbnNlWzBdLCAnd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBcInJlc3BvbnNlIGNvZGUgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfcmVzcG9uc2UocmVzcG9uc2UsIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3F1ZXJ5X3BhcmFtcyA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBwYXJhbSwgcXVlcnlQYXJhbWV0ZXJzLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKHV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcXVlcnkgcGFyYW1ldGVycycsIG51bGwsIFwicHJvcGVydHk6ICdxdWVyeVBhcmFtZXRlcnMnIG11c3QgYmUgYSBtYXBcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJhbSA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCEodXRpbC5pc051bGxhYmxlTWFwcGluZyhwYXJhbVsxXSkgfHwgdXRpbC5pc051bGxhYmxlU2VxdWVuY2UocGFyYW1bMV0pKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBxdWVyeSBwYXJhbWV0ZXJzJywgbnVsbCwgXCJlYWNoIHF1ZXJ5IHBhcmFtZXRlciBtdXN0IGJlIGEgbWFwXCIsIHBhcmFtWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocXVlcnlQYXJhbWV0ZXJzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwYXJhbVswXS52YWx1ZSwgdHJ1ZSksIHBhcmFtWzBdLCAnd2hpbGUgdmFsaWRhdGluZyBxdWVyeSBwYXJhbWV0ZXInLCBcInBhcmFtZXRlciBuYW1lIGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkX2NvbW1vbl9wYXJhbWV0ZXJfcHJvcGVydGllcyhwYXJhbVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfZm9ybV9wYXJhbXMgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgZm9ybVBhcmFtZXRlcnMsIHBhcmFtLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKHV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcXVlcnkgcGFyYW1ldGVycycsIG51bGwsIFwicHJvcGVydHk6ICdmb3JtUGFyYW1ldGVycycgbXVzdCBiZSBhIG1hcFwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGZvcm1QYXJhbWV0ZXJzID0ge307XG4gICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFyYW0gPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICghKHV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocGFyYW1bMV0pIHx8IHV0aWwuaXNOdWxsYWJsZVNlcXVlbmNlKHBhcmFtWzFdKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcXVlcnkgcGFyYW1ldGVycycsIG51bGwsICdlYWNoIGZvcm0gcGFyYW1ldGVyIG11c3QgYmUgYSBtYXAnLCBwYXJhbVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKGZvcm1QYXJhbWV0ZXJzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwYXJhbVswXS52YWx1ZSwgdHJ1ZSksIHBhcmFtWzBdLCAnd2hpbGUgdmFsaWRhdGluZyBmb3JtIHBhcmFtZXRlcicsIFwicGFyYW1ldGVyIG5hbWUgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRfY29tbW9uX3BhcmFtZXRlcl9wcm9wZXJ0aWVzKHBhcmFtWzFdLCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9oZWFkZXJzID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIGhlYWRlck5hbWVzLCBwYXJhbSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICh1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGhlYWRlcnMnLCBudWxsLCBcInByb3BlcnR5OiAnaGVhZGVycycgbXVzdCBiZSBhIG1hcFwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlck5hbWVzID0ge307XG4gICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFyYW0gPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICghKHV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocGFyYW1bMV0pIHx8IHV0aWwuaXNOdWxsYWJsZVNlcXVlbmNlKHBhcmFtWzFdKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcXVlcnkgcGFyYW1ldGVycycsIG51bGwsIFwiZWFjaCBoZWFkZXIgbXVzdCBiZSBhIG1hcFwiLCBwYXJhbVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKGhlYWRlck5hbWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwYXJhbVswXS52YWx1ZSwgdHJ1ZSksIHBhcmFtWzBdLCAnd2hpbGUgdmFsaWRhdGluZyBoZWFkZXJzJywgXCJoZWFkZXIgbmFtZSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZF9jb21tb25fcGFyYW1ldGVyX3Byb3BlcnRpZXMocGFyYW1bMV0sIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3Jlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIGNhbm9uaWNhbEtleSwgcHJvcGVydHksIHJlc3BvbnNlQ29kZSwgcmVzcG9uc2VQcm9wZXJ0aWVzLCB2YWxpZCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjEsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIGlmICh1dGlsLmlzU2VxdWVuY2UocmVzcG9uc2VbMF0pKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2VbMF0udmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIG51bGwsICd0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSByZXNwb25zZSBjb2RlJywgcmVzcG9uc2VbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZjEgPSByZXNwb25zZVswXS52YWx1ZTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHJlc3BvbnNlQ29kZSA9IF9yZWYxW19pXTtcbiAgICAgICAgICBpZiAoISh0aGlzLmlzUGFyYW1ldGVyS2V5KHJlc3BvbnNlQ29kZSkgfHwgdXRpbC5pc0ludGVnZXIocmVzcG9uc2VDb2RlKSB8fCAhaXNOYU4odGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocmVzcG9uc2VDb2RlLCBhbGxvd1BhcmFtZXRlcktleXMpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBudWxsLCBcImVhY2ggcmVzcG9uc2Uga2V5IG11c3QgYmUgYW4gaW50ZWdlclwiLCByZXNwb25zZUNvZGUuc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEodGhpcy5pc1BhcmFtZXRlcktleShyZXNwb25zZSkgfHwgdXRpbC5pc0ludGVnZXIocmVzcG9uc2VbMF0pIHx8ICFpc05hTih0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShyZXNwb25zZVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBudWxsLCBcImVhY2ggcmVzcG9uc2Uga2V5IG11c3QgYmUgYW4gaW50ZWdlclwiLCByZXNwb25zZVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhyZXNwb25zZVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIG51bGwsIFwiZWFjaCByZXNwb25zZSBwcm9wZXJ0eSBtdXN0IGJlIGEgbWFwXCIsIHJlc3BvbnNlWzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHJlc3BvbnNlWzFdKSkge1xuICAgICAgICByZXNwb25zZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgX3JlZjIgPSByZXNwb25zZVsxXS52YWx1ZTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjIubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBfcmVmMltfal07XG4gICAgICAgICAgY2Fub25pY2FsS2V5ID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhyZXNwb25zZVByb3BlcnRpZXMsIGNhbm9uaWNhbEtleSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIFwicHJvcGVydHkgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNQYXJhbWV0ZXJLZXkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNwb25zZXMnLCBudWxsLCAncHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhIHN0cmluZycsIHJlc3BvbnNlWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjYW5vbmljYWxLZXkpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfYm9keShwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBudWxsLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJoZWFkZXJzXCI6XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHkgJ2hlYWRlcnMnIG11c3QgYmUgYSBtYXBcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9oZWFkZXJzKHByb3BlcnR5KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlJywgbnVsbCwgXCJwcm9wZXJ0eTogJ1wiICsgcHJvcGVydHlbMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIHJlc3BvbnNlXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5pc0h0dHBNZXRob2QgPSBmdW5jdGlvbih2YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgX3JlZjE7XG4gICAgICBpZiAoYWxsb3dQYXJhbWV0ZXJLZXlzID09IG51bGwpIHtcbiAgICAgICAgYWxsb3dQYXJhbWV0ZXJLZXlzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZSh2YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgcmV0dXJuIChfcmVmMSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkpID09PSAnb3B0aW9ucycgfHwgX3JlZjEgPT09ICdnZXQnIHx8IF9yZWYxID09PSAnaGVhZCcgfHwgX3JlZjEgPT09ICdwb3N0JyB8fCBfcmVmMSA9PT0gJ3B1dCcgfHwgX3JlZjEgPT09ICdkZWxldGUnIHx8IF9yZWYxID09PSAndHJhY2UnIHx8IF9yZWYxID09PSAnY29ubmVjdCcgfHwgX3JlZjEgPT09ICdwYXRjaCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaXNQYXJhbWV0ZXJWYWx1ZSA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1BhcmFtZXRlcktleShwcm9wZXJ0eSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmlzUGFyYW1ldGVyS2V5ID0gZnVuY3Rpb24ocHJvcGVydHksIGNoZWNrS2V5KSB7XG4gICAgICB2YXIgb2Zmc2V0O1xuICAgICAgaWYgKGNoZWNrS2V5ID09IG51bGwpIHtcbiAgICAgICAgY2hlY2tLZXkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gY2hlY2tLZXkgPyAwIDogMTtcbiAgICAgIGlmICghKGNoZWNrS2V5IHx8IHV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1BhcmFtZXRlcktleVZhbHVlKHByb3BlcnR5W29mZnNldF0udmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eVtvZmZzZXRdLnZhbHVlLm1hdGNoKC88PFxccyooW15cXHxcXHM+XSspXFxzKlxcfC4qXFxzKj4+L2cpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXInLCBudWxsLCBcInVua25vd24gZnVuY3Rpb24gYXBwbGllZCB0byBwcm9wZXJ0eSBuYW1lXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmlzUGFyYW1ldGVyS2V5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLm1hdGNoKC88PFxccyooW15cXHxcXHM+XSspXFxzKj4+L2cpIHx8IHZhbHVlLm1hdGNoKC88PFxccyooW15cXHxcXHM+XSspXFxzKihcXHxcXHMqXFwhXFxzKihzaW5ndWxhcml6ZXxwbHVyYWxpemUpKT9cXHMqPj4vZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfYm9keSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIGJvZHlNb2RlLCBpc1Jlc3BvbnNlQm9keSkge1xuICAgICAgdmFyIGJvZHlQcm9wZXJ0aWVzLCBib2R5UHJvcGVydHksIGNhbm9uaWNhbFByb3BlcnR5LCBpbXBsaWNpdE1vZGUsIGtleSwgc3RhcnRfbWFyaywgdmFsaWQsIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIGlmIChib2R5TW9kZSA9PSBudWxsKSB7XG4gICAgICAgIGJvZHlNb2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcInByb3BlcnR5OiBib2R5IHNwZWNpZmljYXRpb24gbXVzdCBiZSBhIG1hcFwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGltcGxpY2l0TW9kZSA9IFtcImltcGxpY2l0XCIsIFwiZm9yY2VkSW1wbGljaXRcIl07XG4gICAgICBib2R5UHJvcGVydGllcyA9IHt9O1xuICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgYm9keVByb3BlcnR5ID0gX3JlZjFbX2ldO1xuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKGJvZHlQcm9wZXJ0aWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShib2R5UHJvcGVydHlbMF0udmFsdWUsIHRydWUpLCBib2R5UHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBcInByb3BlcnR5IGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNQYXJhbWV0ZXJLZXkoYm9keVByb3BlcnR5KSkge1xuICAgICAgICAgIGlmICghYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwicHJvcGVydHkgJ1wiICsgYm9keVByb3BlcnR5WzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSByZXNvdXJjZVwiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJvZHlQcm9wZXJ0eVswXS52YWx1ZS5tYXRjaCgvXlteXFwvXStcXC9bXlxcL10rJC8pKSB7XG4gICAgICAgICAgaWYgKGJvZHlNb2RlICYmIGJvZHlNb2RlICE9PSBcImV4cGxpY2l0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJub3QgY29tcGF0aWJsZSB3aXRoIGltcGxpY2l0IGRlZmF1bHQgTWVkaWEgVHlwZVwiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHlNb2RlID0gXCJleHBsaWNpdFwiO1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVfYm9keShib2R5UHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgXCJmb3JjZWRJbXBsaWNpdFwiLCBpc1Jlc3BvbnNlQm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gYm9keVByb3BlcnR5WzBdLnZhbHVlO1xuICAgICAgICAgIGNhbm9uaWNhbFByb3BlcnR5ID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUoa2V5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbFByb3BlcnR5KSB7XG4gICAgICAgICAgICBjYXNlIFwiZm9ybVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgICAgaWYgKGJvZHlNb2RlICYmIF9faW5kZXhPZi5jYWxsKGltcGxpY2l0TW9kZSwgYm9keU1vZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJub3QgY29tcGF0aWJsZSB3aXRoIGV4cGxpY2l0IE1lZGlhIFR5cGVcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChib2R5TW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm9keU1vZGUgPSBcImltcGxpY2l0XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9mb3JtX3BhcmFtcyhib2R5UHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJleGFtcGxlXCI6XG4gICAgICAgICAgICAgIGlmIChib2R5TW9kZSAmJiBfX2luZGV4T2YuY2FsbChpbXBsaWNpdE1vZGUsIGJvZHlNb2RlKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwibm90IGNvbXBhdGlibGUgd2l0aCBleHBsaWNpdCBNZWRpYSBUeXBlXCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYm9keU1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvZHlNb2RlID0gXCJpbXBsaWNpdFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihib2R5UHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcImV4YW1wbGUgbXVzdCBiZSBhIHN0cmluZ1wiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NoZW1hXCI6XG4gICAgICAgICAgICAgIGlmIChib2R5TW9kZSAmJiBfX2luZGV4T2YuY2FsbChpbXBsaWNpdE1vZGUsIGJvZHlNb2RlKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwibm90IGNvbXBhdGlibGUgd2l0aCBleHBsaWNpdCBNZWRpYSBUeXBlXCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYm9keU1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvZHlNb2RlID0gXCJpbXBsaWNpdFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihib2R5UHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcInNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKGJvZHlQcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJwcm9wZXJ0eTogJ1wiICsgYm9keVByb3BlcnR5WzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSBib2R5XCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwiZm9ybVBhcmFtZXRlcnNcIiBpbiBib2R5UHJvcGVydGllcykge1xuICAgICAgICBzdGFydF9tYXJrID0gYm9keVByb3BlcnRpZXMuZm9ybVBhcmFtZXRlcnMuc3RhcnRfbWFyaztcbiAgICAgICAgaWYgKGlzUmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcImZvcm1QYXJhbWV0ZXJzIGNhbm5vdCBiZSB1c2VkIHRvIGRlc2NyaWJlIHJlc3BvbnNlIGJvZGllc1wiLCBzdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJzY2hlbWFcIiBpbiBib2R5UHJvcGVydGllcyB8fCBcImV4YW1wbGVcIiBpbiBib2R5UHJvcGVydGllcykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJmb3JtUGFyYW1ldGVycyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIHRoZSBleGFtcGxlIG9yIHNjaGVtYSBwcm9wZXJ0aWVzXCIsIHN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYm9keU1vZGUgPT09IFwiaW1wbGljaXRcIikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0X21lZGlhX3R5cGUoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJib2R5IHRyaWVzIHRvIHVzZSBkZWZhdWx0IE1lZGlhIFR5cGUsIGJ1dCBtZWRpYVR5cGUgaXMgbnVsbFwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlU2NoZW1hID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHZhciBlcnJvciwgbGludCwgbWFyaywgc2NoZW1hO1xuICAgICAgaWYgKHRoaXMuaXNYbWxTY2hlbWEocHJvcGVydHkudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNKc29uU2NoZW1hKHByb3BlcnR5LnZhbHVlKSkge1xuICAgICAgICBsaW50ID0ganNvbmxpbnQocHJvcGVydHkudmFsdWUpO1xuICAgICAgICBpZiAobGludC5lcnJvcikge1xuICAgICAgICAgIG1hcmsgPSB0aGlzLmNyZWF0ZV9tYXJrKHByb3BlcnR5LnN0YXJ0X21hcmsubGluZSArIGxpbnQubGluZSwgMCk7XG4gICAgICAgICAgaWYgKHByb3BlcnR5LmVuZF9tYXJrLmxpbmUgPT09IG1hcmsubGluZSAmJiBwcm9wZXJ0eS5lbmRfbWFyay5jb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAgIG1hcmsubGluZS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwic2NoZW1hIGlzIG5vdCB2YWxpZCBKU09OIGVycm9yOiAnXCIgKyBsaW50LmVycm9yICsgXCInXCIsIG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVtYSA9IEpTT04ucGFyc2UocHJvcGVydHkudmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwic2NoZW1hIGlzIG5vdCB2YWxpZCBKU09OIGVycm9yOiAnXCIgKyBlcnJvciArIFwiJ1wiLCBwcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmlzSnNvblNjaGVtYSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyAhPSBudWxsID8gc3RyaW5nLm1hdGNoKC9eXFxzKlxcey8pIDogdm9pZCAwO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmlzWG1sU2NoZW1hID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICE9IG51bGwgPyBzdHJpbmcubWF0Y2goL15cXHMqKDxcXD94bWxbXj5dKz4pP1tcXHNcXG5dKjx4czpzY2hlbWEvKSA6IHZvaWQgMDtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9jb21tb25fcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIGNvbnRleHQpIHtcbiAgICAgIHZhciB1c2UsIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIGlmICh0aGlzLmlzUGFyYW1ldGVyS2V5KHByb3BlcnR5KSkge1xuICAgICAgICBpZiAoIWFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5ICdcIiArIHByb3BlcnR5WzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSByZXNvdXJjZVwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwiZGlzcGxheU5hbWVcIjpcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSAnbWV0aG9kJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5ICdkaXNwbGF5TmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGNhc2UgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eSAnZGVzY3JpcHRpb24nIG11c3QgYmUgYSBzdHJpbmdcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFwiaXNcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NlcXVlbmNlKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eSAnaXMnIG11c3QgYmUgYW4gYXJyYXlcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICB1c2UgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfdHJhaXRfdXNlKHVzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3RyYWl0X3VzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXIsIHRyYWl0TmFtZSwgdHJhaXRWYWx1ZSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghKHV0aWwuaXNTY2FsYXIobm9kZSkgfHwgdXRpbC5pc01hcHBpbmcobm9kZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBjb25zdW1wdGlvbicsIG51bGwsICd0cmFpdCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbWFwJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRyYWl0TmFtZSA9IHRoaXMua2V5X29yX3ZhbHVlKG5vZGUpO1xuICAgICAgaWYgKCEodHJhaXROYW1lICE9IG51bGwgPyB0cmFpdE5hbWUudHJpbSgpIDogdm9pZCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgY29uc3VtcHRpb24nLCBudWxsLCAndHJhaXQgbmFtZSBtdXN0IGJlIHByb3ZpZGVkJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMuaXNQYXJhbWV0ZXJLZXlWYWx1ZSh0cmFpdE5hbWUpIHx8IHRoaXMuZ2V0X3RyYWl0KHRyYWl0TmFtZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBjb25zdW1wdGlvbicsIG51bGwsIFwidGhlcmUgaXMgbm8gdHJhaXQgbmFtZWQgXCIgKyB0cmFpdE5hbWUsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc1NjYWxhcihub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cmFpdFZhbHVlID0gbm9kZS52YWx1ZVswXVsxXTtcbiAgICAgIGlmICghKHV0aWwuaXNOdWxsKHRyYWl0VmFsdWUpIHx8IHV0aWwuaXNNYXBwaW5nKHRyYWl0VmFsdWUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgY29uc3VtcHRpb24nLCBudWxsLCAndHJhaXQgbXVzdCBiZSBhIG1hcCcsIHRyYWl0VmFsdWUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc051bGwodHJhaXRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSB0cmFpdFZhbHVlLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFyYW1ldGVyID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocGFyYW1ldGVyWzFdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBjb25zdW1wdGlvbicsIG51bGwsICdwYXJhbWV0ZXIgdmFsdWUgbXVzdCBiZSBhIHNjYWxhcicsIHBhcmFtZXRlclsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5jaGlsZF9tZXRob2RzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghKG5vZGUgJiYgdXRpbC5pc01hcHBpbmcobm9kZSkpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmlzSHR0cE1ldGhvZChjaGlsZE5vZGVbMF0udmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaGFzX3Byb3BlcnR5ID0gZnVuY3Rpb24obm9kZSwgcHJvcGVydHkpIHtcbiAgICAgIGlmIChub2RlICYmIHV0aWwuaXNNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlLnNvbWUoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVswXS52YWx1ZSAmJiB0eXBlb2YgY2hpbGROb2RlWzBdLnZhbHVlICE9PSBcIm9iamVjdFwiICYmIGNoaWxkTm9kZVswXS52YWx1ZSA9PT0gcHJvcGVydHk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnByb3BlcnR5X3ZhbHVlID0gZnVuY3Rpb24obm9kZSwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWx0ZXJlZE5vZGVzO1xuICAgICAgZmlsdGVyZWROb2RlcyA9IG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNoaWxkTm9kZVswXS52YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiBjaGlsZE5vZGVbMF0udmFsdWUgPT09IHByb3BlcnR5O1xuICAgICAgfSk7XG4gICAgICBpZiAoZmlsdGVyZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkTm9kZXNbMF1bMV0udmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5ID0gZnVuY3Rpb24obm9kZSwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWx0ZXJlZE5vZGVzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAobm9kZSAmJiB1dGlsLmlzTWFwcGluZyhub2RlKSkge1xuICAgICAgICBmaWx0ZXJlZE5vZGVzID0gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuaXNTdHJpbmcoY2hpbGROb2RlWzBdKSAmJiBjaGlsZE5vZGVbMF0udmFsdWUgPT09IHByb3BlcnR5O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpbHRlcmVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChmaWx0ZXJlZE5vZGVzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZE5vZGVzWzBdWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmdldF9wcm9wZXJ0aWVzID0gZnVuY3Rpb24obm9kZSwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wLCBwcm9wZXJ0aWVzLCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICBpZiAobm9kZSAmJiB1dGlsLmlzTWFwcGluZyhub2RlKSkge1xuICAgICAgICBfcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwcm9wID0gX3JlZjFbX2ldO1xuICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHByb3BbMF0pICYmIHByb3BbMF0udmFsdWUgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmNvbmNhdCh0aGlzLmdldF9wcm9wZXJ0aWVzKHByb3BbMV0sIHByb3BlcnR5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZF9hYnNvbHV0ZV91cmlzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJlcGVhdGVkVXJpLCB1cmlzO1xuICAgICAgdXJpcyA9IHRoaXMuZ2V0X2Fic29sdXRlX3VyaXMobm9kZSk7XG4gICAgICBpZiAocmVwZWF0ZWRVcmkgPSB0aGlzLmhhc0R1cGxpY2F0ZXNVcmlzKHVyaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBjb25zdW1wdGlvbicsIG51bGwsIFwidHdvIHJlc291cmNlcyBzaGFyZSBzYW1lIFVSSSBcIiArIHJlcGVhdGVkVXJpLnVyaSwgcmVwZWF0ZWRVcmkubWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0X2Fic29sdXRlX3VyaXMgPSBmdW5jdGlvbihub2RlLCBwYXJlbnRQYXRoKSB7XG4gICAgICB2YXIgY2hpbGRSZXNvdXJjZSwgY2hpbGRfcmVzb3VyY2VzLCByZXNwb25zZSwgdXJpLCBfaSwgX2xlbjtcbiAgICAgIHJlc3BvbnNlID0gW107XG4gICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsICdyZXNvdXJjZSBpcyBub3QgYSBtYXAnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgY2hpbGRfcmVzb3VyY2VzID0gdGhpcy5jaGlsZF9yZXNvdXJjZXMobm9kZSk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNoaWxkX3Jlc291cmNlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjaGlsZFJlc291cmNlID0gY2hpbGRfcmVzb3VyY2VzW19pXTtcbiAgICAgICAgaWYgKHBhcmVudFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHVyaSA9IHBhcmVudFBhdGggKyBjaGlsZFJlc291cmNlWzBdLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVyaSA9IGNoaWxkUmVzb3VyY2VbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2UucHVzaCh7XG4gICAgICAgICAgdXJpOiB1cmksXG4gICAgICAgICAgbWFyazogY2hpbGRSZXNvdXJjZVswXS5zdGFydF9tYXJrXG4gICAgICAgIH0pO1xuICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmNvbmNhdCh0aGlzLmdldF9hYnNvbHV0ZV91cmlzKGNoaWxkUmVzb3VyY2VbMV0sIHVyaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmtleV9vcl92YWx1ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwb3NzaWJsZUtleU5hbWUsIF9yZWYxLCBfcmVmMiwgX3JlZjM7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNjYWxhck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgIHBvc3NpYmxlS2V5TmFtZSA9IG5vZGUgIT0gbnVsbCA/IChfcmVmMSA9IG5vZGUudmFsdWUpICE9IG51bGwgPyAoX3JlZjIgPSBfcmVmMVswXSkgIT0gbnVsbCA/IChfcmVmMyA9IF9yZWYyWzBdKSAhPSBudWxsID8gX3JlZjMudmFsdWUgOiB2b2lkIDAgOiB2b2lkIDAgOiB2b2lkIDAgOiB2b2lkIDA7XG4gICAgICAgIGlmIChwb3NzaWJsZUtleU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcG9zc2libGVLZXlOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWx1ZV9vcl91bmRlZmluZWQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9iYXNlX3VyaSA9IGZ1bmN0aW9uKGJhc2VVcmlOb2RlKSB7XG4gICAgICB2YXIgYmFzZVVyaSwgZXJyLCBleHByZXNzaW9ucywgcHJvdG9jb2wsIHRlbXBsYXRlLCBfcmVmMSwgX3JlZjI7XG4gICAgICBiYXNlVXJpID0gKF9yZWYxID0gYmFzZVVyaU5vZGUudmFsdWUpICE9IG51bGwgPyBfcmVmMS50cmltKCkgOiB2b2lkIDA7XG4gICAgICBpZiAoIWJhc2VVcmkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJhc2VVcmknLCBudWxsLCAnYmFzZVVyaSBtdXN0IGhhdmUgYSB2YWx1ZScsIGJhc2VVcmlOb2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcHJvdG9jb2wgPSAoKHVybC5wYXJzZShiYXNlVXJpKSkucHJvdG9jb2wgfHwgJ2h0dHA6Jykuc2xpY2UoMCwgLTEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAocHJvdG9jb2wgIT09ICdIVFRQJyAmJiBwcm90b2NvbCAhPT0gJ0hUVFBTJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYmFzZVVyaScsIG51bGwsICdiYXNlVXJpIHByb3RvY29sIG11c3QgYmUgZWl0aGVyIEhUVFAgb3IgSFRUUFMnLCBiYXNlVXJpTm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRlbXBsYXRlID0gdXJpdGVtcGxhdGUucGFyc2UoYmFzZVVyaSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYmFzZVVyaScsIG51bGwsIGVyciAhPSBudWxsID8gKF9yZWYyID0gZXJyLm9wdGlvbnMpICE9IG51bGwgPyBfcmVmMi5tZXNzYWdlIDogdm9pZCAwIDogdm9pZCAwLCBiYXNlVXJpTm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGV4cHJlc3Npb25zID0gdGVtcGxhdGUuZXhwcmVzc2lvbnMuZmlsdGVyKGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuICd0ZW1wbGF0ZVRleHQnIGluIGV4cHI7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50ZW1wbGF0ZVRleHQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChleHByZXNzaW9ucywgJ3ZlcnNpb24nKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmdldF92YWxpZGF0aW9uX2Vycm9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvbl9lcnJvcnM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaXNfdmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb25fZXJyb3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5oYXNEdXBsaWNhdGVzVXJpcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICB2YXIgaXRlbSwgb3V0cHV0LCBfaSwgX2xlbjtcbiAgICAgIG91dHB1dCA9IHt9O1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBhcnJheS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpdGVtID0gYXJyYXlbX2ldO1xuICAgICAgICBpZiAoaXRlbS51cmkgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0W2l0ZW0udXJpXSA9IGl0ZW07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaGFzRHVwbGljYXRlcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICB2YXIgaXRlbSwgb3V0cHV0LCBfaSwgX2xlbjtcbiAgICAgIG91dHB1dCA9IHt9O1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBhcnJheS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpdGVtID0gYXJyYXlbX2ldO1xuICAgICAgICBpZiAoaXRlbSBpbiBvdXRwdXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRbaXRlbV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gVmFsaWRhdG9yO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKiFcbiAqIGluZmxlY3Rpb25cbiAqIENvcHlyaWdodChjKSAyMDExIEJlbiBMaW4gPGJlbkBkcmVhbWVyc2xhYi5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBBIHBvcnQgb2YgaW5mbGVjdGlvbi1qcyB0byBub2RlLmpzIG1vZHVsZS5cbiAqL1xuXG4oIGZ1bmN0aW9uICggcm9vdCwgZmFjdG9yeSApe1xuICBpZiggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICl7XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5ICk7XG4gIH1lbHNlIGlmKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfWVsc2V7XG4gICAgcm9vdC5pbmZsZWN0aW9uID0gZmFjdG9yeSgpO1xuICB9XG59KCB0aGlzLCBmdW5jdGlvbiAoKXtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgYSBsaXN0IG9mIG5vdW5zIHRoYXQgdXNlIHRoZSBzYW1lIGZvcm0gZm9yIGJvdGggc2luZ3VsYXIgYW5kIHBsdXJhbC5cbiAgICogICAgICAgICAgICAgIFRoaXMgbGlzdCBzaG91bGQgcmVtYWluIGVudGlyZWx5IGluIGxvd2VyIGNhc2UgdG8gY29ycmVjdGx5IG1hdGNoIFN0cmluZ3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgdW5jb3VudGFibGVfd29yZHMgPSBbXG4gICAgJ2VxdWlwbWVudCcsICdpbmZvcm1hdGlvbicsICdyaWNlJywgJ21vbmV5JywgJ3NwZWNpZXMnLFxuICAgICdzZXJpZXMnLCAnZmlzaCcsICdzaGVlcCcsICdtb29zZScsICdkZWVyJywgJ25ld3MnXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGVzZSBydWxlcyB0cmFuc2xhdGUgZnJvbSB0aGUgc2luZ3VsYXIgZm9ybSBvZiBhIG5vdW4gdG8gaXRzIHBsdXJhbCBmb3JtLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHBsdXJhbF9ydWxlcyA9IFtcblxuICAgIC8vIGRvIG5vdCByZXBsYWNlIGlmIGl0cyBhbHJlYWR5IGEgcGx1cmFsIHdvcmRcbiAgICBbIG5ldyBSZWdFeHAoICcobSllbiQnLCAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHBlKW9wbGUkJywgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjaGlsZClyZW4kJywgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW3RpXSlhJCcsICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKChhKW5hbHl8KGIpYXwoZClpYWdub3wocClhcmVudGhlfChwKXJvZ25vfChzKXlub3B8KHQpaGUpc2VzJCcsJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoaGl2ZSlzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh0aXZlKXMkJywgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGN1cnZlKXMkJywgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW2xyXSl2ZXMkJywgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbXmZvXSl2ZXMkJywgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFteYWVpb3V5XXxxdSlpZXMkJywgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcocyllcmllcyQnLCAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKW92aWVzJCcsICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpZXMkJywgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW218bF0paWNlJCcsICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidXMpZXMkJywgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG8pZXMkJywgICAgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoc2hvZSlzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjcmlzfGF4fHRlc3QpZXMkJywgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG9jdG9wfHZpcilpJCcsICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoYWxpYXN8c3RhdHVzKWVzJCcsICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJ14ob3gpZW4nLCAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHZlcnR8aW5kKWljZXMkJywgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcobWF0cilpY2VzJCcsICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhxdWl6KXplcyQnLCAgICAgICAgICdnaScgKV0sXG5cbiAgICAvLyBvcmlnaW5hbCBydWxlXG4gICAgWyBuZXcgUmVnRXhwKCAnKG0pYW4kJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgJyQxZW4nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHBlKXJzb24kJywgJ2dpJyApLCAgICAgICAgICAgICAgJyQxb3BsZScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoY2hpbGQpJCcsICdnaScgKSwgICAgICAgICAgICAgICAnJDFyZW4nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnXihveCkkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgJyQxZW4nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGF4fHRlc3QpaXMkJywgJ2dpJyApLCAgICAgICAgICAgJyQxZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG9jdG9wfHZpcil1cyQnLCAnZ2knICksICAgICAgICAgJyQxaScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoYWxpYXN8c3RhdHVzKSQnLCAnZ2knICksICAgICAgICAnJDFlcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoYnUpcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAnJDFzZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGJ1ZmZhbHx0b21hdHxwb3RhdClvJCcsICdnaScgKSwgJyQxb2VzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbdGldKXVtJCcsICdnaScgKSwgICAgICAgICAgICAgICckMWEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnc2lzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgJ3NlcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoPzooW15mXSlmZXwoW2xyXSlmKSQnLCAnZ2knICksICAnJDEkMnZlcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoaGl2ZSkkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAnJDFzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbXmFlaW91eV18cXUpeSQnLCAnZ2knICksICAgICAgICckMWllcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoeHxjaHxzc3xzaCkkJywgJ2dpJyApLCAgICAgICAgICAnJDFlcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcobWF0cnx2ZXJ0fGluZClpeHxleCQnLCAnZ2knICksICAnJDFpY2VzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbbXxsXSlvdXNlJCcsICdnaScgKSwgICAgICAgICAgICckMWljZScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcocXVpeikkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAnJDF6ZXMnIF0sXG5cbiAgICBbIG5ldyBSZWdFeHAoICdzJCcsICdnaScgKSwgJ3MnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnJCcsICdnaScgKSwgICdzJyBdXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGVzZSBydWxlcyB0cmFuc2xhdGUgZnJvbSB0aGUgcGx1cmFsIGZvcm0gb2YgYSBub3VuIHRvIGl0cyBzaW5ndWxhciBmb3JtLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHNpbmd1bGFyX3J1bGVzID0gW1xuXG4gICAgLy8gZG8gbm90IHJlcGxhY2UgaWYgaXRzIGFscmVhZHkgYSBzaW5ndWxhciB3b3JkXG4gICAgWyBuZXcgUmVnRXhwKCAnKG0pYW4kJywgICAgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHBlKXJzb24kJywgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGNoaWxkKSQnLCAgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnXihveCkkJywgICAgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGF4fHRlc3QpaXMkJywgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG9jdG9wfHZpcil1cyQnLCAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGFsaWFzfHN0YXR1cykkJywgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGJ1KXMkJywgICAgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGJ1ZmZhbHx0b21hdHxwb3RhdClvJCcsICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFt0aV0pdW0kJywgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnc2lzJCcsICAgICAgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKD86KFteZl0pZmV8KFtscl0pZikkJywgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGhpdmUpJCcsICAgICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFteYWVpb3V5XXxxdSl5JCcsICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpJCcsICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG1hdHJ8dmVydHxpbmQpaXh8ZXgkJywgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFttfGxdKW91c2UkJywgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHF1aXopJCcsICAgICAgICAgICAgICAgICdnaScgKV0sXG5cbiAgICAvLyBvcmlnaW5hbCBydWxlXG4gICAgWyBuZXcgUmVnRXhwKCAnKG0pZW4kJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFhbicgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcocGUpb3BsZSQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMXJzb24nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGNoaWxkKXJlbiQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFt0aV0pYSQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDF1bScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoKGEpbmFseXwoYilhfChkKWlhZ25vfChwKWFyZW50aGV8KHApcm9nbm98KHMpeW5vcHwodCloZSlzZXMkJywnZ2knICksICckMSQyc2lzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhoaXZlKXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh0aXZlKXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjdXJ2ZSlzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbbHJdKXZlcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxZicgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW15mb10pdmVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMWZlJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKW92aWVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxb3ZpZScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW15hZWlvdXldfHF1KWllcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMXknIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHMpZXJpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFlcmllcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoeHxjaHxzc3xzaCllcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW218bF0paWNlJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMW91c2UnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGJ1cyllcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG8pZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHNob2UpcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGNyaXN8YXh8dGVzdCllcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFpcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcob2N0b3B8dmlyKWkkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMXVzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhhbGlhc3xzdGF0dXMpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJ14ob3gpZW4nLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh2ZXJ0fGluZClpY2VzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxZXgnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG1hdHIpaWNlcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFpeCcgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcocXVpeil6ZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICdzcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICdzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnIF1cbiAgXTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgYSBsaXN0IG9mIHdvcmRzIHRoYXQgc2hvdWxkIG5vdCBiZSBjYXBpdGFsaXplZCBmb3IgdGl0bGUgY2FzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBub25fdGl0bGVjYXNlZF93b3JkcyA9IFtcbiAgICAnYW5kJywgJ29yJywgJ25vcicsICdhJywgJ2FuJywgJ3RoZScsICdzbycsICdidXQnLCAndG8nLCAnb2YnLCAnYXQnLCdieScsXG4gICAgJ2Zyb20nLCAnaW50bycsICdvbicsICdvbnRvJywgJ29mZicsICdvdXQnLCAnaW4nLCAnb3ZlcicsICd3aXRoJywgJ2ZvcidcbiAgXTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIFRoZXNlIGFyZSByZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBTdHJpbmcgZm9ybWF0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBpZF9zdWZmaXggICAgICAgICA9IG5ldyBSZWdFeHAoICcoX2lkc3xfaWQpJCcsICdnJyApO1xuICB2YXIgdW5kZXJiYXIgICAgICAgICAgPSBuZXcgUmVnRXhwKCAnXycsICdnJyApO1xuICB2YXIgc3BhY2Vfb3JfdW5kZXJiYXIgPSBuZXcgUmVnRXhwKCAnW1xcIF9dJywgJ2cnICk7XG4gIHZhciB1cHBlcmNhc2UgICAgICAgICA9IG5ldyBSZWdFeHAoICcoW0EtWl0pJywgJ2cnICk7XG4gIHZhciB1bmRlcmJhcl9wcmVmaXggICA9IG5ldyBSZWdFeHAoICdeXycgKTtcblxuICB2YXIgaW5mbGVjdG9yID0ge1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBhcHBsaWVzIHJ1bGVzIGJhc2VkIHJlcGxhY2VtZW50IHRvIGEgU3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gbW9kaWZ5IGFuZCByZXR1cm4gYmFzZWQgb24gdGhlIHBhc3NlZCBydWxlcy5cbiAgICogQHBhcmFtIHtBcnJheTogW1JlZ0V4cCwgU3RyaW5nXX0gcnVsZXMgUmVnZXhwIHRvIG1hdGNoIHBhaXJlZCB3aXRoIFN0cmluZyB0byB1c2UgZm9yIHJlcGxhY2VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXk6IFtTdHJpbmddfSBza2lwIFN0cmluZ3MgdG8gc2tpcCBpZiB0aGV5IG1hdGNoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvdmVycmlkZSBTdHJpbmcgdG8gcmV0dXJuIGFzIHRob3VnaCB0aGlzIG1ldGhvZCBzdWNjZWVkZWQgKHVzZWQgdG8gY29uZm9ybSB0byBBUElzKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm4gcGFzc2VkIFN0cmluZyBtb2RpZmllZCBieSBwYXNzZWQgcnVsZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB0aGlzLl9hcHBseV9ydWxlcyggJ2Nvd3MnLCBzaW5ndWxhcl9ydWxlcyApOyAvLyA9PT0gJ2NvdydcbiAgICovXG4gICAgX2FwcGx5X3J1bGVzIDogZnVuY3Rpb24gKCBzdHIsIHJ1bGVzLCBza2lwLCBvdmVycmlkZSApe1xuICAgICAgaWYoIG92ZXJyaWRlICl7XG4gICAgICAgIHN0ciA9IG92ZXJyaWRlO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHZhciBpZ25vcmUgPSAoIGluZmxlY3Rvci5pbmRleE9mKCBza2lwLCBzdHIudG9Mb3dlckNhc2UoKSkgPiAtMSApO1xuXG4gICAgICAgIGlmKCAhaWdub3JlICl7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciBqID0gcnVsZXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgICAgIGlmKCBzdHIubWF0Y2goIHJ1bGVzWyBpIF1bIDAgXSkpe1xuICAgICAgICAgICAgICBpZiggcnVsZXNbIGkgXVsgMSBdICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSggcnVsZXNbIGkgXVsgMCBdLCBydWxlc1sgaSBdWyAxIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGxldHMgdXMgZGV0ZWN0IGlmIGFuIEFycmF5IGNvbnRhaW5zIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBzdWJqZWN0IGFycmF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBPYmplY3QgdG8gbG9jYXRlIGluIHRoZSBBcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21faW5kZXggU3RhcnRzIGNoZWNraW5nIGZyb20gdGhpcyBwb3NpdGlvbiBpbiB0aGUgQXJyYXkuKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlX2Z1bmMgRnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIEFycmF5IGl0ZW0gdnMgcGFzc2VkIGl0ZW0uKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm4gaW5kZXggcG9zaXRpb24gaW4gdGhlIEFycmF5IG9mIHRoZSBwYXNzZWQgaXRlbS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmluZGV4T2YoWyAnaGknLCd0aGVyZScgXSwgJ2d1eXMnICk7IC8vID09PSAtMVxuICAgKiAgICAgaW5mbGVjdGlvbi5pbmRleE9mKFsgJ2hpJywndGhlcmUnIF0sICdoaScgKTsgLy8gPT09IDBcbiAgICovXG4gICAgaW5kZXhPZiA6IGZ1bmN0aW9uICggYXJyLCBpdGVtLCBmcm9tX2luZGV4LCBjb21wYXJlX2Z1bmMgKXtcbiAgICAgIGlmKCAhZnJvbV9pbmRleCApe1xuICAgICAgICBmcm9tX2luZGV4ID0gLTE7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGkgICAgID0gZnJvbV9pbmRleDtcbiAgICAgIHZhciBqICAgICA9IGFyci5sZW5ndGg7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIGlmKCBhcnJbIGkgXSAgPT09IGl0ZW0gfHwgY29tcGFyZV9mdW5jICYmIGNvbXBhcmVfZnVuYyggYXJyWyBpIF0sIGl0ZW0gKSl7XG4gICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHBsdXJhbGl6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsdXJhbCBPdmVycmlkZXMgbm9ybWFsIG91dHB1dCB3aXRoIHNhaWQgU3RyaW5nLihvcHRpb25hbClcbiAgICogQHJldHVybnMge1N0cmluZ30gU2luZ3VsYXIgRW5nbGlzaCBsYW5ndWFnZSBub3VucyBhcmUgcmV0dXJuZWQgaW4gcGx1cmFsIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdwZXJzb24nICk7IC8vID09PSAncGVvcGxlJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdvY3RvcHVzJyApOyAvLyA9PT0gJ29jdG9waSdcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAnSGF0JyApOyAvLyA9PT0gJ0hhdHMnXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ3BlcnNvbicsICdndXlzJyApOyAvLyA9PT0gJ2d1eXMnXG4gICAqL1xuICAgIHBsdXJhbGl6ZSA6IGZ1bmN0aW9uICggc3RyLCBwbHVyYWwgKXtcbiAgICAgIHJldHVybiBpbmZsZWN0b3IuX2FwcGx5X3J1bGVzKCBzdHIsIHBsdXJhbF9ydWxlcywgdW5jb3VudGFibGVfd29yZHMsIHBsdXJhbCApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgc2luZ3VsYXJpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaW5ndWxhciBPdmVycmlkZXMgbm9ybWFsIG91dHB1dCB3aXRoIHNhaWQgU3RyaW5nLihvcHRpb25hbClcbiAgICogQHJldHVybnMge1N0cmluZ30gUGx1cmFsIEVuZ2xpc2ggbGFuZ3VhZ2Ugbm91bnMgYXJlIHJldHVybmVkIGluIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSggJ3Blb3BsZScgKTsgLy8gPT09ICdwZXJzb24nXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAnb2N0b3BpJyApOyAvLyA9PT0gJ29jdG9wdXMnXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAnSGF0cycgKTsgLy8gPT09ICdIYXQnXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAnZ3V5cycsICdwZXJzb24nICk7IC8vID09PSAncGVyc29uJ1xuICAgKi9cbiAgICBzaW5ndWxhcml6ZSA6IGZ1bmN0aW9uICggc3RyLCBzaW5ndWxhciApe1xuICAgICAgcmV0dXJuIGluZmxlY3Rvci5fYXBwbHlfcnVsZXMoIHN0ciwgc2luZ3VsYXJfcnVsZXMsIHVuY291bnRhYmxlX3dvcmRzLCBzaW5ndWxhciApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgY2FtZWxpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG93X2ZpcnN0X2xldHRlciBEZWZhdWx0IGlzIHRvIGNhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcmVzdWx0cy4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgbG93ZXJjYXNlIGl0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBMb3dlciBjYXNlIHVuZGVyc2NvcmVkIHdvcmRzIHdpbGwgYmUgcmV0dXJuZWQgaW4gY2FtZWwgY2FzZS5cbiAgICogICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsbHkgJy8nIGlzIHRyYW5zbGF0ZWQgdG8gJzo6J1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uY2FtZWxpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZVByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmNhbWVsaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2VQcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBjYW1lbGl6ZSA6IGZ1bmN0aW9uICggc3RyLCBsb3dfZmlyc3RfbGV0dGVyICl7XG4gICAgICB2YXIgc3RyX3BhdGggPSBzdHIuc3BsaXQoICcvJyApO1xuICAgICAgdmFyIGkgICAgICAgID0gMDtcbiAgICAgIHZhciBqICAgICAgICA9IHN0cl9wYXRoLmxlbmd0aDtcbiAgICAgIHZhciBzdHJfYXJyLCBpbml0X3gsIGssIGwsIGZpcnN0O1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBzdHJfYXJyID0gc3RyX3BhdGhbIGkgXS5zcGxpdCggJ18nICk7XG4gICAgICAgIGsgICAgICAgPSAwO1xuICAgICAgICBsICAgICAgID0gc3RyX2Fyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yKCA7IGsgPCBsOyBrKysgKXtcbiAgICAgICAgICBpZiggayAhPT0gMCApe1xuICAgICAgICAgICAgc3RyX2FyclsgayBdID0gc3RyX2FyclsgayBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlyc3QgPSBzdHJfYXJyWyBrIF0uY2hhckF0KCAwICk7XG4gICAgICAgICAgZmlyc3QgPSBsb3dfZmlyc3RfbGV0dGVyICYmIGkgPT09IDAgJiYgayA9PT0gMFxuICAgICAgICAgICAgPyBmaXJzdC50b0xvd2VyQ2FzZSgpIDogZmlyc3QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBzdHJfYXJyWyBrIF0gPSBmaXJzdCArIHN0cl9hcnJbIGsgXS5zdWJzdHJpbmcoIDEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cl9wYXRoWyBpIF0gPSBzdHJfYXJyLmpvaW4oICcnICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJfcGF0aC5qb2luKCAnOjonICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyB1bmRlcnNjb3JlIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsX3VwcGVyX2Nhc2UgRGVmYXVsdCBpcyB0byBsb3dlcmNhc2UgYW5kIGFkZCB1bmRlcnNjb3JlIHByZWZpeC4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgcmV0dXJuIGFzIGVudGVyZWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENhbWVsIGNhc2VkIHdvcmRzIGFyZSByZXR1cm5lZCBhcyBsb3dlciBjYXNlZCBhbmQgdW5kZXJzY29yZWQuXG4gICAqICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbGx5ICc6OicgaXMgdHJhbnNsYXRlZCB0byAnLycuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnTWVzc2FnZVByb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZV9wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnbWVzc2FnZVByb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZV9wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnTVAnLCB0cnVlICk7IC8vID09PSAnTVAnXG4gICAqL1xuICAgIHVuZGVyc2NvcmUgOiBmdW5jdGlvbiAoIHN0ciwgYWxsX3VwcGVyX2Nhc2UgKXtcbiAgICAgIGlmKCBhbGxfdXBwZXJfY2FzZSAmJiBzdHIgPT09IHN0ci50b1VwcGVyQ2FzZSgpKSByZXR1cm4gc3RyO1xuXG4gICAgICB2YXIgc3RyX3BhdGggPSBzdHIuc3BsaXQoICc6OicgKTtcbiAgICAgIHZhciBpICAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICAgPSBzdHJfcGF0aC5sZW5ndGg7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIHN0cl9wYXRoWyBpIF0gPSBzdHJfcGF0aFsgaSBdLnJlcGxhY2UoIHVwcGVyY2FzZSwgJ18kMScgKTtcbiAgICAgICAgc3RyX3BhdGhbIGkgXSA9IHN0cl9wYXRoWyBpIF0ucmVwbGFjZSggdW5kZXJiYXJfcHJlZml4LCAnJyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyX3BhdGguam9pbiggJy8nICkudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGh1bWFuaXplIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG93X2ZpcnN0X2xldHRlciBEZWZhdWx0IGlzIHRvIGNhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcmVzdWx0cy4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgbG93ZXJjYXNlIGl0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBMb3dlciBjYXNlIHVuZGVyc2NvcmVkIHdvcmRzIHdpbGwgYmUgcmV0dXJuZWQgaW4gaHVtYW5pemVkIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5odW1hbml6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlIHByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmh1bWFuaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2UgcHJvcGVydGllcydcbiAgICovXG4gICAgaHVtYW5pemUgOiBmdW5jdGlvbiAoIHN0ciwgbG93X2ZpcnN0X2xldHRlciApe1xuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSggaWRfc3VmZml4LCAnJyApO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoIHVuZGVyYmFyLCAnICcgKTtcblxuICAgICAgaWYoICFsb3dfZmlyc3RfbGV0dGVyICl7XG4gICAgICAgIHN0ciA9IGluZmxlY3Rvci5jYXBpdGFsaXplKCBzdHIgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNhcGl0YWxpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEFsbCBjaGFyYWN0ZXJzIHdpbGwgYmUgbG93ZXIgY2FzZSBhbmQgdGhlIGZpcnN0IHdpbGwgYmUgdXBwZXIuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5jYXBpdGFsaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2VfcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24uY2FwaXRhbGl6ZSggJ21lc3NhZ2UgcHJvcGVydGllcycsIHRydWUgKTsgLy8gPT09ICdNZXNzYWdlIHByb3BlcnRpZXMnXG4gICAqL1xuICAgIGNhcGl0YWxpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKCAwLCAxICkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoIDEgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGRhc2hlcml6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmVwbGFjZXMgYWxsIHNwYWNlcyBvciB1bmRlcmJhcnMgd2l0aCBkYXNoZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5kYXNoZXJpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZS1wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5kYXNoZXJpemUoICdNZXNzYWdlIFByb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZS1Qcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBkYXNoZXJpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKCBzcGFjZV9vcl91bmRlcmJhciwgJy0nICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyB0aXRsZWl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDYXBpdGFsaXplcyB3b3JkcyBhcyB5b3Ugd291bGQgZm9yIGEgYm9vayB0aXRsZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnRpdGxlaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2UgUHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24udGl0bGVpemUoICdtZXNzYWdlIHByb3BlcnRpZXMgdG8ga2VlcCcgKTsgLy8gPT09ICdNZXNzYWdlIFByb3BlcnRpZXMgdG8gS2VlcCdcbiAgICovXG4gICAgdGl0bGVpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgc3RyICAgICAgICAgPSBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCB1bmRlcmJhciwgJyAnICk7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCggJyAnICk7XG4gICAgICB2YXIgaSAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICA9IHN0cl9hcnIubGVuZ3RoO1xuICAgICAgdmFyIGQsIGssIGw7XG5cbiAgICAgIGZvciggOyBpIDwgajsgaSsrICl7XG4gICAgICAgIGQgPSBzdHJfYXJyWyBpIF0uc3BsaXQoICctJyApO1xuICAgICAgICBrID0gMDtcbiAgICAgICAgbCA9IGQubGVuZ3RoO1xuXG4gICAgICAgIGZvciggOyBrIDwgbDsgaysrKXtcbiAgICAgICAgICBpZiggaW5mbGVjdG9yLmluZGV4T2YoIG5vbl90aXRsZWNhc2VkX3dvcmRzLCBkWyBrIF0udG9Mb3dlckNhc2UoKSkgPCAwICl7XG4gICAgICAgICAgICBkWyBrIF0gPSBpbmZsZWN0b3IuY2FwaXRhbGl6ZSggZFsgayBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJfYXJyWyBpIF0gPSBkLmpvaW4oICctJyApO1xuICAgICAgfVxuXG4gICAgICBzdHIgPSBzdHJfYXJyLmpvaW4oICcgJyApO1xuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZyggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKCAxICk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBkZW1vZHVsaXplIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJlbW92ZXMgbW9kdWxlIG5hbWVzIGxlYXZpbmcgb25seSBjbGFzcyBuYW1lcy4oUnVieSBzdHlsZSlcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmRlbW9kdWxpemUoICdNZXNzYWdlOjpCdXM6OlByb3BlcnRpZXMnICk7IC8vID09PSAnUHJvcGVydGllcydcbiAgICovXG4gICAgZGVtb2R1bGl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCggJzo6JyApO1xuXG4gICAgICByZXR1cm4gc3RyX2Fyclsgc3RyX2Fyci5sZW5ndGggLSAxIF07XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyB0YWJsZWl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm4gY2FtZWwgY2FzZWQgd29yZHMgaW50byB0aGVpciB1bmRlcnNjb3JlZCBwbHVyYWwgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnRhYmxlaXplKCAnTWVzc2FnZUJ1c1Byb3BlcnR5JyApOyAvLyA9PT0gJ21lc3NhZ2VfYnVzX3Byb3BlcnRpZXMnXG4gICAqL1xuICAgIHRhYmxlaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci51bmRlcnNjb3JlKCBzdHIgKTtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci5wbHVyYWxpemUoIHN0ciApO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgY2xhc3NpZmljYXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gVW5kZXJzY29yZWQgcGx1cmFsIG5vdW5zIGJlY29tZSB0aGUgY2FtZWwgY2FzZWQgc2luZ3VsYXIgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmNsYXNzaWZ5KCAnbWVzc2FnZV9idXNfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlQnVzUHJvcGVydHknXG4gICAqL1xuICAgIGNsYXNzaWZ5IDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci5jYW1lbGl6ZSggc3RyICk7XG4gICAgICBzdHIgPSBpbmZsZWN0b3Iuc2luZ3VsYXJpemUoIHN0ciApO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZm9yZWlnbiBrZXkgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBkcm9wX2lkX3ViYXIgRGVmYXVsdCBpcyB0byBzZXBlcmF0ZSBpZCB3aXRoIGFuIHVuZGVyYmFyIGF0IHRoZSBlbmQgb2YgdGhlIGNsYXNzIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5b3UgY2FuIHBhc3MgdHJ1ZSB0byBza2lwIGl0LihvcHRpb25hbClcbiAgICogQHJldHVybnMge1N0cmluZ30gVW5kZXJzY29yZWQgcGx1cmFsIG5vdW5zIGJlY29tZSB0aGUgY2FtZWwgY2FzZWQgc2luZ3VsYXIgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLmZvcmVpZ25fa2V5KCAnTWVzc2FnZUJ1c1Byb3BlcnR5JyApOyAvLyA9PT0gJ21lc3NhZ2VfYnVzX3Byb3BlcnR5X2lkJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5mb3JlaWduX2tleSggJ01lc3NhZ2VCdXNQcm9wZXJ0eScsIHRydWUgKTsgLy8gPT09ICdtZXNzYWdlX2J1c19wcm9wZXJ0eWlkJ1xuICAgKi9cbiAgICBmb3JlaWduX2tleSA6IGZ1bmN0aW9uICggc3RyLCBkcm9wX2lkX3ViYXIgKXtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci5kZW1vZHVsaXplKCBzdHIgKTtcbiAgICAgIHN0ciA9IGluZmxlY3Rvci51bmRlcnNjb3JlKCBzdHIgKSArICgoIGRyb3BfaWRfdWJhciApID8gKCAnJyApIDogKCAnXycgKSkgKyAnaWQnO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgb3JkaW5hbGl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm4gYWxsIGZvdW5kIG51bWJlcnMgdGhlaXIgc2VxdWVuY2UgbGlrZSAnMjJuZCcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5vcmRpbmFsaXplKCAndGhlIDEgcGl0Y2gnICk7IC8vID09PSAndGhlIDFzdCBwaXRjaCdcbiAgICovXG4gICAgb3JkaW5hbGl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCggJyAnICk7XG4gICAgICB2YXIgaSAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICA9IHN0cl9hcnIubGVuZ3RoO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICB2YXIgayA9IHBhcnNlSW50KCBzdHJfYXJyWyBpIF0sIDEwICk7XG5cbiAgICAgICAgaWYoICFpc05hTiggayApKXtcbiAgICAgICAgICB2YXIgbHRkID0gc3RyX2FyclsgaSBdLnN1YnN0cmluZyggc3RyX2FyclsgaSBdLmxlbmd0aCAtIDIgKTtcbiAgICAgICAgICB2YXIgbGQgID0gc3RyX2FyclsgaSBdLnN1YnN0cmluZyggc3RyX2FyclsgaSBdLmxlbmd0aCAtIDEgKTtcbiAgICAgICAgICB2YXIgc3VmID0gJ3RoJztcblxuICAgICAgICAgIGlmKCBsdGQgIT0gJzExJyAmJiBsdGQgIT0gJzEyJyAmJiBsdGQgIT0gJzEzJyApe1xuICAgICAgICAgICAgaWYoIGxkID09PSAnMScgKXtcbiAgICAgICAgICAgICAgc3VmID0gJ3N0JztcbiAgICAgICAgICAgIH1lbHNlIGlmKCBsZCA9PT0gJzInICl7XG4gICAgICAgICAgICAgIHN1ZiA9ICduZCc7XG4gICAgICAgICAgICB9ZWxzZSBpZiggbGQgPT09ICczJyApe1xuICAgICAgICAgICAgICBzdWYgPSAncmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0cl9hcnJbIGkgXSArPSBzdWY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cl9hcnIuam9pbiggJyAnICk7XG4gICAgfSxcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBtdWx0aXBsZSBpbmZsZWN0aW9uIG1ldGhvZHMgb24gYSBzdHJpbmdcbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBbiBhcnJheSBvZiBpbmZsZWN0aW9uIG1ldGhvZHMuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50cmFuc2Zvcm0oICdhbGwgam9iJywgWyAncGx1cmFsaXplJywgJ2NhcGl0YWxpemUnLCAnZGFzaGVyaXplJyBdKTsgLy8gPT09ICdBbGwtam9icydcbiAgICovXG4gICAgdHJhbnNmb3JtIDogZnVuY3Rpb24gKCBzdHIsIGFyciApe1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSBhcnIubGVuZ3RoO1xuXG4gICAgICBmb3IoIDtpIDwgajsgaSsrICl7XG4gICAgICAgIHZhciBtZXRob2QgPSBhcnJbIGkgXTtcblxuICAgICAgICBpZiggdGhpcy5oYXNPd25Qcm9wZXJ0eSggbWV0aG9kICkpe1xuICAgICAgICAgIHN0ciA9IHRoaXNbIG1ldGhvZCBdKCBzdHIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbiAgaW5mbGVjdG9yLnZlcnNpb24gPSAnMS4zLjgnO1xuXG4gIHJldHVybiBpbmZsZWN0b3I7XG59KSk7XG4iLCIoZnVuY3Rpb24oIGdsb2IsIHVuZGVmaW5lZCApIHtcblxudmFyIHJudW1iZXIgPSAvWzAtOV0vLFxuXHRybmV3bGluZSA9IC8oXFxyXFxufFxccnxcXG4pLyxcblx0cmV2aWRlbmNlID0gL1xcclxcbnxcXHJ8XFxuLyxcblx0cndoaXRlc3BhY2UgPSAvKFxcc3xcXHQpLyxcblx0cnZhbGlkc29saWR1cyA9IC9cXFxcKFwifFxcXFx8XFwvfGJ8ZnxufHJ8dHx1WzAtOV17NH0pLyxcblx0ckUgPSAvXihcXC18XFwrKT9bMC05XS87XG5cblxuLy8gTGVlZWVlZWVycnJycm9vb3l5IEplbm5ra2tpaWlubm5zc1xuZnVuY3Rpb24gSlNPTkxpbnQoIGpzb24sIG9wdGlvbnMgKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblxuXHRpZiAoICEgKCBzZWxmIGluc3RhbmNlb2YgSlNPTkxpbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IEpTT05MaW50KCBqc29uLCBvcHRpb25zICk7XG5cdH1cblxuXHQvLyBBcmd1bWVudCBoYW5kbGluZ1xuXHRzZWxmLmpzb24gPSBqc29uIHx8ICcnO1xuXHRzZWxmLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRzZWxmLmxvd2VyID0gc2VsZi5qc29uLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gQWxsb3cgY29tbWVudHMgYnkgZGVmYXVsdFxuXHRpZiAoICEgc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KCAnY29tbWVudHMnICkgKSB7XG5cdFx0c2VsZi5vcHRpb25zLmNvbW1lbnRzID0gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmFsc1xuXHRzZWxmLmMgPSAnJztcblx0c2VsZi5pID0gLTE7XG5cdHNlbGYubGVuZ3RoID0gc2VsZi5qc29uLmxlbmd0aDtcblx0c2VsZi5saW5lID0gMTtcblx0c2VsZi5jaGFyYWN0ZXIgPSAwO1xuXHRzZWxmLl9ldmlkZW5jZSA9IHNlbGYuanNvbi5zcGxpdCggcmV2aWRlbmNlICk7XG5cdHNlbGYuZW5kYmxvY2sgPSAnJztcblx0c2VsZi5jb21tYWJyZWFrID0gZmFsc2U7XG5cblx0dHJ5IHtcblx0XHRzZWxmLnJlbmRlcigpO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRpZiAoIHR5cGVvZiBlICE9ICdzdHJpbmcnICkge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0c2VsZi5lcnJvciA9IGU7XG5cdFx0c2VsZi5zZXRFdmlkZW5jZSgpO1xuXHR9XG59XG5cblxuLy8gTWV0YSAoUGxlYXNlIGNoYW5nZSBjb250YWN0IGluZm8gZm9yIHJlcHVibGlzaGluZyB3aXRoIGNoYW5nZXMpXG5KU09OTGludC5jb250YWN0ID0gXCJDb3JleSBIYXJ0IChjb3JleUBjb2Rlbm90aGluZy5jb20pXCI7XG5KU09OTGludC52ZXJzaW9uID0gJ1tWRVJTSU9OXSc7XG5KU09OTGludC5kYXRlID0gJ1tEQVRFXSc7XG5cblxuLy8gTWV0aG9kc1xuSlNPTkxpbnQucHJvdG90eXBlID0ge1xuXG5cdC8vIFJlbmRlcmluZyBTdGFydFxuXHRyZW5kZXI6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwZWVrID0gJycsIGNvbnRlbnQgPSBmYWxzZTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY29udGVudCApIHtcblx0XHRcdFx0dGhyb3cgXCJVbmtub3duIGNoYXJhY3RlciAnXCIgKyBzZWxmLmMgKyBcIicsIGV4cGVjdGluZyBlbmQgb2YgZmlsZS5cIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxmLmMgPT0gJ1snICkge1xuXHRcdFx0XHRjb250ZW50ID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5hcnJheSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAneycgKSB7XG5cdFx0XHRcdGNvbnRlbnQgPSB0cnVlO1xuXHRcdFx0XHRzZWxmLm9iamVjdCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3Rpbmcgb3BlbmluZyBibG9jayAneycgb3IgJ1snLCBvciBtYXliZSBhIGNvbW1lbnRcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgcHVyZSB3aGl0ZXNwYWNlXG5cdFx0aWYgKCAhIGNvbnRlbnQgKSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgSlNPTiwgbm8gY29udGVudC5cIjtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTXVsdGkgbGluZSBjb21tZW50XG5cdG11bHRpY29tbWVudDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggc2VsZi5jID09IFwiKlwiICYmIHNlbGYuanNvblsgc2VsZi5pICsgMSBdID09IFwiL1wiICkge1xuXHRcdFx0XHRzZWxmLmkrKztcblx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNpbmdsZSBsaW5lIGNvbW1lbnRcblx0Y29tbWVudDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBBcnJheSBCbG9ja1xuXHRhcnJheTogZnVuY3Rpb24oKXtcblx0XHQvLyBLZWVwIHJlZmVyZW5jZSBvZiBjdXJyZW50IGVuZGJsb2NrXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0X2VuZGJsb2NrID0gc2VsZi5lbmRibG9jayxcblx0XHRcdF9jb21tYWJyZWFrID0gc2VsZi5jb21tYWJyZWFrLFxuXHRcdFx0ZW5kZWQgPSBmYWxzZTtcblxuXHRcdHNlbGYuZW5kYmxvY2sgPSAnXSc7XG5cdFx0c2VsZi5jb21tYWJyZWFrID0gZmFsc2U7XG5cdFx0d2hpbGUgKCAoIGVuZGVkID0gc2VsZi52YWx1ZSgpICkgIT09IHRydWUgJiYgc2VsZi5pIDwgc2VsZi5sZW5ndGggKSB7XG5cdFx0XHQvLyBEbyBub3RoaW5nLCBqdXN0IHdhaXQgZm9yIGFycmF5IHZhbHVlcyB0byBmaW5pc2hcblx0XHR9XG5cblx0XHRpZiAoICEgZW5kZWQgKSB7XG5cdFx0XHR0aHJvdyBcIkVPRiBFcnJvci4gRXhwZWN0aW5nIGNsb3NpbmcgJ10nXCI7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcHJldmlvdXMgZW5kYmxvY2tcblx0XHRzZWxmLmVuZGJsb2NrID0gX2VuZGJsb2NrO1xuXHRcdHNlbGYuY29tbWFicmVhayA9IF9jb21tYWJyZWFrO1xuXHR9LFxuXG5cdC8vIE9iamVjdCBCbG9ja1xuXHRvYmplY3Q6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gS2VlcCByZWZlcmVuY2Ugb2YgY3VycmVudCBlbmRibG9ja1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdF9lbmRibG9jayA9IHNlbGYuZW5kYmxvY2ssXG5cdFx0XHRfY29tbWFicmVhayA9IHNlbGYuY29tbWFicmVhayxcblx0XHRcdGZvdW5kID0gZmFsc2UsIHBlZWsgPSAnJywgZW1wdHkgPSB0cnVlO1xuXG5cdFx0c2VsZi5lbmRibG9jayA9ICd9Jztcblx0XHRzZWxmLmNvbW1hYnJlYWsgPSBmYWxzZTtcblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggc2VsZi5vcHRpb25zLmNvbW1lbnRzICYmIHNlbGYuYyA9PSAnLycgKSB7XG5cdFx0XHRcdHBlZWsgPSBzZWxmLmpzb25bIHNlbGYuaSArIDEgXTtcblx0XHRcdFx0aWYgKCBwZWVrID09ICcqJyApIHtcblx0XHRcdFx0XHRzZWxmLm11bHRpY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBwZWVrID09ICcvJyApIHtcblx0XHRcdFx0XHRzZWxmLmNvbW1lbnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gY2hhcmFjdGVyICcvJywgbWF5YmUgYSBjb21tZW50P1wiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcndoaXRlc3BhY2UuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnXCInICkge1xuXHRcdFx0XHRlbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHNlbGYua2V5KCkgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0Ly8gUmVzZXQgb2xkIGVuZGJsb2NrXG5cdFx0XHRcdFx0c2VsZi5lbmRibG9jayA9IF9lbmRibG9jaztcblx0XHRcdFx0XHRzZWxmLmNvbW1hYnJlYWsgPSBfY29tbWFicmVhaztcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBlbXB0eSAmJiBzZWxmLmMgPT0gJ30nICkge1xuXHRcdFx0XHRzZWxmLmVuZGJsb2NrID0gX2VuZGJsb2NrO1xuXHRcdFx0XHRzZWxmLmNvbW1hYnJlYWsgPSBfY29tbWFicmVhaztcblx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJywgZXhwZWN0aW5nIGEgc3RyaW5nIGZvciBrZXkgc3RhdGVtZW50LlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggISBmb3VuZCApIHtcblx0XHRcdHRocm93IFwiRU9GIEVycm9yLCBleHBlY3RpbmcgY2xvc2luZyAnfScuXCI7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEtleSBTdGF0ZW1lbnRcblx0a2V5OiBmdW5jdGlvbigpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLnN0cmluZygpO1xuXG5cdFx0Zm9yICggdmFyIHBlZWsgPSAnJzsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09IFwiOlwiICkge1xuXHRcdFx0XHRyZXR1cm4gc2VsZi52YWx1ZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3RpbmcgYSBzZW1pY29sb24uXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFZhbHVlIHN0YXRlbWVudFxuXHR2YWx1ZTogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBlZWsgPSAnJztcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICd7JyApIHtcblx0XHRcdFx0c2VsZi5vYmplY3QoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICdbJyApIHtcblx0XHRcdFx0c2VsZi5hcnJheSgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5lbmR2YWwoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxmLmMgPT0gJ1wiJyApIHtcblx0XHRcdFx0c2VsZi5zdHJpbmcoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5qc29uLmluZGV4T2YoICd0cnVlJywgc2VsZi5pICkgPT09IHNlbGYuaSApIHtcblx0XHRcdFx0c2VsZi5pICs9IDM7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyICs9IDM7XG5cdFx0XHRcdHJldHVybiBzZWxmLmVuZHZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuanNvbi5pbmRleE9mKCAnZmFsc2UnLCBzZWxmLmkgKSA9PT0gc2VsZi5pICkge1xuXHRcdFx0XHRzZWxmLmkgKz0gNDtcblx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5qc29uLmluZGV4T2YoICdudWxsJywgc2VsZi5pICkgPT09IHNlbGYuaSApIHtcblx0XHRcdFx0c2VsZi5pICs9IDM7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyICs9IDM7XG5cdFx0XHRcdHJldHVybiBzZWxmLmVuZHZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnLScgfHwgcm51bWJlci5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYubnVtZXJpYygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnXScgJiYgc2VsZi5lbmRibG9jayA9PSAnXScgKSB7XG5cdFx0XHRcdGlmICggc2VsZi5jb21tYWJyZWFrICkge1xuXHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBFbmQgT2YgQXJyYXkgRXJyb3IuIEV4cGVjdGluZyBhIHZhbHVlIHN0YXRlbWVudC5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJywgZXhwZWN0aW5nIGEgdmFsdWUuXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFN0cmluZyBzdGF0ZW1lbnRcblx0c3RyaW5nOiBmdW5jdGlvbigpe1xuXHRcdHZhciBzZWxmID0gdGhpcywgZm91bmQgPSBmYWxzZSwgbTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLmMgPT0gXCJcXFxcXCIgKSB7XG5cdFx0XHRcdGlmICggKCBtID0gcnZhbGlkc29saWR1cy5leGVjKCBzZWxmLmpzb24uc3Vic3RyKCBzZWxmLmkgKSApICkgJiYgbS5pbmRleCA9PT0gMCApIHtcblx0XHRcdFx0XHRzZWxmLmkgKz0gbVsgMSBdLmxlbmd0aDtcblx0XHRcdFx0XHRzZWxmLmNoYXJhY3RlciArPSBtWyAxIF0ubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiSW52YWxpZCBSZXZlcnNlIFNvbGlkdXMgJ1xcXFwnIGRlY2xhcmF0aW9uLlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICdcIicgKSB7XG5cdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIGNsb3NlIHN0cmluZyBpcyBmb3VuZFxuXHRcdGlmICggISBmb3VuZCApIHtcblx0XHRcdHRocm93IFwiRU9GOiBObyBjbG9zZSBzdHJpbmcgJ1xcXCInIGZvdW5kLlwiO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOdW1lcmljIFZhbHVlXG5cdG51bWVyaWM6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0bmVnYXRpdmUgPSB0cnVlLFxuXHRcdFx0ZGVjaW1hbCA9IG51bGwsXG5cdFx0XHRlID0gbnVsbCxcblx0XHRcdHBlZWsgPSAnJztcblxuXHRcdC8vIFdlIG5lZWQgdG8ganVtcCBiYWNrIGEgY2hhcmFjdGVyIHRvIGNhdGNoIHRoZSB3aG9sZSBudW1iZXJcblx0XHRzZWxmLmktLTtcblx0XHRzZWxmLmNoYXJhY3Rlci0tO1xuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0Ly8gSGFuZGxlIGluaXRpYWwgbmVnYXRpdmUgc2lnblxuXHRcdFx0aWYgKCBuZWdhdGl2ZSApIHtcblx0XHRcdFx0bmVnYXRpdmUgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCBzZWxmLmMgPT0gJy0nICkge1xuXHRcdFx0XHRcdGlmICggISBybnVtYmVyLmV4ZWMoIHNlbGYuanNvblsgc2VsZi5pICsgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJyBmb2xsb3dpbmcgYSBuZWdhdGl2ZSwgZXhwZWN0aW5nIGEgbnVtZXJpYyB2YWx1ZS5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhIHNpbmdsZSBkZWNpbWFsIGlzIGFsbG93ZWQgaW4gYSBudW1lcmljIHZhbHVlXG5cdFx0XHRpZiAoIGRlY2ltYWwgJiYgc2VsZi5jID09ICcuJyApIHtcblx0XHRcdFx0ZGVjaW1hbCA9IGZhbHNlO1xuXHRcdFx0XHRlID0gdHJ1ZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBPbmx5IGEgc2luZ2xlIGUgbm90YXRpb24gaXMgYWxsb3dlZCBpbiBhIG51bWVyaWMgdmFsdWVcblx0XHRcdGVsc2UgaWYgKCBlICYmIHNlbGYuYy50b0xvd2VyQ2FzZSgpID09ICdlJyApIHtcblx0XHRcdFx0ZSA9IGZhbHNlO1xuXHRcdFx0XHRuZWdhdGl2ZSA9IHRydWU7XG5cdFx0XHRcdGlmICggckUuZXhlYyggc2VsZi5qc29uLnN1YnN0ciggc2VsZi5pICsgMSwgMiApICkgKSB7XG5cdFx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblx0XHRcdFx0XHRzZWxmLmkrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmNoYXJhY3RlcisrO1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5qc29uWyBzZWxmLmkgKyAxIF0gKyBcIicgZm9sbG93aW5nIGUgbm90YXRpb24sIGV4cGVjdGluZyBhIG51bWVyaWMgdmFsdWUuXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE5vcm1hbCBEaWdpdFxuXHRcdFx0ZWxzZSBpZiAoIHJudW1iZXIuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdGlmICggZGVjaW1hbCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRkZWNpbWFsID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQXNzdW1lIGVuZCBvZiBudW1iZXIsIGFuZCBhbGxvdyBlbmR2YWwgdG8gaGFuZGxlIGl0XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gSnVtcCBiYWNrIGEgY2hhcmFjdGVyIHRvIGluY2x1ZGUgdGhlIGN1cnJlbnQgb25lXG5cdFx0XHRcdHNlbGYuaS0tO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3Rlci0tO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5lbmR2YWwoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRW5kaW5nIGEgdmFsdWUgc3RhdGVtZW50XG5cdGVuZHZhbDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBlZWsgPSAnJztcblx0XHRzZWxmLmNvbW1hYnJlYWsgPSBmYWxzZTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICcsJyApIHtcblx0XHRcdFx0c2VsZi5jb21tYWJyZWFrID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09IHNlbGYuZW5kYmxvY2sgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3RpbmcgYSBjb21tYSBvciBhIGNsb3NpbmcgJ1wiICsgc2VsZi5lbmRibG9jayArIFwiJ1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBFeHBvc2UgbGluZSBvZiB0aGUgZXJyb3Jcblx0c2V0RXZpZGVuY2U6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBzdGFydCA9IHNlbGYubGluZSAtIDUsIGVuZCA9IHN0YXJ0ICsgOCwgZXZpZGVuY2UgPSAnJztcblxuXHRcdC8vIE1pbiBzdGFydFxuXHRcdGlmICggc3RhcnQgPCAwICkge1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0ZW5kID0gODtcblx0XHR9XG5cblx0XHQvLyBNYXggZW5kXG5cdFx0aWYgKCBlbmQgPj0gc2VsZi5fZXZpZGVuY2UubGVuZ3RoICkge1xuXHRcdFx0ZW5kID0gc2VsZi5fZXZpZGVuY2UubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIEV2aWRlbmNlIGRpc3BsYXlcblx0XHRmb3IgKCA7IHN0YXJ0IDwgZW5kOyBzdGFydCsrICkge1xuXHRcdFx0ZXZpZGVuY2UgKz0gKCBzdGFydCA9PT0gKCBzZWxmLmxpbmUgLSAxICkgPyBcIi0+IFwiIDogXCIgICBcIiApICtcblx0XHRcdFx0KCBzdGFydCArIDEgKSArICd8ICcgK1xuXHRcdFx0XHRzZWxmLl9ldmlkZW5jZVsgc3RhcnQgXSArIFwiXFxuXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBldmlkZW5jZSBkaXNwbGF5XG5cdFx0c2VsZi5ldmlkZW5jZSA9IGV2aWRlbmNlO1xuXHR9XG59O1xuXG5cbi8vIENoZWNrIGZvciBub2RlanMgbW9kdWxlIHN5c3RlbVxuaWYgKCB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05MaW50O1xufVxuLy8gSW4gYSBicm93c2VyXG5lbHNlIHtcblx0Z2xvYi5KU09OTGludCA9IEpTT05MaW50O1xufVxuXG59KSggdGhpcyApO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIHZpbTp0cz00OnN0cz00OnN3PTQ6XG4vKiFcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEyIEtyaXMgS293YWwgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVRcbiAqIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvcmF3L21hc3Rlci9MSUNFTlNFXG4gKlxuICogV2l0aCBwYXJ0cyBieSBUeWxlciBDbG9zZVxuICogQ29weXJpZ2h0IDIwMDctMjAwOSBUeWxlciBDbG9zZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBYIGxpY2Vuc2UgZm91bmRcbiAqIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UuaHRtbFxuICogRm9ya2VkIGF0IHJlZl9zZW5kLmpzIHZlcnNpb246IDIwMDktMDUtMTFcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IE1hcmsgTWlsbGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgLy8gVHVybiBvZmYgc3RyaWN0IG1vZGUgZm9yIHRoaXMgZnVuY3Rpb24gc28gd2UgY2FuIGFzc2lnbiB0byBnbG9iYWwuUVxuICAgIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXG5cbiAgICAvLyBUaGlzIGZpbGUgd2lsbCBmdW5jdGlvbiBwcm9wZXJseSBhcyBhIDxzY3JpcHQ+IHRhZywgb3IgYSBtb2R1bGVcbiAgICAvLyB1c2luZyBDb21tb25KUyBhbmQgTm9kZUpTIG9yIFJlcXVpcmVKUyBtb2R1bGUgZm9ybWF0cy4gIEluXG4gICAgLy8gQ29tbW9uL05vZGUvUmVxdWlyZUpTLCB0aGUgbW9kdWxlIGV4cG9ydHMgdGhlIFEgQVBJIGFuZCB3aGVuXG4gICAgLy8gZXhlY3V0ZWQgYXMgYSBzaW1wbGUgPHNjcmlwdD4sIGl0IGNyZWF0ZXMgYSBRIGdsb2JhbCBpbnN0ZWFkLlxuXG4gICAgLy8gTW9udGFnZSBSZXF1aXJlXG4gICAgaWYgKHR5cGVvZiBib290c3RyYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBib290c3RyYXAoXCJwcm9taXNlXCIsIGRlZmluaXRpb24pO1xuXG4gICAgLy8gQ29tbW9uSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSB7XG4gICAgICAgIFEgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxuXG59KShmdW5jdGlvbiAoKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhhc1N0YWNrcyA9IGZhbHNlO1xudHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTdGFja3MgPSAhIWUuc3RhY2s7XG59XG5cbi8vIEFsbCBjb2RlIGFmdGVyIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcyByZXBvcnRlZFxuLy8gYnkgUS5cbnZhciBxU3RhcnRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcbnZhciBxRmlsZU5hbWU7XG5cbi8vIHNoaW1zXG5cbi8vIHVzZWQgZm9yIGZhbGxiYWNrIGluIFwiYWxsUmVzb2x2ZWRcIlxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IHBvc3NpYmxlIG1lYW5zIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm5cbi8vIG9mIHRoZSBldmVudCBsb29wLlxudmFyIG5leHRUaWNrID0oZnVuY3Rpb24gKCkge1xuICAgIC8vIGxpbmtlZCBsaXN0IG9mIHRhc2tzIChzaW5nbGUsIHdpdGggaGVhZCBub2RlKVxuICAgIHZhciBoZWFkID0ge3Rhc2s6IHZvaWQgMCwgbmV4dDogbnVsbH07XG4gICAgdmFyIHRhaWwgPSBoZWFkO1xuICAgIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICAgIHZhciByZXF1ZXN0VGljayA9IHZvaWQgMDtcbiAgICB2YXIgaXNOb2RlSlMgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cblxuICAgICAgICB3aGlsZSAoaGVhZC5uZXh0KSB7XG4gICAgICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgICAgICAgdmFyIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgICAgICBoZWFkLnRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXNrKCk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gbm9kZSwgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgY29uc2lkZXJlZCBmYXRhbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIFwidW5jYXVnaHRFeGNlcHRpb25cIiBldmVudHMgKGFzIGRvbWFpbnMgZG9lcykuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgc2xvdy1kb3ducy5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbmV4dFRpY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgIGRvbWFpbjogaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4sXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgICAvLyBOb2RlLmpzIGJlZm9yZSAwLjkuIE5vdGUgdGhhdCBzb21lIGZha2UtTm9kZSBlbnZpcm9ubWVudHMsIGxpa2UgdGhlXG4gICAgICAgIC8vIE1vY2hhIHRlc3QgcnVubmVyLCBpbnRyb2R1Y2UgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgLlxuICAgICAgICBpc05vZGVKUyA9IHRydWU7XG5cbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAvLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAvLyBBdCBsZWFzdCBTYWZhcmkgVmVyc2lvbiA2LjAuNSAoODUzNi4zMC4xKSBpbnRlcm1pdHRlbnRseSBjYW5ub3QgY3JlYXRlXG4gICAgICAgIC8vIHdvcmtpbmcgbWVzc2FnZSBwb3J0cyB0aGUgZmlyc3QgdGltZSBhIHBhZ2UgbG9hZHMuXG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSByZXF1ZXN0UG9ydFRpY2s7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3RQb3J0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIHJlcXVpcmVzIHVzIHRvIHByb3ZpZGUgYSBtZXNzYWdlIHBheWxvYWQsIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgd2UgdXNlIGl0LlxuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RQb3J0VGljaygpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRUaWNrO1xufSkoKTtcblxuLy8gQXR0ZW1wdCB0byBtYWtlIGdlbmVyaWNzIHNhZmUgaW4gdGhlIGZhY2Ugb2YgZG93bnN0cmVhbVxuLy8gbW9kaWZpY2F0aW9ucy5cbi8vIFRoZXJlIGlzIG5vIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIG5lY2Vzc2FyeS5cbi8vIElmIHlvdSBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLCB0aGVzZSBwcmltb3JkaWFscyBuZWVkIHRvIGJlXG4vLyBkZWVwbHkgZnJvemVuIGFueXdheSwgYW5kIGlmIHlvdSBkb27igJl0IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsXG4vLyB0aGlzIGlzIGp1c3QgcGxhaW4gcGFyYW5vaWQuXG4vLyBIb3dldmVyLCB0aGlzIGRvZXMgaGF2ZSB0aGUgbmljZSBzaWRlLWVmZmVjdCBvZiByZWR1Y2luZyB0aGUgc2l6ZVxuLy8gb2YgdGhlIGNvZGUgYnkgcmVkdWNpbmcgeC5jYWxsKCkgdG8gbWVyZWx5IHgoKSwgZWxpbWluYXRpbmcgbWFueVxuLy8gaGFyZC10by1taW5pZnkgY2hhcmFjdGVycy5cbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4vLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbi8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbi8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuLy8gdGhpcyBibG9jay5cbnZhciBoYXNFUzZHZW5lcmF0b3JzO1xudHJ5IHtcbiAgICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSwgbm9uZXc6IGZhbHNlICovXG4gICAgbmV3IEZ1bmN0aW9uKFwiKGZ1bmN0aW9uKiAoKXsgeWllbGQgMTsgfSlcIik7XG4gICAgaGFzRVM2R2VuZXJhdG9ycyA9IHRydWU7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzRVM2R2VuZXJhdG9ycyA9IGZhbHNlO1xufVxuXG4vLyBsb25nIHN0YWNrIHRyYWNlc1xuXG52YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCI7XG5cbmZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFFcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBwcm9taXNlYC4gU2VlICM1Ny5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIHByb21pc2Uuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrICYmXG4gICAgICAgIGVycm9yLnN0YWNrLmluZGV4T2YoU1RBQ0tfSlVNUF9TRVBBUkFUT1IpID09PSAtMVxuICAgICkge1xuICAgICAgICB2YXIgc3RhY2tzID0gW107XG4gICAgICAgIGZvciAodmFyIHAgPSBwcm9taXNlOyAhIXA7IHAgPSBwLnNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHAuc3RhY2spIHtcbiAgICAgICAgICAgICAgICBzdGFja3MudW5zaGlmdChwLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja3MudW5zaGlmdChlcnJvci5zdGFjayk7XG5cbiAgICAgICAgdmFyIGNvbmNhdGVkU3RhY2tzID0gc3RhY2tzLmpvaW4oXCJcXG5cIiArIFNUQUNLX0pVTVBfU0VQQVJBVE9SICsgXCJcXG5cIik7XG4gICAgICAgIGVycm9yLnN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3RhY2tTdHJpbmcoc3RhY2tTdHJpbmcpIHtcbiAgICB2YXIgbGluZXMgPSBzdGFja1N0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgZGVzaXJlZExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgIGlmICghaXNJbnRlcm5hbEZyYW1lKGxpbmUpICYmICFpc05vZGVGcmFtZShsaW5lKSAmJiBsaW5lKSB7XG4gICAgICAgICAgICBkZXNpcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzaXJlZExpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUZyYW1lKHN0YWNrTGluZSkge1xuICAgIHJldHVybiBzdGFja0xpbmUuaW5kZXhPZihcIihtb2R1bGUuanM6XCIpICE9PSAtMSB8fFxuICAgICAgICAgICBzdGFja0xpbmUuaW5kZXhPZihcIihub2RlLmpzOlwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpIHtcbiAgICAvLyBOYW1lZCBmdW5jdGlvbnM6IFwiYXQgZnVuY3Rpb25OYW1lIChmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlcilcIlxuICAgIC8vIEluIElFMTAgZnVuY3Rpb24gbmFtZSBjYW4gaGF2ZSBzcGFjZXMgKFwiQW5vbnltb3VzIGZ1bmN0aW9uXCIpIE9fb1xuICAgIHZhciBhdHRlbXB0MSA9IC9hdCAuKyBcXCgoLispOihcXGQrKTooPzpcXGQrKVxcKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDEpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MVsxXSwgTnVtYmVyKGF0dGVtcHQxWzJdKV07XG4gICAgfVxuXG4gICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uczogXCJhdCBmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQyID0gL2F0IChbXiBdKyk6KFxcZCspOig/OlxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mikge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQyWzFdLCBOdW1iZXIoYXR0ZW1wdDJbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBGaXJlZm94IHN0eWxlOiBcImZ1bmN0aW9uQGZpbGVuYW1lOmxpbmVOdW1iZXIgb3IgQGZpbGVuYW1lOmxpbmVOdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MyA9IC8uKkAoLispOihcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDMpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0M1sxXSwgTnVtYmVyKGF0dGVtcHQzWzJdKV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybmFsRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpO1xuXG4gICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICB2YXIgbGluZU51bWJlciA9IGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcblxuICAgIHJldHVybiBmaWxlTmFtZSA9PT0gcUZpbGVOYW1lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPj0gcVN0YXJ0aW5nTGluZSAmJlxuICAgICAgICBsaW5lTnVtYmVyIDw9IHFFbmRpbmdMaW5lO1xufVxuXG4vLyBkaXNjb3ZlciBvd24gZmlsZSBuYW1lIGFuZCBsaW5lIG51bWJlciByYW5nZSBmb3IgZmlsdGVyaW5nIHN0YWNrXG4vLyB0cmFjZXNcbmZ1bmN0aW9uIGNhcHR1cmVMaW5lKCkge1xuICAgIGlmICghaGFzU3RhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lc1swXS5pbmRleE9mKFwiQFwiKSA+IDAgPyBsaW5lc1sxXSA6IGxpbmVzWzJdO1xuICAgICAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKGZpcnN0TGluZSk7XG4gICAgICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBxRmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgICAgIHJldHVybiBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUoY2FsbGJhY2ssIG5hbWUsIGFsdGVybmF0aXZlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCwgdXNlIFwiICsgYWx0ZXJuYXRpdmUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluc3RlYWQuXCIsIG5ldyBFcnJvcihcIlwiKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIGVuZCBvZiBzaGltc1xuLy8gYmVnaW5uaW5nIG9mIHJlYWwgd29ya1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLCBwYXNzZXMgcHJvbWlzZXMgdGhyb3VnaCwgb3JcbiAqIGNvZXJjZXMgcHJvbWlzZXMgZnJvbSBkaWZmZXJlbnQgc3lzdGVtcy5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlIG9yIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gUSh2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBhIFByb21pc2UsIHJldHVybiBpdCBkaXJlY3RseS4gIFRoaXMgZW5hYmxlc1xuICAgIC8vIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHRvIGJvdGggYmUgdXNlZCB0byBjcmVhdGVkIHJlZmVyZW5jZXMgZnJvbSBvYmplY3RzLFxuICAgIC8vIGJ1dCB0byB0b2xlcmFibHkgY29lcmNlIG5vbi1wcm9taXNlcyB0byBwcm9taXNlcy5cbiAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gYXNzaW1pbGF0ZSB0aGVuYWJsZXNcbiAgICBpZiAoaXNQcm9taXNlQWxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsKHZhbHVlKTtcbiAgICB9XG59XG5RLnJlc29sdmUgPSBRO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdGFza1xuICovXG5RLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qKlxuICogQ29udHJvbHMgd2hldGhlciBvciBub3QgbG9uZyBzdGFjayB0cmFjZXMgd2lsbCBiZSBvblxuICovXG5RLmxvbmdTdGFja1N1cHBvcnQgPSBmYWxzZTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gb2JqZWN0LlxuICpcbiAqIGByZXNvbHZlYCBpcyBhIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGEgbW9yZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhlXG4gKiBwcm9taXNlLiBUbyBmdWxmaWxsIHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYW55IHZhbHVlIHRoYXQgaXNcbiAqIG5vdCBhIHRoZW5hYmxlLiBUbyByZWplY3QgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhIHJlamVjdGVkXG4gKiB0aGVuYWJsZSwgb3IgaW52b2tlIGByZWplY3RgIHdpdGggdGhlIHJlYXNvbiBkaXJlY3RseS4gVG8gcmVzb2x2ZSB0aGVcbiAqIHByb21pc2UgdG8gYW5vdGhlciB0aGVuYWJsZSwgdGh1cyBwdXR0aW5nIGl0IGluIHRoZSBzYW1lIHN0YXRlLCBpbnZva2VcbiAqIGByZXNvbHZlYCB3aXRoIHRoYXQgb3RoZXIgdGhlbmFibGUuXG4gKi9cblEuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIGRlZmVyKCkge1xuICAgIC8vIGlmIFwibWVzc2FnZXNcIiBpcyBhbiBcIkFycmF5XCIsIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHByb21pc2UgaGFzIG5vdCB5ZXRcbiAgICAvLyBiZWVuIHJlc29sdmVkLiAgSWYgaXQgaXMgXCJ1bmRlZmluZWRcIiwgaXQgaGFzIGJlZW4gcmVzb2x2ZWQuICBFYWNoXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgbWVzc2FnZXMgYXJyYXkgaXMgaXRzZWxmIGFuIGFycmF5IG9mIGNvbXBsZXRlIGFyZ3VtZW50cyB0b1xuICAgIC8vIGZvcndhcmQgdG8gdGhlIHJlc29sdmVkIHByb21pc2UuICBXZSBjb2VyY2UgdGhlIHJlc29sdXRpb24gdmFsdWUgdG8gYVxuICAgIC8vIHByb21pc2UgdXNpbmcgdGhlIGByZXNvbHZlYCBmdW5jdGlvbiBiZWNhdXNlIGl0IGhhbmRsZXMgYm90aCBmdWxseVxuICAgIC8vIG5vbi10aGVuYWJsZSB2YWx1ZXMgYW5kIG90aGVyIHRoZW5hYmxlcyBncmFjZWZ1bGx5LlxuICAgIHZhciBtZXNzYWdlcyA9IFtdLCBwcm9ncmVzc0xpc3RlbmVycyA9IFtdLCByZXNvbHZlZFByb21pc2U7XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBvYmplY3RfY3JlYXRlKGRlZmVyLnByb3RvdHlwZSk7XG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBvcGVyYW5kcykge1xuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChhcmdzKTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJ3aGVuXCIgJiYgb3BlcmFuZHNbMV0pIHsgLy8gcHJvZ3Jlc3Mgb3BlcmFuZFxuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXJzLnB1c2gob3BlcmFuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhcmVyVmFsdWUgPSBuZWFyZXIocmVzb2x2ZWRQcm9taXNlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShuZWFyZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5lYXJlclZhbHVlOyAvLyBzaG9ydGVuIGNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlclZhbHVlO1xuICAgIH0sIFwidmFsdWVPZlwiLCBcImluc3BlY3RcIik7XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJwZW5kaW5nXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlLmluc3BlY3QoKTtcbiAgICB9O1xuXG4gICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBkb24ndCB0cnkgdG8gdXNlIGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAgb3IgdHJhbnNmZXIgdGhlXG4gICAgICAgICAgICAvLyBhY2Nlc3NvciBhcm91bmQ7IHRoYXQgY2F1c2VzIG1lbW9yeSBsZWFrcyBhcyBwZXIgR0gtMTExLiBKdXN0XG4gICAgICAgICAgICAvLyByZWlmeSB0aGUgc3RhY2sgdHJhY2UgYXMgYSBzdHJpbmcgQVNBUC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lOyBpdCdzIGFsd2F5cyBqdXN0XG4gICAgICAgICAgICAvLyBcIltvYmplY3QgUHJvbWlzZV1cXG5cIiwgYXMgcGVyIHRoZSBgdG9TdHJpbmdgLlxuICAgICAgICAgICAgcHJvbWlzZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZihcIlxcblwiKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogd2UgZG8gdGhlIGNoZWNrcyBmb3IgYHJlc29sdmVkUHJvbWlzZWAgaW4gZWFjaCBtZXRob2QsIGluc3RlYWQgb2ZcbiAgICAvLyBjb25zb2xpZGF0aW5nIHRoZW0gaW50byBgYmVjb21lYCwgc2luY2Ugb3RoZXJ3aXNlIHdlJ2QgY3JlYXRlIG5ld1xuICAgIC8vIHByb21pc2VzIHdpdGggdGhlIGxpbmVzIGBiZWNvbWUod2hhdGV2ZXIodmFsdWUpKWAuIFNlZSBlLmcuIEdILTI1Mi5cblxuICAgIGZ1bmN0aW9uIGJlY29tZShuZXdQcm9taXNlKSB7XG4gICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5ld1Byb21pc2U7XG4gICAgICAgIHByb21pc2Uuc291cmNlID0gbmV3UHJvbWlzZTtcblxuICAgICAgICBhcnJheV9yZWR1Y2UobWVzc2FnZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLnByb21pc2UgPSBwcm9taXNlO1xuZnVuY3Rpb24gcHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLy8gWFhYIGV4cGVyaW1lbnRhbC4gIFRoaXMgbWV0aG9kIGlzIGEgd2F5IHRvIGRlbm90ZSB0aGF0IGEgbG9jYWwgdmFsdWUgaXNcbi8vIHNlcmlhbGl6YWJsZSBhbmQgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IGRpc3BhdGNoZWQgdG8gYSByZW1vdGUgdXBvbiByZXF1ZXN0LFxuLy8gaW5zdGVhZCBvZiBwYXNzaW5nIGEgcmVmZXJlbmNlLlxuUS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgdHdvIHByb21pc2VzIGV2ZW50dWFsbHkgZnVsZmlsbCB0byB0aGUgc2FtZSB2YWx1ZSwgcHJvbWlzZXMgdGhhdCB2YWx1ZSxcbiAqIGJ1dCBvdGhlcndpc2UgcmVqZWN0cy5cbiAqIEBwYXJhbSB4IHtBbnkqfVxuICogQHBhcmFtIHkge0FueSp9XG4gKiBAcmV0dXJucyB7QW55Kn0gYSBwcm9taXNlIGZvciB4IGFuZCB5IGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBidXQgYSByZWplY3Rpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKi9cblEuam9pbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIFEoeCkuam9pbih5KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHJldHVybiBRKFt0aGlzLCB0aGF0XSkuc3ByZWFkKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBcIj09PVwiIHNob3VsZCBiZSBPYmplY3QuaXMgb3IgZXF1aXZcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5RLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShhbnN3ZXJQcykge1xuICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24oYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTsgICAvLyBlbnN1cmUgdGhlIHVudHJ1c3RlZCBwcm9taXNlIG1ha2VzIGF0IG1vc3QgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNhbGwgdG8gb25lIG9mIHRoZSBjYWxsYmFja3NcblxuICAgIGZ1bmN0aW9uIF9mdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZnVsZmlsbGVkID09PSBcImZ1bmN0aW9uXCIgPyBmdWxmaWxsZWQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlamVjdGVkKGV4Y2VwdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHJlamVjdGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhleGNlcHRpb24sIHNlbGYpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKG5ld0V4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3RXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Byb2dyZXNzZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9ncmVzc2VkID09PSBcImZ1bmN0aW9uXCIgPyBwcm9ncmVzc2VkKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgJiZcbiAgICAgICAgdHlwZW9mIG9iamVjdC5wcm9taXNlRGlzcGF0Y2ggPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0Lmluc3BlY3QgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuUS5pc1Byb21pc2VBbGlrZSA9IGlzUHJvbWlzZUFsaWtlO1xuZnVuY3Rpb24gaXNQcm9taXNlQWxpa2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgJiYgdHlwZW9mIG9iamVjdC50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcGVuZGluZyBwcm9taXNlLCBtZWFuaW5nIG5vdFxuICogZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuICovXG5RLmlzUGVuZGluZyA9IGlzUGVuZGluZztcbmZ1bmN0aW9uIGlzUGVuZGluZyhvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB2YWx1ZSBvciBmdWxmaWxsZWRcbiAqIHByb21pc2UuXG4gKi9cblEuaXNGdWxmaWxsZWQgPSBpc0Z1bGZpbGxlZDtcbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKG9iamVjdCkge1xuICAgIHJldHVybiAhaXNQcm9taXNlKG9iamVjdCkgfHwgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSByZWplY3RlZCBwcm9taXNlLlxuICovXG5RLmlzUmVqZWN0ZWQgPSBpc1JlamVjdGVkO1xuZnVuY3Rpb24gaXNSZWplY3RlZChvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufTtcblxuLy8vLyBCRUdJTiBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8vIFRoaXMgcHJvbWlzZSBsaWJyYXJ5IGNvbnN1bWVzIGV4Y2VwdGlvbnMgdGhyb3duIGluIGhhbmRsZXJzIHNvIHRoZXkgY2FuIGJlXG4vLyBoYW5kbGVkIGJ5IGEgc3Vic2VxdWVudCBwcm9taXNlLiAgVGhlIGV4Y2VwdGlvbnMgZ2V0IGFkZGVkIHRvIHRoaXMgYXJyYXkgd2hlblxuLy8gdGhleSBhcmUgY3JlYXRlZCwgYW5kIHJlbW92ZWQgd2hlbiB0aGV5IGFyZSBoYW5kbGVkLiAgTm90ZSB0aGF0IGluIEVTNiBvclxuLy8gc2hpbW1lZCBlbnZpcm9ubWVudHMsIHRoaXMgd291bGQgbmF0dXJhbGx5IGJlIGEgYFNldGAuXG52YXIgdW5oYW5kbGVkUmVhc29ucyA9IFtdO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWFzb25zRGlzcGxheWVkID0gZmFsc2U7XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc3BsYXlVbmhhbmRsZWRSZWFzb25zKCkge1xuICAgIGlmIChcbiAgICAgICAgIXVuaGFuZGxlZFJlYXNvbnNEaXNwbGF5ZWQgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAhd2luZG93LlRvdWNoICYmXG4gICAgICAgIHdpbmRvdy5jb25zb2xlXG4gICAgKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltRXSBVbmhhbmRsZWQgcmVqZWN0aW9uIHJlYXNvbnMgKHNob3VsZCBiZSBlbXB0eSk6XCIsXG4gICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWFzb25zKTtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWFzb25zRGlzcGxheWVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nVW5oYW5kbGVkUmVhc29ucygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IHVuaGFuZGxlZFJlYXNvbnNbaV07XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaGFuZGxlZCByZWplY3Rpb24gcmVhc29uOlwiLCByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVhc29uc0Rpc3BsYXllZCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuICAgICAgICAvLyBTaG93IHVuaGFuZGxlZCByZWplY3Rpb24gcmVhc29ucyBpZiBOb2RlIGV4aXRzIHdpdGhvdXQgaGFuZGxpbmcgYW5cbiAgICAgICAgLy8gb3V0c3RhbmRpbmcgcmVqZWN0aW9uLiAgKE5vdGUgdGhhdCBCcm93c2VyaWZ5IHByZXNlbnRseSBwcm9kdWNlcyBhXG4gICAgICAgIC8vIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCB0aGUgYEV2ZW50RW1pdHRlcmAgYG9uYCBtZXRob2QuKVxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5vbikge1xuICAgICAgICAgICAgcHJvY2Vzcy5vbihcImV4aXRcIiwgbG9nVW5oYW5kbGVkUmVhc29ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbiAgICBkaXNwbGF5VW5oYW5kbGVkUmVhc29ucygpO1xufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5zcGxpY2UoYXQsIDEpO1xuICAgIH1cbn1cblxuUS5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMgPSByZXNldFVuaGFuZGxlZFJlamVjdGlvbnM7XG5cblEuZ2V0VW5oYW5kbGVkUmVhc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyB0aGF0IGNvbnN1bWVycyBjYW4ndCBpbnRlcmZlcmUgd2l0aCBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gICAgcmV0dXJuIHVuaGFuZGxlZFJlYXNvbnMuc2xpY2UoKTtcbn07XG5cblEuc3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm9uKSB7XG4gICAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJleGl0XCIsIGxvZ1VuaGFuZGxlZFJlYXNvbnMpO1xuICAgIH1cbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEFubm90YXRlcyBhbiBvYmplY3Qgc3VjaCB0aGF0IGl0IHdpbGwgbmV2ZXIgYmVcbiAqIHRyYW5zZmVycmVkIGF3YXkgZnJvbSB0aGlzIHByb2Nlc3Mgb3ZlciBhbnkgcHJvbWlzZVxuICogY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgcHJvbWlzZSBhIHdyYXBwaW5nIG9mIHRoYXQgb2JqZWN0IHRoYXRcbiAqIGFkZGl0aW9uYWxseSByZXNwb25kcyB0byB0aGUgXCJpc0RlZlwiIG1lc3NhZ2VcbiAqIHdpdGhvdXQgYSByZWplY3Rpb24uXG4gKi9cblEubWFzdGVyID0gbWFzdGVyO1xuZnVuY3Rpb24gbWFzdGVyKG9iamVjdCkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJpc0RlZlwiOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKG9wLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBRKG9iamVjdCkuaW5zcGVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFNwcmVhZHMgdGhlIHZhbHVlcyBvZiBhIHByb21pc2VkIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZVxuICogZnVsZmlsbG1lbnQgY2FsbGJhY2suXG4gKiBAcGFyYW0gZnVsZmlsbGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdmFyaWFkaWMgYXJndW1lbnRzIGZyb20gdGhlXG4gKiBwcm9taXNlZCBhcnJheVxuICogQHBhcmFtIHJlamVjdGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgcHJvbWlzZVxuICogaXMgcmVqZWN0ZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb3IgdGhyb3duIGV4Y2VwdGlvbiBvZlxuICogZWl0aGVyIGNhbGxiYWNrLlxuICovXG5RLnNwcmVhZCA9IHNwcmVhZDtcbmZ1bmN0aW9uIHNwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRoZSBhc3luYyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciBmb3IgZ2VuZXJhdG9yIGZ1bmN0aW9ucywgdHVybmluZ1xuICogdGhlbSBpbnRvIGFzeW5jaHJvbm91cyBnZW5lcmF0b3JzLiAgQWx0aG91Z2ggZ2VuZXJhdG9ycyBhcmUgb25seSBwYXJ0XG4gKiBvZiB0aGUgbmV3ZXN0IEVDTUFTY3JpcHQgNiBkcmFmdHMsIHRoaXMgY29kZSBkb2VzIG5vdCBjYXVzZSBzeW50YXhcbiAqIGVycm9ycyBpbiBvbGRlciBlbmdpbmVzLiAgVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrIGFuZCB3aWxsXG4gKiBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiAtLWhhcm1vbnktZ2VuZXJhdG9ycyBydW50aW1lIGZsYWcgZW5hYmxlZC4gIFNwaWRlck1vbmtleSBoYXMgaGFkIHRoZW1cbiAqIGZvciBsb25nZXIsIGJ1dCB1bmRlciBhbiBvbGRlciBQeXRob24taW5zcGlyZWQgZm9ybS4gIFRoaXMgZnVuY3Rpb25cbiAqIHdvcmtzIG9uIGJvdGgga2luZHMgb2YgZ2VuZXJhdG9ycy5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IGFzeW5jO1xuZnVuY3Rpb24gYXN5bmMobWFrZUdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGhhc0VTNkdlbmVyYXRvcnMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBjYXNlIHdoZW4gU00gZG9lcyBFUzYgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjZXB0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBtYWtlR2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJuZXh0XCIpO1xuICAgICAgICB2YXIgZXJyYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJ0aHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc3Bhd24gZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBhc3luYyB0aGF0IGltbWVkaWF0ZWx5XG4gKiBjYWxscyB0aGUgZ2VuZXJhdG9yIGFuZCBhbHNvIGVuZHMgdGhlIHByb21pc2UgY2hhaW4sIHNvIHRoYXQgYW55XG4gKiB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW5zdGVhZCBvZiBmb3J3YXJkZWQgdG8gdGhlIGVycm9yXG4gKiBoYW5kbGVyLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0J3MgZXh0cmVtZWx5IGNvbW1vbiB0byBydW5cbiAqIGdlbmVyYXRvcnMgYXQgdGhlIHRvcC1sZXZlbCB0byB3b3JrIHdpdGggbGlicmFyaWVzLlxuICovXG5RLnNwYXduID0gc3Bhd247XG5mdW5jdGlvbiBzcGF3bihtYWtlR2VuZXJhdG9yKSB7XG4gICAgUS5kb25lKFEuYXN5bmMobWFrZUdlbmVyYXRvcikoKSk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbnRlcmZhY2Ugb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuLyoqXG4gKiBUaHJvd3MgYSBSZXR1cm5WYWx1ZSBleGNlcHRpb24gdG8gc3RvcCBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGEgc3RvcC1nYXAgbWVhc3VyZSB0byBzdXBwb3J0IGdlbmVyYXRvciByZXR1cm5cbiAqIHZhbHVlcyBpbiBvbGRlciBGaXJlZm94L1NwaWRlck1vbmtleS4gIEluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBFUzZcbiAqIGdlbmVyYXRvcnMgbGlrZSBDaHJvbWl1bSAyOSwganVzdCB1c2UgXCJyZXR1cm5cIiBpbiB5b3VyIGdlbmVyYXRvclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGUgc3Vycm91bmRpbmcgZ2VuZXJhdG9yXG4gKiBAdGhyb3dzIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzYgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24qICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgcmV0dXJuIGZvbyArIGJhcjtcbiAqIH0pXG4gKiAvLyBPbGRlciBTcGlkZXJNb25rZXkgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24gKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICBRLnJldHVybihmb28gKyBiYXIpO1xuICogfSlcbiAqL1xuUVtcInJldHVyblwiXSA9IF9yZXR1cm47XG5mdW5jdGlvbiBfcmV0dXJuKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFFSZXR1cm5WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIHByb21pc2VkIGZ1bmN0aW9uIGRlY29yYXRvciBlbnN1cmVzIHRoYXQgYW55IHByb21pc2UgYXJndW1lbnRzXG4gKiBhcmUgc2V0dGxlZCBhbmQgcGFzc2VkIGFzIHZhbHVlcyAoYHRoaXNgIGlzIGFsc28gc2V0dGxlZCBhbmQgcGFzc2VkXG4gKiBhcyBhIHZhbHVlKS4gIEl0IHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gaXNcbiAqIGFsd2F5cyBhIHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBRLnByb21pc2VkKGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgICAgcmV0dXJuIGEgKyBiO1xuICogfSk7XG4gKiBhZGQoUShhKSwgUShCKSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGRlY29yYXRlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQuXG4gKi9cblEucHJvbWlzZWQgPSBwcm9taXNlZDtcbmZ1bmN0aW9uIHByb21pc2VkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNwcmVhZChbdGhpcywgYWxsKGFyZ3VtZW50cyldLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHNlbmRzIGEgbWVzc2FnZSB0byBhIHZhbHVlIGluIGEgZnV0dXJlIHR1cm5cbiAqIEBwYXJhbSBvYmplY3QqIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBvcCB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBvcGVyYXRpb24sIGUuZy4sIFwid2hlblwiLFxuICogQHBhcmFtIGFyZ3MgZnVydGhlciBhcmd1bWVudHMgdG8gYmUgZm9yd2FyZGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHJlc3VsdCB7UHJvbWlzZX0gYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAqL1xuUS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuZnVuY3Rpb24gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2gob3AsIGFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZGVmZXJyZWQucmVzb2x2ZSwgb3AsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGdldFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcHJvcGVydHkgdmFsdWVcbiAqL1xuUS5nZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciBvYmplY3Qgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0gdmFsdWUgICAgIG5ldyB2YWx1ZSBvZiBwcm9wZXJ0eVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGRlbGV0ZVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSB2YWx1ZSAgICAgYSB2YWx1ZSB0byBwb3N0LCB0eXBpY2FsbHkgYW4gYXJyYXkgb2ZcbiAqICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBhcmd1bWVudHMgZm9yIHByb21pc2VzIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgYXJlIHVsdGltYXRlbHkgYmFja2VkIHdpdGggYHJlc29sdmVgIHZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgYXMgb3Bwb3NlZCB0byB0aG9zZSBiYWNrZWQgd2l0aCBVUkxzXG4gKiAgICAgICAgICAgICAgICAgIHdoZXJlaW4gdGhlIHBvc3RlZCB2YWx1ZSBjYW4gYmUgYW55XG4gKiAgICAgICAgICAgICAgICAgIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG4vLyBib3VuZCBsb2NhbGx5IGJlY2F1c2UgaXQgaXMgdXNlZCBieSBvdGhlciBtZXRob2RzXG5RLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGludm9jYXRpb24gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblEubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMildKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUHJvbWlzZS5wcm90b3R5cGUubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSBhcmdzICAgICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmFwcGx5ID0gZnVuY3Rpb24gKG9iamVjdCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblFbXCJ0cnlcIl0gPVxuUS5mY2FsbCA9IGZ1bmN0aW9uIChvYmplY3QgLyogLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMpXSk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiwgdHJhbnNmb3JtaW5nIHJldHVybiB2YWx1ZXMgaW50byBhIGZ1bGZpbGxlZFxuICogcHJvbWlzZSBhbmQgdGhyb3duIGVycm9ycyBpbnRvIGEgcmVqZWN0ZWQgb25lLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYmluZCA9IGZ1bmN0aW9uIChvYmplY3QgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IFEob2JqZWN0KTtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5mYmluZCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIG5hbWVzIG9mIHRoZSBvd25lZCBwcm9wZXJ0aWVzIG9mIGEgcHJvbWlzZWRcbiAqIG9iamVjdCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIGtleXMgb2YgdGhlIGV2ZW50dWFsbHkgc2V0dGxlZCBvYmplY3RcbiAqL1xuUS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5LiAgSWYgYW55IG9mXG4gKiB0aGUgcHJvbWlzZXMgZ2V0cyByZWplY3RlZCwgdGhlIHdob2xlIGFycmF5IGlzIHJlamVjdGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzXG4gKi9cbi8vIEJ5IE1hcmsgTWlsbGVyXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpjb25jdXJyZW5jeSZyZXY9MTMwODc3NjUyMSNhbGxmdWxmaWxsZWRcblEuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgY291bnREb3duID0gMDtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9taXNlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzUHJvbWlzZShwcm9taXNlKSAmJlxuICAgICAgICAgICAgICAgIChzbmFwc2hvdCA9IHByb21pc2UuaW5zcGVjdCgpKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gc25hcHNob3QudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsrY291bnREb3duO1xuICAgICAgICAgICAgICAgIHdoZW4oXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7IGluZGV4OiBpbmRleCwgdmFsdWU6IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgaWYgKGNvdW50RG93biA9PT0gMCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVE9ETyBhdHRlbXB0IHRvIHJlY3ljbGUgdGhlIHJlamVjdGlvbiB3aXRoIFwidGhpc1wiLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcywgZm9yY2luZyByZWplY3Rpb25zIHRvIGJlXG4gKiB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBhdCB0aGUgZW5kIG9mIGEgY2hhaW4gb2YgcHJvbWlzZXNcbiAqIEByZXR1cm5zIG5vdGhpbmdcbiAqL1xuUS5kb25lID0gZnVuY3Rpb24gKG9iamVjdCwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRvbmUoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGZvcndhcmQgdG8gYSBmdXR1cmUgdHVybiBzbyB0aGF0IGBgd2hlbmBgXG4gICAgICAgIC8vIGRvZXMgbm90IGNhdGNoIGl0IGFuZCB0dXJuIGl0IGludG8gYSByZWplY3Rpb24uXG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge1N0cmluZ30gY3VzdG9tIGVycm9yIG1lc3NhZ2UgKG9wdGlvbmFsKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpZiBpdCBpc1xuICogZnVsZmlsbGVkIGJlZm9yZSB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICovXG5RLnRpbWVvdXQgPSBmdW5jdGlvbiAob2JqZWN0LCBtcywgbWVzc2FnZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgbWVzc2FnZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IobWVzc2FnZSB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIikpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgIH0sIGRlZmVycmVkLm5vdGlmeSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5RLmRlbGF5ID0gZnVuY3Rpb24gKG9iamVjdCwgdGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUShvYmplY3QpLmRlbGF5KHRpbWVvdXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgYXMgYW4gYXJyYXksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiAgICAgIFEubmZhcHBseShGUy5yZWFkRmlsZSwgW19fZmlsZW5hbWVdKVxuICogICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogICAgICB9KVxuICpcbiAqL1xuUS5uZmFwcGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBpbmRpdmlkdWFsbHksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mY2FsbChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSlcbiAqIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiB9KVxuICpcbiAqL1xuUS5uZmNhbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIGEgTm9kZUpTIGNvbnRpbnVhdGlvbiBwYXNzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnRcbiAqIHZlcnNpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mYmluZChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSkoXCJ1dGYtOFwiKVxuICogLnRoZW4oY29uc29sZS5sb2cpXG4gKiAuZG9uZSgpXG4gKi9cblEubmZiaW5kID1cblEuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgUShjYWxsYmFjaykuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmJpbmQgPVxuUHJvbWlzZS5wcm90b3R5cGUuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5kZW5vZGVpZnkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cblEubmJpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc3AsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUShib3VuZCkuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uYmluZCA9IGZ1bmN0aW9uICgvKnRoaXNwLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMCk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLm5iaW5kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2sgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEubnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ucG9zdChuYW1lLCBhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUubnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MgfHwgW10pO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjaywgZm9yd2FyZGluZyB0aGUgZ2l2ZW4gdmFyaWFkaWMgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGFyZ3VtZW50LlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIC4uLmFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrIHdpbGxcbiAqIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5RLm5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblByb21pc2UucHJvdG90eXBlLm5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBJZiBhIGZ1bmN0aW9uIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBib3RoIE5vZGUgY29udGludWF0aW9uLXBhc3Npbmctc3R5bGUgYW5kXG4gKiBwcm9taXNlLXJldHVybmluZy1zdHlsZSwgaXQgY2FuIGVuZCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBjaGFpbiB3aXRoXG4gKiBgbm9kZWlmeShub2RlYmFjaylgLCBmb3J3YXJkaW5nIHRoZSBvcHRpb25hbCBub2RlYmFjayBhcmd1bWVudC4gIElmIHRoZSB1c2VyXG4gKiBlbGVjdHMgdG8gdXNlIGEgbm9kZWJhY2ssIHRoZSByZXN1bHQgd2lsbCBiZSBzZW50IHRoZXJlLiAgSWYgdGhleSBkbyBub3RcbiAqIHBhc3MgYSBub2RlYmFjaywgdGhleSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBwcm9taXNlLlxuICogQHBhcmFtIG9iamVjdCBhIHJlc3VsdCAob3IgYSBwcm9taXNlIGZvciBhIHJlc3VsdClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5vZGViYWNrIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFja1xuICogQHJldHVybnMgZWl0aGVyIHRoZSBwcm9taXNlIG9yIG5vdGhpbmdcbiAqL1xuUS5ub2RlaWZ5ID0gbm9kZWlmeTtcbmZ1bmN0aW9uIG5vZGVpZnkob2JqZWN0LCBub2RlYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdCkubm9kZWlmeShub2RlYmFjayk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2spIHtcbiAgICBpZiAobm9kZWJhY2spIHtcbiAgICAgICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIvVXNlcnMvYWFuYW5kL0lkZWFQcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qZ2xvYmFsIHVuZXNjYXBlLCBtb2R1bGUsIGRlZmluZSwgd2luZG93LCBnbG9iYWwqL1xyXG5cclxuLypcclxuIFVyaVRlbXBsYXRlIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIEZyYW56IEFudGVzYmVyZ2VyLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gQXZhaWxhYmxlIHZpYSB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcblxyXG4oZnVuY3Rpb24gKGV4cG9ydENhbGxiYWNrKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBVcmlUZW1wbGF0ZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBVcmlUZW1wbGF0ZUVycm9yIChvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBVcmlUZW1wbGF0ZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoSlNPTiAmJiBKU09OLnN0cmluZ2lmeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gVXJpVGVtcGxhdGVFcnJvcjtcclxufSgpKTtcclxuXHJcbnZhciBvYmplY3RIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gaXNBcnJheSAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcgKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIgKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBqb2luIChhcnIsIHNlcGFyYXRvcikge1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyxcclxuICAgICAgICAgICAgZmlyc3QgPSB0cnVlLFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnIubGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZXBhcmF0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9IGFycltpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFwIChhcnIsIG1hcHBlcikge1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGFyci5sZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVyKGFycltpbmRleF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXIgKGFyciwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgYXJyLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGFycltpbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJbaW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlZXBGcmVlemVVc2luZ09iamVjdEZyZWV6ZSAob2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgb2JqZWN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5mcmVlemUob2JqZWN0KTtcclxuICAgICAgICB2YXIgcHJvcGVydHksIHByb3BlcnR5TmFtZTtcclxuICAgICAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG9iamVjdFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgLy8gYmUgYXdhcmUsIGFycmF5cyBhcmUgJ29iamVjdCcsIHRvb1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZXBGcmVlemUocHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVlcEZyZWV6ZSAob2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWVwRnJlZXplVXNpbmdPYmplY3RGcmVlemUob2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxyXG4gICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcclxuICAgICAgICBpc051bWJlcjogaXNOdW1iZXIsXHJcbiAgICAgICAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXHJcbiAgICAgICAgam9pbjogam9pbixcclxuICAgICAgICBtYXA6IG1hcCxcclxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICBkZWVwRnJlZXplOiBkZWVwRnJlZXplXHJcbiAgICB9O1xyXG59KCkpO1xyXG5cclxudmFyIGNoYXJIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQWxwaGEgKGNocikge1xyXG4gICAgICAgIHJldHVybiAoY2hyID49ICdhJyAmJiBjaHIgPD0gJ3onKSB8fCAoKGNociA+PSAnQScgJiYgY2hyIDw9ICdaJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGlnaXQgKGNocikge1xyXG4gICAgICAgIHJldHVybiBjaHIgPj0gJzAnICYmIGNociA8PSAnOSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdCAoY2hyKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRGlnaXQoY2hyKSB8fCAoY2hyID49ICdhJyAmJiBjaHIgPD0gJ2YnKSB8fCAoY2hyID49ICdBJyAmJiBjaHIgPD0gJ0YnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzQWxwaGE6IGlzQWxwaGEsXHJcbiAgICAgICAgaXNEaWdpdDogaXNEaWdpdCxcclxuICAgICAgICBpc0hleERpZ2l0OiBpc0hleERpZ2l0XHJcbiAgICB9O1xyXG59KCkpO1xyXG5cclxudmFyIHBjdEVuY29kZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHV0ZjggPSB7XHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoY2hyKSB7XHJcbiAgICAgICAgICAgIC8vIHNlZSBodHRwOi8vZWNtYW5hdXQuYmxvZ3Nwb3QuZGUvMjAwNi8wNy9lbmNvZGluZy1kZWNvZGluZy11dGY4LWluLWphdmFzY3JpcHQuaHRtbFxyXG4gICAgICAgICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNocikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbnVtQnl0ZXM6IGZ1bmN0aW9uIChmaXJzdENoYXJDb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXJDb2RlIDw9IDB4N0YpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKDB4QzIgPD0gZmlyc3RDaGFyQ29kZSAmJiBmaXJzdENoYXJDb2RlIDw9IDB4REYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKDB4RTAgPD0gZmlyc3RDaGFyQ29kZSAmJiBmaXJzdENoYXJDb2RlIDw9IDB4RUYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKDB4RjAgPD0gZmlyc3RDaGFyQ29kZSAmJiBmaXJzdENoYXJDb2RlIDw9IDB4RjQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIHZhbGlkIGZpcnN0IG9jdGV0XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNWYWxpZEZvbGxvd2luZ0NoYXJDb2RlOiBmdW5jdGlvbiAoY2hhckNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDB4ODAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhCRjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZW5jb2RlcyBhIGNoYXJhY3RlciwgaWYgbmVlZGVkIG9yIG5vdC5cclxuICAgICAqIEBwYXJhbSBjaHJcclxuICAgICAqIEByZXR1cm4gcGN0LWVuY29kZWQgY2hhcmFjdGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGVuY29kZUNoYXJhY3RlciAoY2hyKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICAgICAgICBvY3RldHMgPSB1dGY4LmVuY29kZShjaHIpLFxyXG4gICAgICAgICAgICBvY3RldCxcclxuICAgICAgICAgICAgaW5kZXg7XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb2N0ZXRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICBvY3RldCA9IG9jdGV0cy5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICclJyArIChvY3RldCA8IDB4MTAgPyAnMCcgOiAnJykgKyBvY3RldC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMsIHdoZXRoZXIgdGhlIGdpdmVuIHRleHQgYXQgc3RhcnQgaXMgaW4gdGhlIGZvcm0gJ3BlcmNlbnQgaGV4LWRpZ2l0IGhleC1kaWdpdCcsIGxpa2UgJyUzRidcclxuICAgICAqIEBwYXJhbSB0ZXh0XHJcbiAgICAgKiBAcGFyYW0gc3RhcnRcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW58KnwqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1BlcmNlbnREaWdpdERpZ2l0ICh0ZXh0LCBzdGFydCkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0LmNoYXJBdChzdGFydCkgPT09ICclJyAmJiBjaGFySGVscGVyLmlzSGV4RGlnaXQodGV4dC5jaGFyQXQoc3RhcnQgKyAxKSkgJiYgY2hhckhlbHBlci5pc0hleERpZ2l0KHRleHQuY2hhckF0KHN0YXJ0ICsgMikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgaGV4IG51bWJlciBmcm9tIHN0YXJ0IHdpdGggbGVuZ3RoIDIuXHJcbiAgICAgKiBAcGFyYW0gdGV4dCBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0YXJ0IHRoZSBzdGFydCBpbmRleCBvZiB0aGUgMi1kaWdpdCBoZXggbnVtYmVyXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhcnNlSGV4MiAodGV4dCwgc3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dC5zdWJzdHIoc3RhcnQsIDIpLCAxNik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBjaGFyIHNlcXVlbmNlIGlzIGEgY29ycmVjdGx5IHBjdC1lbmNvZGVkIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNQY3RFbmNvZGVkIChjaHIpIHtcclxuICAgICAgICBpZiAoIWlzUGVyY2VudERpZ2l0RGlnaXQoY2hyLCAwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXJzdENoYXJDb2RlID0gcGFyc2VIZXgyKGNociwgMSk7XHJcbiAgICAgICAgdmFyIG51bUJ5dGVzID0gdXRmOC5udW1CeXRlcyhmaXJzdENoYXJDb2RlKTtcclxuICAgICAgICBpZiAobnVtQnl0ZXMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBieXRlTnVtYmVyID0gMTsgYnl0ZU51bWJlciA8IG51bUJ5dGVzOyBieXRlTnVtYmVyICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1BlcmNlbnREaWdpdERpZ2l0KGNociwgMypieXRlTnVtYmVyKSB8fCAhdXRmOC5pc1ZhbGlkRm9sbG93aW5nQ2hhckNvZGUocGFyc2VIZXgyKGNociwgMypieXRlTnVtYmVyICsgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhcyBtdWNoIGFzIG5lZWRlZCBmcm9tIHRoZSB0ZXh0LCBlLmcuICclMjAnIG9yICclQzMlQjYnLiBJdCBkb2VzIG5vdCBkZWNvZGUhXHJcbiAgICAgKiBAcGFyYW0gdGV4dFxyXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXhcclxuICAgICAqIEByZXR1cm4gdGhlIGNoYXJhY3RlciBvciBwY3Qtc3RyaW5nIG9mIHRoZSB0ZXh0IGF0IHN0YXJ0SW5kZXhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGN0Q2hhckF0KHRleHQsIHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICB2YXIgY2hyID0gdGV4dC5jaGFyQXQoc3RhcnRJbmRleCk7XHJcbiAgICAgICAgaWYgKCFpc1BlcmNlbnREaWdpdERpZ2l0KHRleHQsIHN0YXJ0SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1dGY4Q2hhckNvZGUgPSBwYXJzZUhleDIodGV4dCwgc3RhcnRJbmRleCArIDEpO1xyXG4gICAgICAgIHZhciBudW1CeXRlcyA9IHV0ZjgubnVtQnl0ZXModXRmOENoYXJDb2RlKTtcclxuICAgICAgICBpZiAobnVtQnl0ZXMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNocjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgYnl0ZU51bWJlciA9IDE7IGJ5dGVOdW1iZXIgPCBudW1CeXRlczsgYnl0ZU51bWJlciArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNQZXJjZW50RGlnaXREaWdpdCh0ZXh0LCBzdGFydEluZGV4ICsgMyAqIGJ5dGVOdW1iZXIpIHx8ICF1dGY4LmlzVmFsaWRGb2xsb3dpbmdDaGFyQ29kZShwYXJzZUhleDIodGV4dCwgc3RhcnRJbmRleCArIDMgKiBieXRlTnVtYmVyICsgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cihzdGFydEluZGV4LCAzICogbnVtQnl0ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZW5jb2RlQ2hhcmFjdGVyOiBlbmNvZGVDaGFyYWN0ZXIsXHJcbiAgICAgICAgaXNQY3RFbmNvZGVkOiBpc1BjdEVuY29kZWQsXHJcbiAgICAgICAgcGN0Q2hhckF0OiBwY3RDaGFyQXRcclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG52YXIgcmZjQ2hhckhlbHBlciA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIGFuIGNoYXJhY3RlciBpcyBhbiB2YXJjaGFyIGNoYXJhY3RlciBhY2NvcmRpbmcgMi4zIG9mIHJmYyA2NTcwXHJcbiAgICAgKiBAcGFyYW0gY2hyXHJcbiAgICAgKiBAcmV0dXJuIChCb29sZWFuKVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1ZhcmNoYXIgKGNocikge1xyXG4gICAgICAgIHJldHVybiBjaGFySGVscGVyLmlzQWxwaGEoY2hyKSB8fCBjaGFySGVscGVyLmlzRGlnaXQoY2hyKSB8fCBjaHIgPT09ICdfJyB8fCBwY3RFbmNvZGVyLmlzUGN0RW5jb2RlZChjaHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpZiBjaHIgaXMgYW4gdW5yZXNlcnZlZCBjaGFyYWN0ZXIgYWNjb3JkaW5nIDEuNSBvZiByZmMgNjU3MFxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNVbnJlc2VydmVkIChjaHIpIHtcclxuICAgICAgICByZXR1cm4gY2hhckhlbHBlci5pc0FscGhhKGNocikgfHwgY2hhckhlbHBlci5pc0RpZ2l0KGNocikgfHwgY2hyID09PSAnLScgfHwgY2hyID09PSAnLicgfHwgY2hyID09PSAnXycgfHwgY2hyID09PSAnfic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIGNociBpcyBhbiByZXNlcnZlZCBjaGFyYWN0ZXIgYWNjb3JkaW5nIDEuNSBvZiByZmMgNjU3MFxyXG4gICAgICogb3IgdGhlIHBlcmNlbnQgY2hhcmFjdGVyIG1lbnRpb25lZCBpbiAzLjIuMS5cclxuICAgICAqIEBwYXJhbSBjaHJcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKGNocikge1xyXG4gICAgICAgIHJldHVybiBjaHIgPT09ICc6JyB8fCBjaHIgPT09ICcvJyB8fCBjaHIgPT09ICc/JyB8fCBjaHIgPT09ICcjJyB8fCBjaHIgPT09ICdbJyB8fCBjaHIgPT09ICddJyB8fCBjaHIgPT09ICdAJyB8fCBjaHIgPT09ICchJyB8fCBjaHIgPT09ICckJyB8fCBjaHIgPT09ICcmJyB8fCBjaHIgPT09ICcoJyB8fFxyXG4gICAgICAgICAgICBjaHIgPT09ICcpJyB8fCBjaHIgPT09ICcqJyB8fCBjaHIgPT09ICcrJyB8fCBjaHIgPT09ICcsJyB8fCBjaHIgPT09ICc7JyB8fCBjaHIgPT09ICc9JyB8fCBjaHIgPT09IFwiJ1wiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNWYXJjaGFyOiBpc1ZhcmNoYXIsXHJcbiAgICAgICAgaXNVbnJlc2VydmVkOiBpc1VucmVzZXJ2ZWQsXHJcbiAgICAgICAgaXNSZXNlcnZlZDogaXNSZXNlcnZlZFxyXG4gICAgfTtcclxuXHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogZW5jb2Rpbmcgb2YgcmZjIDY1NzBcclxuICovXHJcbnZhciBlbmNvZGluZ0hlbHBlciA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gZW5jb2RlICh0ZXh0LCBwYXNzUmVzZXJ2ZWQpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gJycsXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICBjaHIgPSAnJztcclxuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRleHQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRleHQubGVuZ3RoOyBpbmRleCArPSBjaHIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNociA9IHRleHQuY2hhckF0KGluZGV4KTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHJmY0NoYXJIZWxwZXIuaXNVbnJlc2VydmVkKGNocikgfHwgKHBhc3NSZXNlcnZlZCAmJiByZmNDaGFySGVscGVyLmlzUmVzZXJ2ZWQoY2hyKSkgPyBjaHIgOiBwY3RFbmNvZGVyLmVuY29kZUNoYXJhY3RlcihjaHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuY29kZVBhc3NSZXNlcnZlZCAodGV4dCkge1xyXG4gICAgICAgIHJldHVybiBlbmNvZGUodGV4dCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5jb2RlTGl0ZXJhbENoYXJhY3RlciAobGl0ZXJhbCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgY2hyID0gcGN0RW5jb2Rlci5wY3RDaGFyQXQobGl0ZXJhbCwgaW5kZXgpO1xyXG4gICAgICAgIGlmIChjaHIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJmY0NoYXJIZWxwZXIuaXNSZXNlcnZlZChjaHIpIHx8IHJmY0NoYXJIZWxwZXIuaXNVbnJlc2VydmVkKGNocikgPyBjaHIgOiBwY3RFbmNvZGVyLmVuY29kZUNoYXJhY3RlcihjaHIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmNvZGVMaXRlcmFsIChsaXRlcmFsKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgY2hyID0gJyc7XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGl0ZXJhbC5sZW5ndGg7IGluZGV4ICs9IGNoci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2hyID0gcGN0RW5jb2Rlci5wY3RDaGFyQXQobGl0ZXJhbCwgaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmZjQ2hhckhlbHBlci5pc1Jlc2VydmVkKGNocikgfHwgcmZjQ2hhckhlbHBlci5pc1VucmVzZXJ2ZWQoY2hyKSA/IGNociA6IHBjdEVuY29kZXIuZW5jb2RlQ2hhcmFjdGVyKGNocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxyXG4gICAgICAgIGVuY29kZVBhc3NSZXNlcnZlZDogZW5jb2RlUGFzc1Jlc2VydmVkLFxyXG4gICAgICAgIGVuY29kZUxpdGVyYWw6IGVuY29kZUxpdGVyYWwsXHJcbiAgICAgICAgZW5jb2RlTGl0ZXJhbENoYXJhY3RlcjogZW5jb2RlTGl0ZXJhbENoYXJhY3RlclxyXG4gICAgfTtcclxuXHJcbn0oKSk7XHJcblxyXG5cclxuLy8gdGhlIG9wZXJhdG9ycyBkZWZpbmVkIGJ5IHJmYyA2NTcwXHJcbnZhciBvcGVyYXRvcnMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhclxyXG4gICAgICAgIGJ5U3ltYm9sID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlIChzeW1ib2wpIHtcclxuICAgICAgICBieVN5bWJvbFtzeW1ib2xdID0ge1xyXG4gICAgICAgICAgICBzeW1ib2w6IHN5bWJvbCxcclxuICAgICAgICAgICAgc2VwYXJhdG9yOiAoc3ltYm9sID09PSAnPycpID8gJyYnIDogKHN5bWJvbCA9PT0gJycgfHwgc3ltYm9sID09PSAnKycgfHwgc3ltYm9sID09PSAnIycpID8gJywnIDogc3ltYm9sLFxyXG4gICAgICAgICAgICBuYW1lZDogc3ltYm9sID09PSAnOycgfHwgc3ltYm9sID09PSAnJicgfHwgc3ltYm9sID09PSAnPycsXHJcbiAgICAgICAgICAgIGlmRW1wdHk6IChzeW1ib2wgPT09ICcmJyB8fCBzeW1ib2wgPT09ICc/JykgPyAnPScgOiAnJyxcclxuICAgICAgICAgICAgZmlyc3Q6IChzeW1ib2wgPT09ICcrJyApID8gJycgOiBzeW1ib2wsXHJcbiAgICAgICAgICAgIGVuY29kZTogKHN5bWJvbCA9PT0gJysnIHx8IHN5bWJvbCA9PT0gJyMnKSA/IGVuY29kaW5nSGVscGVyLmVuY29kZVBhc3NSZXNlcnZlZCA6IGVuY29kaW5nSGVscGVyLmVuY29kZSxcclxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlKCcnKTtcclxuICAgIGNyZWF0ZSgnKycpO1xyXG4gICAgY3JlYXRlKCcjJyk7XHJcbiAgICBjcmVhdGUoJy4nKTtcclxuICAgIGNyZWF0ZSgnLycpO1xyXG4gICAgY3JlYXRlKCc7Jyk7XHJcbiAgICBjcmVhdGUoJz8nKTtcclxuICAgIGNyZWF0ZSgnJicpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiAoY2hyKSB7XHJcbiAgICAgICAgICAgIGlmIChieVN5bWJvbFtjaHJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnlTeW1ib2xbY2hyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXCI9LCFAfFwiLmluZGV4T2YoY2hyKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnlTeW1ib2xbJyddO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVjdHMsIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IGlzIGRlZmluZWQgaW4gdGhlIHNlbnNlIG9mIHJmYyA2NTcwXHJcbiAqIFNlY3Rpb24gMi4zIG9mIHRoZSBSRkMgbWFrZXMgY2xlYXIgZGVmaW50aW9uczpcclxuICogKiB1bmRlZmluZWQgYW5kIG51bGwgYXJlIG5vdCBkZWZpbmVkLlxyXG4gKiAqIHRoZSBlbXB0eSBzdHJpbmcgaXMgZGVmaW5lZFxyXG4gKiAqIGFuIGFycmF5IChcImxpc3RcIikgaXMgZGVmaW5lZCwgaWYgaXQgaXMgbm90IGVtcHR5IChldmVuIGlmIGFsbCBlbGVtZW50cyBhcmUgbm90IGRlZmluZWQpXHJcbiAqICogYW4gb2JqZWN0IChcIm1hcFwiKSBpcyBkZWZpbmVkLCBpZiBpdCBjb250YWlucyBhdCBsZWFzdCBvbmUgcHJvcGVydHkgd2l0aCBkZWZpbmVkIHZhbHVlXHJcbiAqIEBwYXJhbSBvYmplY3RcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRGVmaW5lZCAob2JqZWN0KSB7XHJcbiAgICB2YXJcclxuICAgICAgICBwcm9wZXJ0eU5hbWU7XHJcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iamVjdEhlbHBlci5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgICAgICAvLyBTZWN0aW9uIDIuMzogQSB2YXJpYWJsZSBkZWZpbmVkIGFzIGEgbGlzdCB2YWx1ZSBpcyBjb25zaWRlcmVkIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBjb250YWlucyB6ZXJvIG1lbWJlcnNcclxuICAgICAgICByZXR1cm4gb2JqZWN0Lmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygb2JqZWN0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBvYmplY3QgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgLy8gZmFsc3kgdmFsdWVzIGxpa2UgZW1wdHkgc3RyaW5ncywgZmFsc2Ugb3IgMCBhcmUgXCJkZWZpbmVkXCJcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGVsc2UgT2JqZWN0XHJcbiAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiBvYmplY3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgJiYgaXNEZWZpbmVkKG9iamVjdFtwcm9wZXJ0eU5hbWVdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbnZhciBMaXRlcmFsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaXRlcmFsRXhwcmVzc2lvbiAobGl0ZXJhbCkge1xyXG4gICAgICAgIHRoaXMubGl0ZXJhbCA9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwobGl0ZXJhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZXJhbEV4cHJlc3Npb24ucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlcmFsRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBMaXRlcmFsRXhwcmVzc2lvbi5wcm90b3R5cGUuZXhwYW5kO1xyXG5cclxuICAgIHJldHVybiBMaXRlcmFsRXhwcmVzc2lvbjtcclxufSgpKTtcclxuXHJcbnZhciBwYXJzZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uIChleHByZXNzaW9uVGV4dCkge1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICBvcGVyYXRvcixcclxuICAgICAgICAgICAgdmFyc3BlY3MgPSBbXSxcclxuICAgICAgICAgICAgdmFyc3BlYyA9IG51bGwsXHJcbiAgICAgICAgICAgIHZhcm5hbWVTdGFydCA9IG51bGwsXHJcbiAgICAgICAgICAgIG1heExlbmd0aFN0YXJ0ID0gbnVsbCxcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgIGNociA9ICcnO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjbG9zZVZhcm5hbWUgKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFybmFtZSA9IGV4cHJlc3Npb25UZXh0LnN1YnN0cmluZyh2YXJuYW1lU3RhcnQsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKHZhcm5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImEgdmFybmFtZSBtdXN0IGJlIHNwZWNpZmllZFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXJzcGVjID0ge3Zhcm5hbWU6IHZhcm5hbWUsIGV4cGxvZGVkOiBmYWxzZSwgbWF4TGVuZ3RoOiBudWxsfTtcclxuICAgICAgICAgICAgdmFybmFtZVN0YXJ0ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlTWF4TGVuZ3RoICgpIHtcclxuICAgICAgICAgICAgaWYgKG1heExlbmd0aFN0YXJ0ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJhZnRlciBhICc6JyB5b3UgaGF2ZSB0byBzcGVjaWZ5IHRoZSBsZW5ndGhcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyc3BlYy5tYXhMZW5ndGggPSBwYXJzZUludChleHByZXNzaW9uVGV4dC5zdWJzdHJpbmcobWF4TGVuZ3RoU3RhcnQsIGluZGV4KSwgMTApO1xyXG4gICAgICAgICAgICBtYXhMZW5ndGhTdGFydCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcGVyYXRvciA9IChmdW5jdGlvbiAob3BlcmF0b3JUZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBvcCA9IG9wZXJhdG9ycy52YWx1ZU9mKG9wZXJhdG9yVGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvcCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJpbGxlZ2FsIHVzZSBvZiByZXNlcnZlZCBvcGVyYXRvclwiLCBwb3NpdGlvbjogaW5kZXgsIG9wZXJhdG9yOiBvcGVyYXRvclRleHR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3A7XHJcbiAgICAgICAgfShleHByZXNzaW9uVGV4dC5jaGFyQXQoMCkpKTtcclxuICAgICAgICBpbmRleCA9IG9wZXJhdG9yLnN5bWJvbC5sZW5ndGg7XHJcblxyXG4gICAgICAgIHZhcm5hbWVTdGFydCA9IGluZGV4O1xyXG5cclxuICAgICAgICBmb3IgKDsgaW5kZXggPCBleHByZXNzaW9uVGV4dC5sZW5ndGg7IGluZGV4ICs9IGNoci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2hyID0gcGN0RW5jb2Rlci5wY3RDaGFyQXQoZXhwcmVzc2lvblRleHQsIGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YXJuYW1lU3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzcGVjIHNheXM6IHZhcm5hbWUgPSAgdmFyY2hhciAqKCBbXCIuXCJdIHZhcmNoYXIgKVxyXG4gICAgICAgICAgICAgICAgLy8gc28gYSBkb3QgaXMgYWxsb3dlZCBleGNlcHQgZm9yIHRoZSBmaXJzdCBjaGFyXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFybmFtZVN0YXJ0ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImEgdmFybmFtZSBNVVNUIE5PVCBzdGFydCB3aXRoIGEgZG90XCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZmNDaGFySGVscGVyLmlzVmFyY2hhcihjaHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbG9zZVZhcm5hbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4TGVuZ3RoU3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbWF4TGVuZ3RoU3RhcnQgJiYgY2hyID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcIkEgOnByZWZpeCBtdXN0IG5vdCBzdGFydCB3aXRoIGRpZ2l0IDBcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhckhlbHBlci5pc0RpZ2l0KGNocikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggLSBtYXhMZW5ndGhTdGFydCA+PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiQSA6cHJlZml4IG11c3QgaGF2ZSBtYXggNCBkaWdpdHNcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xvc2VNYXhMZW5ndGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hyID09PSAnOicpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YXJzcGVjLm1heExlbmd0aCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwib25seSBvbmUgOm1heExlbmd0aCBpcyBhbGxvd2VkIHBlciB2YXJzcGVjXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhcnNwZWMuZXhwbG9kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImFuIGV4cGxvZWRlZCB2YXJzcGVjIE1VU1QgTk9UIGJlIHZhcnNwZWNlZFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1heExlbmd0aFN0YXJ0ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNociA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFyc3BlYyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiZXhwbG9kZWQgd2l0aG91dCB2YXJzcGVjXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhcnNwZWMuZXhwbG9kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImV4cGxvZGVkIHR3aWNlXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhcnNwZWMubWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJhbiBleHBsb2RlICgqKSBNVVNUIE5PVCBmb2xsb3cgdG8gYSBwcmVmaXhcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXJzcGVjLmV4cGxvZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGxlZ2FsIGNoYXJhY3RlciBub3cgaXMgdGhlIGNvbW1hXHJcbiAgICAgICAgICAgIGlmIChjaHIgPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgdmFyc3BlY3MucHVzaCh2YXJzcGVjKTtcclxuICAgICAgICAgICAgICAgIHZhcnNwZWMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFybmFtZVN0YXJ0ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJpbGxlZ2FsIGNoYXJhY3RlclwiLCBjaGFyYWN0ZXI6IGNociwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgfSAvLyBmb3IgY2hyXHJcbiAgICAgICAgaWYgKHZhcm5hbWVTdGFydCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjbG9zZVZhcm5hbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heExlbmd0aFN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNsb3NlTWF4TGVuZ3RoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhcnNwZWNzLnB1c2godmFyc3BlYyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZUV4cHJlc3Npb24oZXhwcmVzc2lvblRleHQsIG9wZXJhdG9yLCB2YXJzcGVjcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2UgKHVyaVRlbXBsYXRlVGV4dCkge1xyXG4gICAgICAgIC8vIGFzc2VydCBmaWxsZWQgc3RyaW5nXHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICBjaHIsXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW10sXHJcbiAgICAgICAgICAgIGJyYWNlT3BlbkluZGV4ID0gbnVsbCxcclxuICAgICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gMDtcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB1cmlUZW1wbGF0ZVRleHQubGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgIGNociA9IHVyaVRlbXBsYXRlVGV4dC5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAobGl0ZXJhbFN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwidW5vcGVuZWQgYnJhY2UgY2xvc2VkXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNociA9PT0gJ3snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpdGVyYWxTdGFydCA8IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IExpdGVyYWxFeHByZXNzaW9uKHVyaVRlbXBsYXRlVGV4dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpbmRleCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmFjZU9wZW5JbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChicmFjZU9wZW5JbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGVyZSBqdXN0IHsgaXMgZm9yYmlkZGVuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAneycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwiYnJhY2UgYWxyZWFkeSBvcGVuZWRcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2VPcGVuSW5kZXggKyAxID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwiZW1wdHkgYnJhY2VzXCIsIHBvc2l0aW9uOiBicmFjZU9wZW5JbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlRXhwcmVzc2lvbih1cmlUZW1wbGF0ZVRleHQuc3Vic3RyaW5nKGJyYWNlT3BlbkluZGV4ICsgMSwgaW5kZXgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IucHJvdG90eXBlID09PSBVcmlUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe3RlbXBsYXRlVGV4dDogdXJpVGVtcGxhdGVUZXh0LCBtZXNzYWdlOiBlcnJvci5vcHRpb25zLm1lc3NhZ2UsIHBvc2l0aW9uOiBicmFjZU9wZW5JbmRleCArIGVycm9yLm9wdGlvbnMucG9zaXRpb24sIGRldGFpbHM6IGVycm9yLm9wdGlvbnN9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VPcGVuSW5kZXggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY2hlZCB1bnJlYWNoYWJsZSBjb2RlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChicmFjZU9wZW5JbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwidW5jbG9zZWQgYnJhY2VcIiwgcG9zaXRpb246IGJyYWNlT3BlbkluZGV4fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaXRlcmFsU3RhcnQgPCB1cmlUZW1wbGF0ZVRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IExpdGVyYWxFeHByZXNzaW9uKHVyaVRlbXBsYXRlVGV4dC5zdWJzdHIobGl0ZXJhbFN0YXJ0KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVyaVRlbXBsYXRlKHVyaVRlbXBsYXRlVGV4dCwgZXhwcmVzc2lvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZTtcclxufSgpKTtcclxuXHJcbnZhciBWYXJpYWJsZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGlmIEpTT04gaXMgbm90IGF2YWlsYWJsZVxyXG4gICAgZnVuY3Rpb24gcHJldHR5UHJpbnQgKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIChKU09OICYmIEpTT04uc3RyaW5naWZ5KSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkgKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyLmlzTnVtYmVyKHZhbHVlKSB8fCBvYmplY3RIZWxwZXIuaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXIuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvcGVydHlBcnJheSAob2JqZWN0KSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU7XHJcbiAgICAgICAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe25hbWU6IHByb3BlcnR5TmFtZSwgdmFsdWU6IG9iamVjdFtwcm9wZXJ0eU5hbWVdfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBWYXJpYWJsZUV4cHJlc3Npb24gKHRlbXBsYXRlVGV4dCwgb3BlcmF0b3IsIHZhcnNwZWNzKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVRleHQgPSB0ZW1wbGF0ZVRleHQ7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgICAgIHRoaXMudmFyc3BlY3MgPSB2YXJzcGVjcztcclxuICAgIH1cclxuXHJcbiAgICBWYXJpYWJsZUV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlVGV4dDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kU2ltcGxlVmFsdWUodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAob3BlcmF0b3IubmFtZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwodmFyc3BlYy52YXJuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG9wZXJhdG9yLmlmRW1wdHk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnPSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YXJzcGVjLm1heExlbmd0aCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCB2YXJzcGVjLm1heExlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSBvcGVyYXRvci5lbmNvZGUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVEZWZpbmVkIChuYW1lVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaXNEZWZpbmVkKG5hbWVWYWx1ZS52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kTm90RXhwbG9kZWQodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGFyciA9IFtdLFxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcclxuICAgICAgICBpZiAob3BlcmF0b3IubmFtZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwodmFyc3BlYy52YXJuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gb3BlcmF0b3IuaWZFbXB0eTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9ICc9JztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlci5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBhcnIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLmZpbHRlcihhcnIsIGlzRGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5tYXAoYXJyLCBvcGVyYXRvci5lbmNvZGUpO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gb2JqZWN0SGVscGVyLmpvaW4oYXJyLCAnLCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJyID0gcHJvcGVydHlBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5maWx0ZXIoYXJyLCB2YWx1ZURlZmluZWQpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIubWFwKGFyciwgZnVuY3Rpb24gKG5hbWVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yLmVuY29kZShuYW1lVmFsdWUubmFtZSkgKyAnLCcgKyBvcGVyYXRvci5lbmNvZGUobmFtZVZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBvYmplY3RIZWxwZXIuam9pbihhcnIsICcsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kRXhwbG9kZWROYW1lZCAodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGlzQXJyYXkgPSBvYmplY3RIZWxwZXIuaXNBcnJheSh2YWx1ZSksXHJcbiAgICAgICAgICAgIGFyciA9IFtdO1xyXG4gICAgICAgIGlmIChpc0FycmF5KSB7XHJcbiAgICAgICAgICAgIGFyciA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgaXNEZWZpbmVkKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIGZ1bmN0aW9uIChsaXN0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwodmFyc3BlYy52YXJuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGxpc3RFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcCArPSBvcGVyYXRvci5pZkVtcHR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wICs9ICc9JyArIG9wZXJhdG9yLmVuY29kZShsaXN0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyciA9IHByb3BlcnR5QXJyYXkodmFsdWUpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgdmFsdWVEZWZpbmVkKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIGZ1bmN0aW9uIChuYW1lVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBlbmNvZGluZ0hlbHBlci5lbmNvZGVMaXRlcmFsKG5hbWVWYWx1ZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG5hbWVWYWx1ZS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXAgKz0gb3BlcmF0b3IuaWZFbXB0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcCArPSAnPScgKyBvcGVyYXRvci5lbmNvZGUobmFtZVZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0SGVscGVyLmpvaW4oYXJyLCBvcGVyYXRvci5zZXBhcmF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGV4cGFuZEV4cGxvZGVkVW5uYW1lZCAob3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGFyciA9IFtdLFxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyLmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGFyciA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgaXNEZWZpbmVkKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIG9wZXJhdG9yLmVuY29kZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBvYmplY3RIZWxwZXIuam9pbihhcnIsIG9wZXJhdG9yLnNlcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcnIgPSBwcm9wZXJ0eUFycmF5KHZhbHVlKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLmZpbHRlcihhcnIsIGZ1bmN0aW9uIChuYW1lVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWQobmFtZVZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5tYXAoYXJyLCBmdW5jdGlvbiAobmFtZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuZW5jb2RlKG5hbWVWYWx1ZS5uYW1lKSArICc9JyArIG9wZXJhdG9yLmVuY29kZShuYW1lVmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IG9iamVjdEhlbHBlci5qb2luKGFyciwgb3BlcmF0b3Iuc2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgVmFyaWFibGVFeHByZXNzaW9uLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGV4cGFuZGVkID0gW10sXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICB2YXJzcGVjLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgdmFsdWVJc0FycixcclxuICAgICAgICAgICAgb25lRXhwbG9kZWQgPSBmYWxzZSxcclxuICAgICAgICAgICAgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xyXG5cclxuICAgICAgICAvLyBleHBhbmQgZWFjaCB2YXJzcGVjIGFuZCBqb2luIHdpdGggb3BlcmF0b3IncyBzZXBhcmF0b3JcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnZhcnNwZWNzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICB2YXJzcGVjID0gdGhpcy52YXJzcGVjc1tpbmRleF07XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFyaWFibGVzW3ZhcnNwZWMudmFybmFtZV07XHJcbiAgICAgICAgICAgIC8vIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAvLyBpZiAodmFyaWFibGVzLmhhc093blByb3BlcnR5KHZhcnNwZWMubmFtZSkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YXJzcGVjLmV4cGxvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvbmVFeHBsb2RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWVJc0FyciA9IG9iamVjdEhlbHBlci5pc0FycmF5KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChleHBhbmRTaW1wbGVWYWx1ZSh2YXJzcGVjLCBvcGVyYXRvciwgdmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YXJzcGVjLm1heExlbmd0aCAmJiBpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAyLjQuMSBvZiB0aGUgc3BlYyBzYXlzOiBcIlByZWZpeCBtb2RpZmllcnMgYXJlIG5vdCBhcHBsaWNhYmxlIHRvIHZhcmlhYmxlcyB0aGF0IGhhdmUgY29tcG9zaXRlIHZhbHVlcy5cIlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmVmaXggbW9kaWZpZXJzIGFyZSBub3QgYXBwbGljYWJsZSB0byB2YXJpYWJsZXMgdGhhdCBoYXZlIGNvbXBvc2l0ZSB2YWx1ZXMuIFlvdSB0cmllZCB0byBleHBhbmQgJyArIHRoaXMgKyBcIiB3aXRoIFwiICsgcHJldHR5UHJpbnQodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdmFyc3BlYy5leHBsb2RlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLm5hbWVkIHx8ICFpc0VtcHR5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkLnB1c2goZXhwYW5kTm90RXhwbG9kZWQodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLm5hbWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChleHBhbmRFeHBsb2RlZE5hbWVkKHZhcnNwZWMsIG9wZXJhdG9yLCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChleHBhbmRFeHBsb2RlZFVubmFtZWQob3BlcmF0b3IsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleHBhbmRlZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuZmlyc3QgKyBvYmplY3RIZWxwZXIuam9pbihleHBhbmRlZCwgb3BlcmF0b3Iuc2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBWYXJpYWJsZUV4cHJlc3Npb247XHJcbn0oKSk7XHJcblxyXG52YXIgVXJpVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVXJpVGVtcGxhdGUgKHRlbXBsYXRlVGV4dCwgZXhwcmVzc2lvbnMpIHtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlVGV4dCA9IHRlbXBsYXRlVGV4dDtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcbiAgICAgICAgb2JqZWN0SGVscGVyLmRlZXBGcmVlemUodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgVXJpVGVtcGxhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlVGV4dDtcclxuICAgIH07XHJcblxyXG4gICAgVXJpVGVtcGxhdGUucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcclxuICAgICAgICAvLyB0aGlzLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcmVzc2lvbikge3JldHVybiBleHByZXNzaW9uLmV4cGFuZCh2YXJpYWJsZXMpO30pLmpvaW4oJycpO1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5leHByZXNzaW9ucy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwcmVzc2lvbnNbaW5kZXhdLmV4cGFuZCh2YXJpYWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBVcmlUZW1wbGF0ZS5wYXJzZSA9IHBhcnNlO1xyXG4gICAgVXJpVGVtcGxhdGUuVXJpVGVtcGxhdGVFcnJvciA9IFVyaVRlbXBsYXRlRXJyb3I7XHJcbiAgICByZXR1cm4gVXJpVGVtcGxhdGU7XHJcbn0oKSk7XHJcblxyXG4gICAgZXhwb3J0Q2FsbGJhY2soVXJpVGVtcGxhdGUpO1xyXG5cclxufShmdW5jdGlvbiAoVXJpVGVtcGxhdGUpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgICAgICAvLyBleHBvcnQgVXJpVGVtcGxhdGUsIHdoZW4gbW9kdWxlIGlzIHByZXNlbnQsIG9yIHBhc3MgaXQgdG8gd2luZG93IG9yIGdsb2JhbFxyXG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gVXJpVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBkZWZpbmUoW10sZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXJpVGVtcGxhdGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5VcmlUZW1wbGF0ZSA9IFVyaVRlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2xvYmFsLlVyaVRlbXBsYXRlID0gVXJpVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pKTtcclxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xuLyoqXG4gKiBXcmFwcGVyIGZvciBidWlsdC1pbiBodHRwLmpzIHRvIGVtdWxhdGUgdGhlIGJyb3dzZXIgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2l0aCBKUyBkZXNpZ25lZCBmb3IgYnJvd3NlcnMgdG8gaW1wcm92ZSByZXVzZSBvZiBjb2RlIGFuZFxuICogYWxsb3cgdGhlIHVzZSBvZiBleGlzdGluZyBsaWJyYXJpZXMuXG4gKlxuICogVXNhZ2U6IGluY2x1ZGUoXCJYTUxIdHRwUmVxdWVzdC5qc1wiKSBhbmQgdXNlIFhNTEh0dHBSZXF1ZXN0IHBlciBXM0Mgc3BlY3MuXG4gKlxuICogQGF1dGhvciBEYW4gRGVGZWxpcHBpIDxkYW5AZHJpdmVyZGFuLmNvbT5cbiAqIEBjb250cmlidXRvciBEYXZpZCBFbGxpcyA8ZC5mLmVsbGlzQGllZWUub3JnPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxudmFyIFVybCA9IHJlcXVpcmUoXCJ1cmxcIilcbiAgLCBzcGF3biA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpLnNwYXduXG4gICwgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBQcml2YXRlIHZhcmlhYmxlc1xuICAgKi9cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbiAgdmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcblxuICAvLyBIb2xkcyBodHRwLmpzIG9iamVjdHNcbiAgdmFyIHJlcXVlc3Q7XG4gIHZhciByZXNwb25zZTtcblxuICAvLyBSZXF1ZXN0IHNldHRpbmdzXG4gIHZhciBzZXR0aW5ncyA9IHt9O1xuXG4gIC8vIERpc2FibGUgaGVhZGVyIGJsYWNrbGlzdC5cbiAgLy8gTm90IHBhcnQgb2YgWEhSIHNwZWNzLlxuICB2YXIgZGlzYWJsZUhlYWRlckNoZWNrID0gZmFsc2U7XG5cbiAgLy8gU2V0IHNvbWUgZGVmYXVsdCBoZWFkZXJzXG4gIHZhciBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBcIlVzZXItQWdlbnRcIjogXCJub2RlLVhNTEh0dHBSZXF1ZXN0XCIsXG4gICAgXCJBY2NlcHRcIjogXCIqLypcIixcbiAgfTtcblxuICB2YXIgaGVhZGVycyA9IGRlZmF1bHRIZWFkZXJzO1xuXG4gIC8vIFRoZXNlIGhlYWRlcnMgYXJlIG5vdCB1c2VyIHNldGFibGUuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbG93ZWQgYnV0IGJhbm5lZCBpbiB0aGUgc3BlYzpcbiAgLy8gKiB1c2VyLWFnZW50XG4gIHZhciBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInZpYVwiXG4gIF07XG5cbiAgLy8gVGhlc2UgcmVxdWVzdCBtZXRob2RzIGFyZSBub3QgYWxsb3dlZFxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMgPSBbXG4gICAgXCJUUkFDRVwiLFxuICAgIFwiVFJBQ0tcIixcbiAgICBcIkNPTk5FQ1RcIlxuICBdO1xuXG4gIC8vIFNlbmQgZmxhZ1xuICB2YXIgc2VuZEZsYWcgPSBmYWxzZTtcbiAgLy8gRXJyb3IgZmxhZywgdXNlZCB3aGVuIGVycm9ycyBvY2N1ciBvciBhYm9ydCBpcyBjYWxsZWRcbiAgdmFyIGVycm9yRmxhZyA9IGZhbHNlO1xuXG4gIC8vIEV2ZW50IGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0ge307XG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICB0aGlzLlVOU0VOVCA9IDA7XG4gIHRoaXMuT1BFTkVEID0gMTtcbiAgdGhpcy5IRUFERVJTX1JFQ0VJVkVEID0gMjtcbiAgdGhpcy5MT0FESU5HID0gMztcbiAgdGhpcy5ET05FID0gNDtcblxuICAvKipcbiAgICogUHVibGljIHZhcnNcbiAgICovXG5cbiAgLy8gQ3VycmVudCBzdGF0ZVxuICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLlVOU0VOVDtcblxuICAvLyBkZWZhdWx0IHJlYWR5IHN0YXRlIGNoYW5nZSBoYW5kbGVyIGluIGNhc2Ugb25lIGlzIG5vdCBzZXQgb3IgaXMgc2V0IGxhdGVcbiAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG4gIC8vIFJlc3VsdCAmIHJlc3BvbnNlXG4gIHRoaXMucmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XG4gIHRoaXMuc3RhdHVzID0gbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gbnVsbDtcblxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIGhlYWRlciBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBIZWFkZXIgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybiBib29sZWFuIEZhbHNlIGlmIG5vdCBhbGxvd2VkLCBvdGhlcndpc2UgdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQWxsb3dlZEh0dHBIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICByZXR1cm4gZGlzYWJsZUhlYWRlckNoZWNrIHx8IChoZWFkZXIgJiYgZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNwZWNpZmllZCBtZXRob2QgaXMgYWxsb3dlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBtZXRob2QgUmVxdWVzdCBtZXRob2QgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybiBib29sZWFuIEZhbHNlIGlmIG5vdCBhbGxvd2VkLCBvdGhlcndpc2UgdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQWxsb3dlZEh0dHBNZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICByZXR1cm4gKG1ldGhvZCAmJiBmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcy5pbmRleE9mKG1ldGhvZCkgPT09IC0xKTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZHNcbiAgICovXG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIGNvbm5lY3Rpb24uIEN1cnJlbnRseSBzdXBwb3J0cyBsb2NhbCBzZXJ2ZXIgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgbWV0aG9kIENvbm5lY3Rpb24gbWV0aG9kIChlZyBHRVQsIFBPU1QpXG4gICAqIEBwYXJhbSBzdHJpbmcgdXJsIFVSTCBmb3IgdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSBib29sZWFuIGFzeW5jIEFzeW5jaHJvbm91cyBjb25uZWN0aW9uLiBEZWZhdWx0IGlzIHRydWUuXG4gICAqIEBwYXJhbSBzdHJpbmcgdXNlciBVc2VybmFtZSBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gc3RyaW5nIHBhc3N3b3JkIFBhc3N3b3JkIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvbiAob3B0aW9uYWwpXG4gICAqL1xuICB0aGlzLm9wZW4gPSBmdW5jdGlvbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGVycm9yRmxhZyA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHZhbGlkIHJlcXVlc3QgbWV0aG9kXG4gICAgaWYgKCFpc0FsbG93ZWRIdHRwTWV0aG9kKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IFwiU2VjdXJpdHlFcnJvcjogUmVxdWVzdCBtZXRob2Qgbm90IGFsbG93ZWRcIjtcbiAgICB9XG5cbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgIFwidXJsXCI6IHVybC50b1N0cmluZygpLFxuICAgICAgXCJhc3luY1wiOiAodHlwZW9mIGFzeW5jICE9PSBcImJvb2xlYW5cIiA/IHRydWUgOiBhc3luYyksXG4gICAgICBcInVzZXJcIjogdXNlciB8fCBudWxsLFxuICAgICAgXCJwYXNzd29yZFwiOiBwYXNzd29yZCB8fCBudWxsXG4gICAgfTtcblxuICAgIHNldFN0YXRlKHRoaXMuT1BFTkVEKTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZXMgb3IgZW5hYmxlcyBpc0FsbG93ZWRIdHRwSGVhZGVyKCkgY2hlY2sgdGhlIHJlcXVlc3QuIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogVGhpcyBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBXM0Mgc3BlYy5cbiAgICpcbiAgICogQHBhcmFtIGJvb2xlYW4gc3RhdGUgRW5hYmxlIG9yIGRpc2FibGUgaGVhZGVyIGNoZWNraW5nLlxuICAgKi9cbiAgdGhpcy5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGRpc2FibGVIZWFkZXJDaGVjayA9IHN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIG5hbWVcbiAgICogQHBhcmFtIHN0cmluZyB2YWx1ZSBIZWFkZXIgdmFsdWVcbiAgICovXG4gIHRoaXMuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlciwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IHRoaXMuT1BFTkVEKSB7XG4gICAgICB0aHJvdyBcIklOVkFMSURfU1RBVEVfRVJSOiBzZXRSZXF1ZXN0SGVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHN0YXRlIGlzIE9QRU5cIjtcbiAgICB9XG4gICAgaWYgKCFpc0FsbG93ZWRIdHRwSGVhZGVyKGhlYWRlcikpIHtcbiAgICAgIGNvbnNvbGUud2FybignUmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBcIicgKyBoZWFkZXIgKyAnXCInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICB0aHJvdyBcIklOVkFMSURfU1RBVEVfRVJSOiBzZW5kIGZsYWcgaXMgdHJ1ZVwiO1xuICAgIH1cbiAgICBoZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIE5hbWUgb2YgaGVhZGVyIHRvIGdldC5cbiAgICogQHJldHVybiBzdHJpbmcgVGV4dCBvZiB0aGUgaGVhZGVyIG9yIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHRoaXMuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICBpZiAodHlwZW9mIGhlYWRlciA9PT0gXCJzdHJpbmdcIlxuICAgICAgJiYgdGhpcy5yZWFkeVN0YXRlID4gdGhpcy5PUEVORURcbiAgICAgICYmIHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldXG4gICAgICAmJiAhZXJyb3JGbGFnXG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHN0cmluZyBBIHN0cmluZyB3aXRoIGFsbCByZXNwb25zZSBoZWFkZXJzIHNlcGFyYXRlZCBieSBDUitMRlxuICAgKi9cbiAgdGhpcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgdGhpcy5IRUFERVJTX1JFQ0VJVkVEIHx8IGVycm9yRmxhZykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAvLyBDb29raWUgaGVhZGVycyBhcmUgZXhjbHVkZWRcbiAgICAgIGlmIChpICE9PSBcInNldC1jb29raWVcIiAmJiBpICE9PSBcInNldC1jb29raWUyXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGkgKyBcIjogXCIgKyByZXNwb25zZS5oZWFkZXJzW2ldICsgXCJcXHJcXG5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJzdHIoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVxdWVzdCBoZWFkZXJcbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBuYW1lIE5hbWUgb2YgaGVhZGVyIHRvIGdldFxuICAgKiBAcmV0dXJuIHN0cmluZyBSZXR1cm5zIHRoZSByZXF1ZXN0IGhlYWRlciBvciBlbXB0eSBzdHJpbmcgaWYgbm90IHNldFxuICAgKi9cbiAgdGhpcy5nZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIC8vIEBUT0RPIE1ha2UgdGhpcyBjYXNlIGluc2Vuc2l0aXZlXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIGhlYWRlcnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBoZWFkZXJzW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGRhdGEgT3B0aW9uYWwgZGF0YSB0byBzZW5kIGFzIHJlcXVlc3QgYm9keS5cbiAgICovXG4gIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IHRoaXMuT1BFTkVEKSB7XG4gICAgICB0aHJvdyBcIklOVkFMSURfU1RBVEVfRVJSOiBjb25uZWN0aW9uIG11c3QgYmUgb3BlbmVkIGJlZm9yZSBzZW5kKCkgaXMgY2FsbGVkXCI7XG4gICAgfVxuXG4gICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICB0aHJvdyBcIklOVkFMSURfU1RBVEVfRVJSOiBzZW5kIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXCI7XG4gICAgfVxuXG4gICAgdmFyIHNzbCA9IGZhbHNlLCBsb2NhbCA9IGZhbHNlO1xuICAgIHZhciB1cmwgPSBVcmwucGFyc2Uoc2V0dGluZ3MudXJsKTtcbiAgICB2YXIgaG9zdDtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNlcnZlclxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdodHRwczonOlxuICAgICAgICBzc2wgPSB0cnVlO1xuICAgICAgICAvLyBTU0wgJiBub24tU1NMIGJvdGggbmVlZCBob3N0LCBubyBicmVhayBoZXJlLlxuICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgICBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZmlsZTonOlxuICAgICAgICBsb2NhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGNhc2UgJyc6XG4gICAgICAgIGhvc3QgPSBcImxvY2FsaG9zdFwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgXCJQcm90b2NvbCBub3Qgc3VwcG9ydGVkLlwiO1xuICAgIH1cblxuICAgIC8vIExvYWQgZmlsZXMgb2ZmIHRoZSBsb2NhbCBmaWxlc3lzdGVtIChmaWxlOi8vKVxuICAgIGlmIChsb2NhbCkge1xuICAgICAgaWYgKHNldHRpbmdzLm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgICB0aHJvdyBcIlhNTEh0dHBSZXF1ZXN0OiBPbmx5IEdFVCBtZXRob2QgaXMgc3VwcG9ydGVkXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xuICAgICAgICBmcy5yZWFkRmlsZSh1cmwucGF0aG5hbWUsICd1dGY4JywgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gZGF0YTtcbiAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBmcy5yZWFkRmlsZVN5bmModXJsLnBhdGhuYW1lLCAndXRmOCcpO1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gMjAwO1xuICAgICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gcG9ydCA4MC4gSWYgYWNjZXNzaW5nIGxvY2FsaG9zdCBvbiBhbm90aGVyIHBvcnQgYmUgc3VyZVxuICAgIC8vIHRvIHVzZSBodHRwOi8vbG9jYWxob3N0OnBvcnQvcGF0aFxuICAgIHZhciBwb3J0ID0gdXJsLnBvcnQgfHwgKHNzbCA/IDQ0MyA6IDgwKTtcbiAgICAvLyBBZGQgcXVlcnkgc3RyaW5nIGlmIG9uZSBpcyB1c2VkXG4gICAgdmFyIHVyaSA9IHVybC5wYXRobmFtZSArICh1cmwuc2VhcmNoID8gdXJsLnNlYXJjaCA6ICcnKTtcblxuICAgIC8vIFNldCB0aGUgSG9zdCBoZWFkZXIgb3IgdGhlIHNlcnZlciBtYXkgcmVqZWN0IHRoZSByZXF1ZXN0XG4gICAgaGVhZGVyc1tcIkhvc3RcIl0gPSBob3N0O1xuICAgIGlmICghKChzc2wgJiYgcG9ydCA9PT0gNDQzKSB8fCBwb3J0ID09PSA4MCkpIHtcbiAgICAgIGhlYWRlcnNbXCJIb3N0XCJdICs9ICc6JyArIHVybC5wb3J0O1xuICAgIH1cblxuICAgIC8vIFNldCBCYXNpYyBBdXRoIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChzZXR0aW5ncy51c2VyKSB7XG4gICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnBhc3N3b3JkID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2V0dGluZ3MucGFzc3dvcmQgPSBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIGF1dGhCdWYgPSBuZXcgQnVmZmVyKHNldHRpbmdzLnVzZXIgKyBcIjpcIiArIHNldHRpbmdzLnBhc3N3b3JkKTtcbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCYXNpYyBcIiArIGF1dGhCdWYudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbnRlbnQgbGVuZ3RoIGhlYWRlclxuICAgIGlmIChzZXR0aW5ncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgc2V0dGluZ3MubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgPyBkYXRhLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAoIWhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pIHtcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAvLyBGb3IgYSBwb3N0IHdpdGggbm8gZGF0YSBzZXQgQ29udGVudC1MZW5ndGg6IDAuXG4gICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGJ5IGJ1Z2d5IHNlcnZlcnMgdGhhdCBkb24ndCBtZWV0IHRoZSBzcGVjcy5cbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBob3N0OiBob3N0LFxuICAgICAgcG9ydDogcG9ydCxcbiAgICAgIHBhdGg6IHVyaSxcbiAgICAgIG1ldGhvZDogc2V0dGluZ3MubWV0aG9kLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGFnZW50OiBmYWxzZVxuICAgIH07XG5cbiAgICAvLyBSZXNldCBlcnJvciBmbGFnXG4gICAgZXJyb3JGbGFnID0gZmFsc2U7XG5cbiAgICAvLyBIYW5kbGUgYXN5bmMgcmVxdWVzdHNcbiAgICBpZiAoc2V0dGluZ3MuYXN5bmMpIHtcbiAgICAgIC8vIFVzZSB0aGUgcHJvcGVyIHByb3RvY29sXG4gICAgICB2YXIgZG9SZXF1ZXN0ID0gc3NsID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcblxuICAgICAgLy8gUmVxdWVzdCBpcyBiZWluZyBzZW50LCBzZXQgc2VuZCBmbGFnXG4gICAgICBzZW5kRmxhZyA9IHRydWU7XG5cbiAgICAgIC8vIEFzIHBlciBzcGVjLCB0aGlzIGlzIGNhbGxlZCBoZXJlIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpO1xuXG4gICAgICAvLyBIYW5kbGVyIGZvciB0aGUgcmVzcG9uc2VcbiAgICAgIGZ1bmN0aW9uIHJlc3BvbnNlSGFuZGxlcihyZXNwKSB7XG4gICAgICAgIC8vIFNldCByZXNwb25zZSB2YXIgdG8gdGhlIHJlc3BvbnNlIHdlIGdvdCBiYWNrXG4gICAgICAgIC8vIFRoaXMgaXMgc28gaXQgcmVtYWlucyBhY2Nlc3NhYmxlIG91dHNpZGUgdGhpcyBzY29wZVxuICAgICAgICByZXNwb25zZSA9IHJlc3A7XG4gICAgICAgIC8vIENoZWNrIGZvciByZWRpcmVjdFxuICAgICAgICAvLyBAVE9ETyBQcmV2ZW50IGxvb3BlZCByZWRpcmVjdHNcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzA3KSB7XG4gICAgICAgICAgLy8gQ2hhbmdlIFVSTCB0byB0aGUgcmVkaXJlY3QgbG9jYXRpb25cbiAgICAgICAgICBzZXR0aW5ncy51cmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICAgIHZhciB1cmwgPSBVcmwucGFyc2Uoc2V0dGluZ3MudXJsKTtcbiAgICAgICAgICAvLyBTZXQgaG9zdCB2YXIgaW4gY2FzZSBpdCdzIHVzZWQgbGF0ZXJcbiAgICAgICAgICBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICAgIC8vIE9wdGlvbnMgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgICAgICAgIHZhciBuZXdPcHRpb25zID0ge1xuICAgICAgICAgICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHVybC5wb3J0LFxuICAgICAgICAgICAgcGF0aDogdXJsLnBhdGgsXG4gICAgICAgICAgICBtZXRob2Q6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMyA/ICdHRVQnIDogc2V0dGluZ3MubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBJc3N1ZSB0aGUgbmV3IHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0ID0gZG9SZXF1ZXN0KG5ld09wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICAgIC8vIEBUT0RPIENoZWNrIGlmIGFuIFhIUiBldmVudCBuZWVkcyB0byBiZSBmaXJlZCBoZXJlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuXG4gICAgICAgIHNldFN0YXRlKHNlbGYuSEVBREVSU19SRUNFSVZFRCk7XG4gICAgICAgIHNlbGYuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcblxuICAgICAgICByZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlJ3Mgc29tZSBkYXRhXG4gICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCArPSBjaHVuaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRG9uJ3QgZW1pdCBzdGF0ZSBjaGFuZ2VzIGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICAgICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkxPQURJTkcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZFxuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgICAgIHNlbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRXJyb3IgaGFuZGxlciBmb3IgdGhlIHJlcXVlc3RcbiAgICAgIGZ1bmN0aW9uIGVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHRoZSByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gZG9SZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcblxuICAgICAgLy8gTm9kZSAwLjQgYW5kIGxhdGVyIHdvbid0IGFjY2VwdCBlbXB0eSBkYXRhLiBNYWtlIHN1cmUgaXQncyBuZWVkZWQuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXF1ZXN0LndyaXRlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmVuZCgpO1xuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG4gICAgfSBlbHNlIHsgLy8gU3luY2hyb25vdXNcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIG90aGVyIE5vZGUgcHJvY2Vzc1xuICAgICAgdmFyIGNvbnRlbnRGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1jb250ZW50LVwiICsgcHJvY2Vzcy5waWQ7XG4gICAgICB2YXIgc3luY0ZpbGUgPSBcIi5ub2RlLXhtbGh0dHByZXF1ZXN0LXN5bmMtXCIgKyBwcm9jZXNzLnBpZDtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoc3luY0ZpbGUsIFwiXCIsIFwidXRmOFwiKTtcbiAgICAgIC8vIFRoZSBhc3luYyByZXF1ZXN0IHRoZSBvdGhlciBOb2RlIHByb2Nlc3MgZXhlY3V0ZXNcbiAgICAgIHZhciBleGVjU3RyaW5nID0gXCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKSwgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XCJcbiAgICAgICAgKyBcInZhciBkb1JlcXVlc3QgPSBodHRwXCIgKyAoc3NsID8gXCJzXCIgOiBcIlwiKSArIFwiLnJlcXVlc3Q7XCJcbiAgICAgICAgKyBcInZhciBvcHRpb25zID0gXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSArIFwiO1wiXG4gICAgICAgICsgXCJ2YXIgcmVzcG9uc2VUZXh0ID0gJyc7XCJcbiAgICAgICAgKyBcInZhciByZXEgPSBkb1JlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcIlxuICAgICAgICArIFwicmVzcG9uc2Uuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcIlxuICAgICAgICArIFwicmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1wiXG4gICAgICAgICsgXCIgIHJlc3BvbnNlVGV4dCArPSBjaHVuaztcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOicgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgJywnICsgcmVzcG9uc2VUZXh0LCAndXRmOCcpO1wiXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOicgKyBKU09OLnN0cmluZ2lmeShlcnJvciksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIFwifSkub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcIlxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtRVJST1I6JyArIEpTT04uc3RyaW5naWZ5KGVycm9yKSwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgKGRhdGEgPyBcInJlcS53cml0ZSgnXCIgKyBkYXRhLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKSArIFwiJyk7XCI6XCJcIilcbiAgICAgICAgKyBcInJlcS5lbmQoKTtcIjtcbiAgICAgIC8vIFN0YXJ0IHRoZSBvdGhlciBOb2RlIFByb2Nlc3MsIGV4ZWN1dGluZyB0aGlzIHN0cmluZ1xuICAgICAgdmFyIHN5bmNQcm9jID0gc3Bhd24ocHJvY2Vzcy5hcmd2WzBdLCBbXCItZVwiLCBleGVjU3RyaW5nXSk7XG4gICAgICB2YXIgc3RhdHVzVGV4dDtcbiAgICAgIHdoaWxlKGZzLmV4aXN0c1N5bmMoc3luY0ZpbGUpKSB7XG4gICAgICAgIC8vIFdhaXQgd2hpbGUgdGhlIHN5bmMgZmlsZSBpcyBlbXB0eVxuICAgICAgfVxuICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBmcy5yZWFkRmlsZVN5bmMoY29udGVudEZpbGUsICd1dGY4Jyk7XG4gICAgICAvLyBLaWxsIHRoZSBjaGlsZCBwcm9jZXNzIG9uY2UgdGhlIGZpbGUgaGFzIGRhdGFcbiAgICAgIHN5bmNQcm9jLnN0ZGluLmVuZCgpO1xuICAgICAgLy8gUmVtb3ZlIHRoZSB0ZW1wb3JhcnkgZmlsZVxuICAgICAgZnMudW5saW5rU3luYyhjb250ZW50RmlsZSk7XG4gICAgICBpZiAoc2VsZi5yZXNwb25zZVRleHQubWF0Y2goL15OT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOi8pKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlIHJldHVybmVkIGFuIGVycm9yLCBoYW5kbGUgaXRcbiAgICAgICAgdmFyIGVycm9yT2JqID0gc2VsZi5yZXNwb25zZVRleHQucmVwbGFjZSgvXk5PREUtWE1MSFRUUFJFUVVFU1QtRVJST1I6LywgXCJcIik7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoZXJyb3JPYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgcmV0dXJuZWQgb2theSwgcGFyc2UgaXRzIGRhdGEgYW5kIG1vdmUgdG8gdGhlIERPTkUgc3RhdGVcbiAgICAgICAgc2VsZi5zdGF0dXMgPSBzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1TVEFUVVM6KFswLTldKiksLiovLCBcIiQxXCIpO1xuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IHNlbGYucmVzcG9uc2VUZXh0LnJlcGxhY2UoL15OT0RFLVhNTEhUVFBSRVFVRVNULVNUQVRVUzpbMC05XSosKC4qKS8sIFwiJDFcIik7XG4gICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB0byBkZWFsIHdpdGggaXQuXG4gICAqL1xuICB0aGlzLmhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB0aGlzLnN0YXR1cyA9IDUwMztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBlcnJvcjtcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGVycm9yLnN0YWNrO1xuICAgIGVycm9yRmxhZyA9IHRydWU7XG4gICAgc2V0U3RhdGUodGhpcy5ET05FKTtcbiAgfTtcblxuICAvKipcbiAgICogQWJvcnRzIGEgcmVxdWVzdC5cbiAgICovXG4gIHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaGVhZGVycyA9IGRlZmF1bHRIZWFkZXJzO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgICB0aGlzLnJlc3BvbnNlWE1MID0gXCJcIjtcblxuICAgIGVycm9yRmxhZyA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLlVOU0VOVFxuICAgICAgICAmJiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCB8fCBzZW5kRmxhZylcbiAgICAgICAgJiYgdGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLkRPTkUpIHtcbiAgICAgIHNlbmRGbGFnID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLlVOU0VOVDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lci4gUHJlZmVycmVkIG1ldGhvZCBvZiBiaW5kaW5nIHRvIGV2ZW50cy5cbiAgICovXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGV2ZW50IGluIGxpc3RlbmVycykpIHtcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICB9XG4gICAgLy8gQ3VycmVudGx5IGFsbG93cyBkdXBsaWNhdGUgY2FsbGJhY2tzLiBTaG91bGQgaXQ/XG4gICAgbGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGNhbGxiYWNrIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZC5cbiAgICogT25seSB3b3JrcyBvbiB0aGUgbWF0Y2hpbmcgZnVuY2l0b24sIGNhbm5vdCBiZSBhIGNvcHkuXG4gICAqL1xuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAvLyBGaWx0ZXIgd2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCB0aGUgY2FsbGJhY2sgcmVtb3ZlZFxuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyc1tldmVudF0uZmlsdGVyKGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHJldHVybiBldiAhPT0gY2FsbGJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGFueSBldmVudHMsIGluY2x1ZGluZyBib3RoIFwib25cIiBtZXRob2RzIGFuZCBldmVudHMgYXR0YWNoZWQgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lci5cbiAgICovXG4gIHRoaXMuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmW1wib25cIiArIGV2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzZWxmW1wib25cIiArIGV2ZW50XSgpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdW2ldLmNhbGwoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHJlYWR5U3RhdGUgYW5kIGNhbGxzIG9ucmVhZHlzdGF0ZWNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIGludCBzdGF0ZSBOZXcgc3RhdGVcbiAgICovXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHNlbGYucmVhZHlTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IHN0YXRlO1xuXG4gICAgICBpZiAoc2V0dGluZ3MuYXN5bmMgfHwgc2VsZi5yZWFkeVN0YXRlIDwgc2VsZi5PUEVORUQgfHwgc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FICYmICFlcnJvckZsYWcpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZFwiKTtcbiAgICAgICAgLy8gQFRPRE8gZmlndXJlIG91dCBJbnNwZWN0b3JJbnN0cnVtZW50YXRpb246OmRpZExvYWRYSFIoY29va2llKVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2FkZW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2FhbmFuZC9JZGVhUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIvKipcbiAqIEFjY2VwdHMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHJlcHJlc2VudCBhIHJlZmVyZW5jZSB0byBhIHZhbHVlIG9uIGFuXG4gKiBvYmplY3QuIFN1cHBvcnRzIHBhc3NpbmcgYW4gb3B0aW9uYWwgc2V0dGVyLCB0byBzZXQgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAgeyp9ICAgICAgW3NldHRlcl1cbiAqIEByZXR1cm4geyp9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgcGF0aCwgc2V0dGVyKSB7XG4gIHZhciBpc1NldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcGF0aFtpXTtcblxuICAgIGlmIChpc1NldHRlcikge1xuICAgICAgaWYgKGkgPT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICBvYmplY3RbcHJvcF0gPSBzZXR0ZXI7XG4gICAgICB9IGVsc2UgaWYgKCEocHJvcCBpbiBvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iamVjdCA9IG9iamVjdFtwcm9wXTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgdXBkYXRlZCBvYmplY3QgcmVmZXJlbmNlLlxuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfICAgICAgICA9IEFwcC5MaWJyYXJ5Ll87XG52YXIgYXN5bmMgICAgPSBBcHAuTGlicmFyeS5hc3luYztcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vY2xpZW50LWdlbmVyYXRvci90ZW1wbGF0ZScpO1xuXG4vKipcbiAqIE1hcCBhdXRoZW50aWNhdGlvbiB0eXBlcyB0byBhdXRvbWF0aWMgcHJlZmVyZW5jZS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciBPUkRFUl9QUkVGRVJFTkNFID0gWydPQXV0aCAyLjAnLCAnT0F1dGggMS4wJywgJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJ107XG5cbi8qKlxuICogUmVxdWlyZWQgYXV0aGVudGljYXRpb24ga2V5cyB1c2VkIHRvIGNoZWNrIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgREVGQVVMVF9SRVFVSVJFRF9GSUVMRFMgPSB7XG4gICdPQXV0aCAxLjAnOiB7XG4gICAgY29uc3VtZXJLZXk6ICAgIHRydWUsXG4gICAgY29uc3VtZXJTZWNyZXQ6IHRydWVcbiAgfSxcbiAgJ09BdXRoIDIuMCc6IHtcbiAgICBjbGllbnRJZDogICAgIHRydWUsXG4gICAgY2xpZW50U2VjcmV0OiB0cnVlXG4gIH0sXG4gICdCYXNpYyBBdXRoZW50aWNhdGlvbic6IHtcbiAgICB1c2VybmFtZTogdHJ1ZSxcbiAgICBwYXNzd29yZDogdHJ1ZVxuICB9XG59O1xuXG4vKipcbiAqIFBvc3NpYmxlIHRva2VucyB0byBiZSBmaWxsZWQgb3V0IGJ5IHRoZSB1c2VyLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBERUZBVUxUX1BPU1NJQkxFX0ZJRUxEUyA9IHtcbiAgJ09BdXRoIDEuMCc6ICAgICAgICAgICAgWydjb25zdW1lcktleScsICdjb25zdW1lclNlY3JldCddLFxuICAnT0F1dGggMi4wJzogICAgICAgICAgICBbJ2NsaWVudElkJywgJ2NsaWVudFNlY3JldCcsICdzY29wZXMnXSxcbiAgJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJzogWyd1c2VybmFtZScsICdwYXNzd29yZCddXG59O1xuXG4vKipcbiAqIERlZmF1bHQgYXV0aGVudGljYXRpb24gcHJvbXB0IHRpdGxlcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgREVGQVVMVF9QUk9NUFRfVElUTEVTID0ge1xuICAnT0F1dGggMS4wJzogICAgICAgICAgICAnUGxlYXNlIEVudGVyIFlvdXIgT0F1dGggMS4wIEtleXMnLFxuICAnT0F1dGggMi4wJzogICAgICAgICAgICAnUGxlYXNlIEVudGVyIFlvdXIgT0F1dGggMi4wIEtleXMnLFxuICAnQmFzaWMgQXV0aGVudGljYXRpb24nOiAnUGxlYXNlIEVudGVyIFlvdXIgVXNlcm5hbWUgYW5kIFBhc3N3b3JkJ1xufTtcblxuLyoqXG4gKiBNYXAgb2Ygb2JqZWN0IGtleXMgdG8gdGhlaXIgcmVhZGFibGUgbmFtZXMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIERFRkFVTFRfRklFTERfTkFNRVMgPSB7XG4gIGNvbnN1bWVyS2V5OiAgICAnQ29uc3VtZXIgS2V5JyxcbiAgY29uc3VtZXJTZWNyZXQ6ICdDb25zdW1lciBTZWNyZXQnLFxuICBjbGllbnRJZDogICAgICAgJ0NsaWVudCBJRCcsXG4gIGNsaWVudFNlY3JldDogICAnQ2xpZW50IFNlY3JldCcsXG4gIHNjb3BlczogICAgICAgICAnUGVybWlzc2lvbnMnLFxuICB1c2VybmFtZTogICAgICAgJ1VzZXJuYW1lJyxcbiAgcGFzc3dvcmQ6ICAgICAgICdQYXNzd29yZCdcbn07XG5cbi8qKlxuICogVGhlc2UgZmllbGRzIG11c3QgYmUgaGlkZGVuIGluIHRoZSBVSS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgU0VDUkVUX0ZJRUxEUyA9IHtcbiAgY2xpZW50U2VjcmV0OiB0cnVlLFxuICBjb25zdW1lclNlY3JldDogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWVcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXZhaWxhYmxlIGtleXMgYW5kIHdoZXRoZXIgdGhleSBhcmUgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIHJlcXVpcmVkVG9rZW5zID0gZnVuY3Rpb24gKHNjaGVtZSkge1xuICB2YXIga2V5cyA9IF8uZXh0ZW5kKHt9LCBERUZBVUxUX1JFUVVJUkVEX0ZJRUxEU1tzY2hlbWUudHlwZV0pO1xuXG4gIC8vIFNwZWNpYWwgY2FzZSBpcyByZXF1aXJlZCBmb3IgT0F1dGgyIGltcGxpY2l0IGF1dGggZmxvdy5cbiAgaWYgKHNjaGVtZS50eXBlID09PSAnT0F1dGggMi4wJykge1xuICAgIGtleXMuY2xpZW50U2VjcmV0ID0gIV8uY29udGFpbnMoXG4gICAgICBzY2hlbWUuc2V0dGluZ3MuYXV0aG9yaXphdGlvbkdyYW50cywgJ3Rva2VuJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qKlxuICogU2FuaXRpemUgc2NvcGVzIHRvIGJlIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSAgeyp9ICAgICBzY29wZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG52YXIgc2FuaXRpemVTY29wZSA9IGZ1bmN0aW9uIChzY29wZXMpIHtcbiAgaWYgKF8uaXNTdHJpbmcoc2NvcGVzKSkge1xuICAgIHJldHVybiBzY29wZXMuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzY29wZXMpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHNjb3Blcztcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHRva2VucyBvYmplY3QgYWdhaW5zdCB0aGUgcmVxdWlyZWQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIHNjaGVtZVxuICogQHBhcmFtICB7T2JqZWN0fSAgdG9rZW5zXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaGFzUmVxdWlyZWRUb2tlbnMgPSBmdW5jdGlvbiAoc2NoZW1lLCB0b2tlbnMpIHtcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSByZXF1aXJlZCB0b2tlbnMgYW5kIGNoZWNrIHRoYXQgdGhlIHRva2VuIGlzIGRlZmluZWQuXG4gIHJldHVybiBfLmV2ZXJ5KHJlcXVpcmVkVG9rZW5zKHNjaGVtZSksIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlID8gdG9rZW5zW2tleV0gOiB0cnVlO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvbXB0IHRoZSB1c2VyIGZvciBhdXRoZW50aWNhdGlvbiB0b2tlbnMgYmFzZWQgb24gYSBzY2hlbWUuIFdlIGNhbiBwYXNzIGluXG4gKiB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCB0byBoZWxwIGRlY2lkZSB3aGF0IGRhdGEgdG8gZGlzcGxheSB0byB0aGUgdXNlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBzY2hlbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xudmFyIHByb21wdFRva2VucyA9IGZ1bmN0aW9uIChzY2hlbWUsIG9wdGlvbnMsIGRvbmUpIHtcbiAgdmFyIGNhbmNlbGxlZCAgID0gdHJ1ZTtcbiAgdmFyIG5lZWRzVG9rZW5zID0gcmVxdWlyZWRUb2tlbnMoc2NoZW1lKTtcblxuICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiB0aGUgdG9rZW5zIHRvIHVzZSB3aXRoIG91ciBwcm9tcHQgYW5kIGZpbHRlclxuICAvLyBleHBsaWNpdGx5IG5vdCByZXF1aXJlZCB0b2tlbnMuXG4gIHZhciBwb3NzaWJsZVRva2VucyA9IF8uZmlsdGVyKFxuICAgIERFRkFVTFRfUE9TU0lCTEVfRklFTERTW3NjaGVtZS50eXBlXSxcbiAgICBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIHJldHVybiBuZWVkc1Rva2Vuc1t0b2tlbl0gIT09IGZhbHNlO1xuICAgIH1cbiAgKTtcblxuICAvLyBNdWx0aXBsZSB3YXlzIG9mIHNldHRpbmcgdGhlIHNjb3BlIG9wdGlvbi5cbiAgb3B0aW9ucy5zY29wZXMgPSBzYW5pdGl6ZVNjb3BlKG9wdGlvbnMuc2NvcGUgfHwgb3B0aW9ucy5zY29wZXMpO1xuICBkZWxldGUgb3B0aW9ucy5zY29wZTtcblxuICAvLyBHZW5lcmF0ZSB0aGUgZm9ybSB0byBwcm9tcHQgdGhlIHVzZXIgd2l0aC5cbiAgdmFyIHByb21wdEZvcm0gPSBfLm1hcChwb3NzaWJsZVRva2VucywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdzY29wZXMnKSB7XG4gICAgICB2YXIgc2NvcGVzID0gc2FuaXRpemVTY29wZShzY2hlbWUuc2V0dGluZ3Muc2NvcGVzKTtcblxuICAgICAgLy8gSWdub3JlIHRoZSBzY29wZXMgc2VsZWN0aW9uIHdoZW4gbm90aGluZyBpcyBhdmFpbGFibGUgZm9yIHNlbGVjdGlvbi5cbiAgICAgIGlmICghc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCBzY29wZXMgdG8gY2hlY2tib3ggc2VsZWN0aW9ucy5cbiAgICAgIHZhciBzY29wZU9wdGlvbnMgPSBfLm1hcChzY29wZXMsIGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2NvcGUgaXMgYWxyZWFkeSBpbiB0aGUgc2VsZWN0ZWQgc2NvcGVzLiBJZiB0aGVyZSBpc1xuICAgICAgICAvLyBvbmx5IG9uZSBwb3NzaWJsZSBzY29wZSwganVzdCBzZWxlY3QgaXQgYnkgZGVmYXVsdCBhbnl3YXkuXG4gICAgICAgIHZhciBoYXNTY29wZSA9IF8uY29udGFpbnMob3B0aW9ucy5zY29wZXMsIHNjb3BlKSB8fCBzY29wZXMubGVuZ3RoID09PSAxO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJjaGVja2JveFwiPicsXG4gICAgICAgICAgJzxsYWJlbD4nLFxuICAgICAgICAgICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzY29wZXNcIiB2YWx1ZT1cIicgKyBzY29wZSArICdcIiAnICtcbiAgICAgICAgICAgIChoYXNTY29wZSA/ICdjaGVja2VkJyA6ICcnKSArICc+JyxcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAnPC9sYWJlbD4nLFxuICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9KS5qb2luKCdcXG4nKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyxcbiAgICAgICAgJzxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWxcIj4nICsgREVGQVVMVF9GSUVMRF9OQU1FU1trZXldICsgJzwvbGFiZWw+JyxcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWNvbnRlbnRcIj4nICsgc2NvcGVPcHRpb25zICsgJzwvZGl2PicsXG4gICAgICAgICc8L2Rpdj4nXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQgd2Ugc2hvdyB0aGUgdXNlciBhbiBpbnB1dCBmaWVsZCB0byBpbnB1dCB0aGVpciBrZXlzLlxuICAgIHJldHVybiBbXG4gICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nLFxuICAgICAgJzxsYWJlbCBmb3I9XCInICsga2V5ICsgJ1wiIGNsYXNzPVwiZm9ybS1sYWJlbFwiPicsXG4gICAgICBERUZBVUxUX0ZJRUxEX05BTUVTW2tleV0sXG4gICAgICAnPC9sYWJlbD4nLFxuICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWNvbnRlbnRcIj4nLFxuICAgICAgJzxpbnB1dCBpZD1cIicgKyBrZXkgKyAnXCIgdmFsdWU9XCInICsgKG9wdGlvbnNba2V5XSB8fCAnJykgKyAnXCInICtcbiAgICAgICAgKFNFQ1JFVF9GSUVMRFNba2V5XSA/ICcgdHlwZT1cInBhc3N3b3JkXCInIDogJycpICsgJz4nLFxuICAgICAgJzwvZGl2PicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0uam9pbignJyk7XG4gIH0pLmpvaW4oJ1xcbicpO1xuXG4gIHJldHVybiBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCd1aTptb2RhbCcsIHtcbiAgICB0aXRsZTogREVGQVVMVF9QUk9NUFRfVElUTEVTW3NjaGVtZS50eXBlXSxcbiAgICBjb250ZW50OiBbXG4gICAgICAnPHA+JyxcbiAgICAgICdUaGlzIEFQSSByZXF1aXJlcyBhdXRoZW50aWNhdGlvbi4gUGxlYXNlIGVudGVyIHlvdXIgYXBwbGljYXRpb24ga2V5cy4nLFxuICAgICAgJzwvcD4nLFxuICAgICAgJzxwPjxlbT5XZSBkbyBub3Qgc3RvcmUgeW91ciBrZXlzLjwvZW0+PC9wPicsXG4gICAgICAnPGZvcm0+JyxcbiAgICAgIHByb21wdEZvcm0sXG4gICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZm9vdGVyXCI+JyxcbiAgICAgICc8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiPlN1Ym1pdDwvYnV0dG9uPicsXG4gICAgICAnPC9kaXY+JyxcbiAgICAgICc8L2Zvcm0+J1xuICAgIF0uam9pbignXFxuJyksXG4gICAgc2hvdzogZnVuY3Rpb24gKG1vZGFsKSB7XG4gICAgICBtb2RhbC5lbC5xdWVyeVNlbGVjdG9yKCdmb3JtJylcbiAgICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgXy5lYWNoKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzY29wZXMnKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleE9mID0gXy5pbmRleE9mKG9wdGlvbnMuc2NvcGVzLCBlbC52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVzLnB1c2goZWwudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZiA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBvcHRpb25zLnNjb3Blcy5zcGxpY2UoaW5kZXhPZiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuIGRvbmUoZXJyIHx8IChjYW5jZWxsZWQgPyBuZXcgRXJyb3IoJ01vZGFsIGNsb3NlZCcpIDogbnVsbCksIG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXV0aGVudGljYXRlIHVzaW5nIGFuIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBhbmQgcGFzc2VkIGluIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIHNjaGVtZVxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBkb25lXG4gKi9cbnZhciBhdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoc2NoZW1lLCBvcHRpb25zLCBkb25lKSB7XG4gIHZhciBvcHRzID0gXy5kZWZhdWx0cyh7XG4gICAgdHlwZTogc2NoZW1lLnR5cGVcbiAgfSwgb3B0aW9ucywgc2NoZW1lLnNldHRpbmdzKTtcblxuICAvLyBJbnRlcnBvbGF0ZSBhbGwgdXJpIHBhcmFtZXRlcnMuXG4gIF8uZWFjaChbXG4gICAgJ2FjY2Vzc1Rva2VuVXJpJyxcbiAgICAnYXV0aG9yaXphdGlvblVyaScsXG4gICAgJ3JlcXVlc3RUb2tlblVyaScsXG4gICAgJ2F1dGhvcml6YXRpb25VcmknLFxuICAgICd0b2tlbkNyZWRlbnRpYWxzVXJpJ1xuICBdLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBvcHRzW3BhcmFtXSA9IHRlbXBsYXRlKG9wdHNbcGFyYW1dLCBvcHRzLmJhc2VVcmlQYXJhbWV0ZXJzKTtcbiAgfSk7XG5cbiAgLy8gVHJpZ2dlciB0aGUgYXV0aGVudGljYXRpb24gZmxvdy5cbiAgQXBwLm1pZGRsZXdhcmUudHJpZ2dlcignYXV0aGVudGljYXRlJywgb3B0cywgZnVuY3Rpb24gKGVyciwgdG9rZW5zKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRva2Vucykge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbmUobnVsbCwgc2NoZW1lLCBvcHRpb25zLCB0b2tlbnMpO1xuICB9LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBmcm9tIGEgdGhpcmQtcGFydHkgc291cmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIHNjaGVtZVxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgcmVxdWVzdFRva2VucyA9IGZ1bmN0aW9uIChzY2hlbWUsIG9wdGlvbnMsIGRvbmUpIHtcbiAgdmFyIGNiID0gZnVuY3Rpb24gKGVyciwgdG9rZW5zKSB7XG4gICAgcmV0dXJuIGRvbmUoZXJyLCBfLmV4dGVuZCh7fSwgdG9rZW5zLCBvcHRpb25zKSk7XG4gIH07XG5cbiAgcmV0dXJuIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ3JhbWxDbGllbnQ6dG9rZW4nLCBzY2hlbWUsIGNiLCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcmVmZXJyZWQgc2NoZW1lIG9wdGlvbiBmcm9tIGFuIG9iamVjdCBvZiBldmVyeSBzY2hlbWUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBwcmVmZXJyZWRTY2hlbWUgPSBmdW5jdGlvbiAoc2NoZW1lcykge1xuICAvLyBGaXggYHVuZGVmaW5lZGAgc2NoZW1lcyBpc3N1ZXMuXG4gIGlmICghc2NoZW1lcyB8fCAhT2JqZWN0LmtleXMoc2NoZW1lcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1ldGhvZCA9IF8uaW50ZXJzZWN0aW9uKE9SREVSX1BSRUZFUkVOQ0UsIF8ucGx1Y2soc2NoZW1lcywgJ3R5cGUnKSlbMF07XG5cbiAgLy8gUmV0dXJuIGFuIGVzc2VudGlhbGx5IHJhbmRvbSBidXQgY29uc2lzdGVudCBzY2hlbWUuXG4gIGlmICghbWV0aG9kKSB7XG4gICAgcmV0dXJuIHNjaGVtZXNbXy5rZXlzKHNjaGVtZXMpWzBdXTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHNjaGVtZSB0aGF0IG1hdGNoZWQgb3VyIHByZWZlcnJlZCBtZXRob2QuXG4gIHJldHVybiBfLmZpbmQoc2NoZW1lcywgZnVuY3Rpb24gKHNjaGVtZSkge1xuICAgIHJldHVybiBzY2hlbWUudHlwZSA9PT0gbWV0aG9kO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYXV0aGVudGljYXRpb24gdG9rZW5zIGFuZCBtZXRob2QgYW55IHdheSBwb3NzaWJsZS4gSXQgd2lsbCBhdHRlbXB0XG4gKiB0byByZXNvbHZlIGF1dG9tYXRpY2FsbHkuIElmIHRoYXQgaXMgbm90IHBvc3NpYmxlLCBpdCB3aWxsIGRlZmVyIHRvXG4gKiBwcm9tcHRpbmcgdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgc2NoZW1lc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgcmV0cmlldmVUb2tlbnMgPSBmdW5jdGlvbiAoc2NoZW1lcywgb3B0aW9ucywgZG9uZSkge1xuICB2YXIgdG9rZW5zO1xuXG4gIC8vIEF0dGVtcHQgdG8gZ2V0IHRoZSBmaXJzdCByZXNvbHZpbmcgc2V0IG9mIGFjY2VzcyB0b2tlbnMuXG4gIGFzeW5jLmRldGVjdFNlcmllcyhfLm1hcChzY2hlbWVzLCBmdW5jdGlvbiAoc2VjdXJlZCwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIHNjaGVtZXNbbWV0aG9kXTtcbiAgfSksIGZ1bmN0aW9uIChzY2hlbWUsIGNiKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RUb2tlbnMoc2NoZW1lLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyIHx8ICFkYXRhIHx8ICFoYXNSZXF1aXJlZFRva2VucyhzY2hlbWUsIGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBjYihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYih0b2tlbnMgPSBkYXRhKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKHNjaGVtZSkge1xuICAgIGlmICghc2NoZW1lKSB7XG4gICAgICBzY2hlbWUgPSBwcmVmZXJyZWRTY2hlbWUoc2NoZW1lcyk7XG5cbiAgICAgIGlmICghc2NoZW1lKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignTm8gc2NoZW1lcyBhdmFpbGFibGUnKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9tcHRUb2tlbnMoc2NoZW1lLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyLCBzY2hlbWUsIHRva2Vucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShudWxsLCBzY2hlbWUsIHRva2Vucyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIG1hZ2ljYWxseSByZXNvbHZlIHRvIHRoZSBmaXJzdCB3b3JraW5nIGF1dGhlbnRpY2F0aW9uIG1ldGhvZC4gSWZcbiAqIHdlIGZhaWwsIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIG1hbnVhbCBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHdpdGggdGhlXG4gKiBvcHRpbWFsIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgc2NoZW1lc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgcmVzb2x2ZVNjaGVtZSA9IGZ1bmN0aW9uIChzY2hlbWVzLCBvcHRpb25zLCBkb25lKSB7XG4gIHJldHVybiByZXRyaWV2ZVRva2VucyhzY2hlbWVzLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBzY2hlbWUsIHRva2Vucykge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGRvbmUoZXJyKTsgfVxuXG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIHRva2VucywgZG9uZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgY29udGFpbiBhbGwgdGhlIGxvZ2ljIGZvciBhdXRvbWFnaWNhbGx5XG4gKiBzZWxlY3RpbmcgYW4gYXBwcm9wcmlhdGUgYXV0aGVudGljYXRpb24gbWV0aG9kIGFuZCBwcm9tcHRpbmcgdGhlIHVzZXJcbiAqIGZvciB0aGUgZm9sbG93aW5nIHN0ZXBzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIHNjaGVtZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1lcywgbWV0aG9kLCBvcHRpb25zLCBkb25lKSB7XG4gIHZhciBhdXRoID0gXy5leHRlbmQoe30sIG9wdGlvbnMpO1xuXG4gIC8vIElmIG5vIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBoYXMgYmVlbiBwYXNzZWQgaW4sIGF0dGVtcHQgdG8gcGljayBvdXIgb3duLlxuICBpZiAoIW1ldGhvZCkge1xuICAgIHJldHVybiByZXNvbHZlU2NoZW1lKHNjaGVtZXMsIGF1dGgsIGRvbmUpO1xuICB9XG5cbiAgLy8gRW5zdXJlIHdlIGFyZSBhdHRlbXB0aW5nIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIGEgdmFsaWQgbWV0aG9kLlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWVzLCBtZXRob2QpKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKFxuICAgICAgJ1RoZSBvbmx5IGF2YWlsYWJsZSBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGFyZTogJyArXG4gICAgICBfLmtleXMoc2NoZW1lcykubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKCcsICcpXG4gICAgKSk7XG4gIH1cblxuICB2YXIgc2NoZW1lID0gc2NoZW1lc1ttZXRob2RdO1xuXG4gIC8vIElmIHdlIGRvbid0IGhhdmUgYWxsIHRoZSByZXF1aXJlZCB0b2tlbnMgYXZhaWxhYmxlLCBwcm9tcHQgdGhlIHVzZXIgdG9cbiAgLy8gaW5wdXQgdG9rZW5zIGFuZCBjb250aW51ZSBhdXRoZW50aWNhdGluZy5cbiAgaWYgKCFoYXNSZXF1aXJlZFRva2VucyhzY2hlbWUsIGF1dGgpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RUb2tlbnMoc2NoZW1lLCBhdXRoLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBkb25lKGVycik7IH1cblxuICAgICAgLy8gRG9uJ3QgcHJvbXB0IGZvciB0aGUgdG9rZW5zIGlmIHdlIG1hbmFnZWQgdG8gcmV0cmlldmUgdGhlbSBhbnl3YXkuXG4gICAgICBpZiAoaGFzUmVxdWlyZWRUb2tlbnMoc2NoZW1lLCBfLmRlZmF1bHRzKGF1dGgsIGRhdGEpKSkge1xuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRlKHNjaGVtZSwgYXV0aCwgZG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9tcHRUb2tlbnMoc2NoZW1lLCBhdXRoLCBmdW5jdGlvbiAoZXJyLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gZG9uZShlcnIpOyB9XG5cbiAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIHRva2VucywgZG9uZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpbmFsbHkgd2UgaGF2ZSBldmVyeXRoaW5nIHdlIG5lZWQgYW5kIGNhbiBpbml0aWF0ZSBhdXRoZW50aWNhdGlvbi5cbiAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIGF1dGgsIGRvbmUpO1xufTtcblxuLyoqXG4gKiBFeHBvc2Ugc2VjcmV0IGZpZWxkIG5hbWVzLlxuICovXG5leHBvcnRzLlNFQ1JFVF9GSUVMRFMgPSBTRUNSRVRfRklFTERTO1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gICAgICAgICAgID0gQXBwLkxpYnJhcnkuXztcbnZhciBxcyAgICAgICAgICA9IEFwcC5MaWJyYXJ5LnFzO1xudmFyIHRlbXBsYXRlICAgID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xudmFyIHNhbml0aXplQVNUID0gcmVxdWlyZSgnLi9zYW5pdGl6ZS1hc3QnKTtcblxudmFyIENPTkZJR19QUk9QRVJUWSA9ICchY29uZmlnJztcbnZhciBDTElFTlRfUFJPUEVSVFkgPSAnIWNsaWVudCc7XG5cbnZhciBKU09OX1JFR0VYUCA9IC9eYXBwbGljYXRpb25cXC8oW1xcdyEjXFwkJSZcXCpgXFwtXFwuXFxefl0qXFwrKT9qc29uJC9pO1xuXG52YXIgSFRUUF9NRVRIT0RTICAgICAgICAgPSBbJ2dldCcsICdoZWFkJywgJ3B1dCcsICdwb3N0JywgJ3BhdGNoJywgJ2RlbGV0ZSddO1xudmFyIFJFVFVSTl9QUk9QRVJUWSAgICAgID0gJyFyZXR1cm4nO1xudmFyIERFU0NSSVBUSU9OX1BST1BFUlRZID0gJyFkZXNjcmlwdGlvbic7XG52YXIgQ09ORklHX09QVElPTlMgICAgICAgPSBbXG4gICdib2R5JyxcbiAgJ3Byb3h5JyxcbiAgJ3VyaVBhcmFtZXRlcnMnLFxuICAnYmFzZVVyaScsXG4gICdiYXNlVXJpUGFyYW1ldGVycycsXG4gICdoZWFkZXJzJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2JlZm9yZVNlbmQnXG5dO1xudmFyIE9WRVJSSURBQkxFX0NPTkZJR19PUFRJT05TID0gXy5vYmplY3QoXG4gIFsnYm9keScsICdwcm94eScsICdiYXNlVXJpJywgJ2JlZm9yZVNlbmQnXSwgdHJ1ZVxuKTtcblxuLyoqXG4gKiBTdGF0aWMgZGVzY3JpcHRpb24gb2YgdGhlIG1lZGlhIHR5cGUgZXh0ZW5zaW9uIGZ1bmN0aW9uLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBFWFRFTlNJT05fREVTQ1JJUFRJT04gPSB7XG4gICchdHlwZSc6ICdmbihleHRlbnNpb24pJyxcbiAgJyFhcmdzJzogW3tcbiAgICAnIXR5cGUnOiAnc3RyaW5nJyxcbiAgICAnIWRvYyc6ICAnU2V0IHRoZSBmaWxlIGV4dGVuc2lvbiB3aXRoIHJlbGV2YW50IGBBY2NlcHRgIGhlYWRlci4nXG4gIH1dLFxuICAnIWRvYyc6IFtcbiAgICAnU2V0IHRoZSBwYXRoIGV4dGVuc2lvbiBhbmQgY29ycmVzcG9uZGluZyBhY2NlcHQgaGVhZGVyLidcbiAgXS5qb2luKCcgJylcbn07XG5cbi8qKlxuICogU3RhdGljIGRlc2NyaXB0aW9uIG9mIHRoZSBjbGllbnQgb2JqZWN0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBDTElFTlRfREVTQ1JJUFRJT04gPSB7XG4gICchdHlwZSc6ICdmbih1cmwsIGRhdGE/KScsXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ3N0cmluZycsXG4gICAgJyFkb2MnOiAgJ1Byb3ZpZGUgYSB1cmwgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJpLidcbiAgfSwge1xuICAgICchdHlwZSc6ICdvYmplY3QnLFxuICAgICchZG9jJzogICdQcm92aWRlIGEgZGF0YSBvYmplY3QgdG8gcmVwbGFjZSB0ZW1wbGF0ZSB0YWdzIGluIHRoZSBgdXJsYC4nXG4gIH1dLFxuICAnIWRvYyc6IFtcbiAgICAnTWFrZSBhbiBBUEkgcmVxdWVzdCB0byBhIGN1c3RvbSBVUkwuJ1xuICBdLmpvaW4oJyAnKVxufTtcblxuLyoqXG4gKiBNYXAgdGhlIHN1cHBvcnRlZCBhdXRoIHR5cGVzIHRvIHRoZSBrbm93biB0cmlnZ2Vycy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgYXV0aE1hcCA9IHtcbiAgJ09BdXRoIDEuMCc6ICAgICAgICAgICAgJ29hdXRoMScsXG4gICdPQXV0aCAyLjAnOiAgICAgICAgICAgICdvYXV0aDInLFxuICAnQmFzaWMgQXV0aGVudGljYXRpb24nOiAnYmFzaWNBdXRoJ1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBkYXRhIG9iamVjdCBpbnRvIGEgZm9ybSBkYXRhIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gICBkYXRhXG4gKiBAcmV0dXJuIHtGb3JtRGF0YX1cbiAqL1xudmFyIHRvRm9ybURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBwaWVjZSBvZiBkYXRhIGFuZCBhcHBlbmQgdG8gdGhlIGZvcm0gZGF0YSBvYmplY3QuXG4gIF8uZWFjaChkYXRhLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gZm9ybTtcbn07XG5cbi8qKlxuICogTWFwIG1pbWUgdHlwZXMgdG8gdGhlaXIgcGFyc2Vycy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcGFyc2UgPSBbXG4gIFtKU09OX1JFR0VYUCwgSlNPTi5wYXJzZV0sXG4gIFsnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgcXMucGFyc2VdXG5dO1xuXG4vKipcbiAqIE1hcCBtaW1lIHR5cGVzIHRvIHRoZWlyIHNlcmlhbGl6ZXJzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBzZXJpYWxpemUgPSBbXG4gIFtKU09OX1JFR0VYUCwgSlNPTi5zdHJpbmdpZnldLFxuICBbJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIHFzLnN0cmluZ2lmeV0sXG4gIFsnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIHRvRm9ybURhdGFdXG5dO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBhcnJheSBvZiBtYXRjaCBhbmQgcmVzdWx0IHZhbHVlcywgYW5kIHJldHVybiB0aGVcbiAqIGZpcnN0IG1hdGNoaW5nIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgICBhcnJheVxuICogQHBhcmFtICB7U3RyaW5nfSAgIHRlc3RcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgZ2V0TWF0Y2ggPSBmdW5jdGlvbiAoYXJyYXksIHRlc3QpIHtcbiAgdmFyIG1hdGNoID0gXy5maW5kKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgY2hlY2sgPSB2YWx1ZVswXTtcblxuICAgIGlmIChfLmlzUmVnRXhwKGNoZWNrKSkge1xuICAgICAgcmV0dXJuIGNoZWNrLnRlc3QodGVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrID09PSB0ZXN0O1xuICB9KTtcblxuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59O1xuXG4vKipcbiAqIFNvcnQgbWltZXMgYnkgcHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIG1pbWVQcmVmZXJlbmNlID0gZnVuY3Rpb24gKG1pbWUpIHtcbiAgcmV0dXJuIGdldE1hdGNoKFtcbiAgICBbSlNPTl9SRUdFWFAsIDNdLFxuICAgIFsnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgMl0sXG4gICAgWydtdWx0aXBhcnQvZm9ybS1kYXRhJywgMV1cbiAgXSwgbWltZSkgfHwgMDtcbn07XG5cbi8qKlxuICogVHVybiBhIHN0cmluZyBpbnRvIGlubGluZSBjb2RlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBjb2RpZnlNYXJrZG93biA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuICdgJyArIHN0ciArICdgJztcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHJhbWwgYm9keSBvYmplY3QgdG8gYSBtYXJrZG93biBkb2N1bWVudGF0aW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJvZHlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHJhbWxCb2R5VG9NYXJrZG93biA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIHZhciBtaW1lcyAgICAgICAgID0gXy5rZXlzKGJvZHkpLnNvcnQobWltZVByZWZlcmVuY2UpO1xuICB2YXIgZG9jdW1lbnRhdGlvbiA9IFtdO1xuXG4gIC8vIElmIG11bHRpcGxlIG1pbWUgdHlwZXMgYXJlIHN1cHBvcnRlZCwgYWRkIGEgZGVmYXVsdCBtaW1lIHR5cGUgdXNhZ2Ugbm90ZS5cbiAgaWYgKG1pbWVzLmxlbmd0aCA+IDEpIHtcbiAgICBkb2N1bWVudGF0aW9uLnB1c2goXG4gICAgICAnVGhlIGJvZHkgZm9yIHRoaXMgcmVzb3VyY2Ugc3VwcG9ydHMgbXVsdGlwbGUgY29udGVudCB0eXBlcy4gQnkgJyArXG4gICAgICAnZGVmYXVsdCwgJyArIGNvZGlmeU1hcmtkb3duKG1pbWVzWzBdKSArICcgd2lsbCBiZSB1c2VkLiBIb3dldmVyLCB5b3UgJyArXG4gICAgICAnY2FuIGVhc2lseSBzcGVjaWZ5IGFub3RoZXIgYENvbnRlbnQtVHlwZWAgdG8gYmUgdXNlZC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIG1pbWUgdHlwZSBhbmQgYXBwZW5kIGRvY3VtZW50YXRpb24uXG4gIF8uZWFjaChtaW1lcywgZnVuY3Rpb24gKG1pbWUpIHtcbiAgICB2YXIgY29udGVudFR5cGUgPSBib2R5W21pbWVdO1xuXG4gICAgLy8gQXZvaWQgYnVpbGRpbmcgZG9jdW1lbnRhdGlvbiBpZiBpdCdzIG5vdCBhbiBvYmplY3QuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBhdmFpbGFibGUgbWltZSB0eXBlcywgd2UgbmVlZCB0byBwcmVmaXggZWFjaFxuICAgIC8vIGRlZmluaXRpb24gd2l0aCBzb21lIHRleHQgYWJvdXQgdGhlIGN1cnJlbnQgbWltZSB0eXBlLlxuICAgIGlmIChtaW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICBkb2N1bWVudGF0aW9uLnB1c2goXG4gICAgICAgICdXaGVuIHRoZSBjb250ZW50IHR5cGUgaXMgJyArIGNvZGlmeU1hcmtkb3duKG1pbWUpICsgJzonXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEFwcGVuZCB0aGUgYXZhaWxhYmxlIGZvcm0gcGFyYW1ldGVycyB0byB0aGUgbWFya2Rvd24gY29udGVudC5cbiAgICBpZiAoY29udGVudFR5cGUuZm9ybVBhcmFtZXRlcnMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGZvcm0gcGFyYW1ldGVyIGFuZCBnZW5lcmF0ZSBiYXNpYyBkb2N1bWVudGF0aW9uLlxuICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlLmZvcm1QYXJhbWV0ZXJzLCBmdW5jdGlvbiAocGFyYW0sIGtleSkge1xuICAgICAgICBkb2N1bWVudGF0aW9uLnB1c2goXG4gICAgICAgICAgJyogKionICsga2V5ICsgKHBhcmFtLnJlcXVpcmVkID8gJycgOiAnPycpICsgJzoqKiAnICtcbiAgICAgICAgICAnKicgKyBwYXJhbS50eXBlICsgJyogJyArIHBhcmFtLmRlc2NyaXB0aW9uXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIHRoZSBleGFtcGxlIG9udG8gdGhlIGRlc2NyaXB0aW9uIGZvciByZWZlcmVuY2UuXG4gICAgaWYgKGNvbnRlbnRUeXBlLmV4YW1wbGUpIHtcbiAgICAgIGRvY3VtZW50YXRpb24ucHVzaChcbiAgICAgICAgJyoqRXhhbXBsZToqKicsXG4gICAgICAgICdgYGBcXG4nICsgY29udGVudFR5cGUuZXhhbXBsZSArICdcXG5gYGAnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFB1c2ggdGhlIHNjaGVtYSBvbnRvIHRoZSBkZXNjcmlwdGlvbiBmb3IgcmVmZXJlbmNlLlxuICAgIGlmIChjb250ZW50VHlwZS5zY2hlbWEpIHtcbiAgICAgIGRvY3VtZW50YXRpb24ucHVzaChcbiAgICAgICAgJyoqU2NoZW1hOioqJyxcbiAgICAgICAgJ2BgYFxcbicgKyBjb250ZW50VHlwZS5zY2hlbWEgKyAnXFxuYGBgJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkb2N1bWVudGF0aW9uLmpvaW4oJ1xcblxcbicpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIG1ldGhvZCBpcyBhIHF1ZXJ5IG1ldGhvZCAobm90IGEgYm9keSBhcyB0aGUgYXJndW1lbnQpLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIG1ldGhvZFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzUXVlcnlNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09ICdnZXQnIHx8IG1ldGhvZCA9PT0gJ2hlYWQnO1xufTtcblxuLyoqXG4gKiBNYXAgb2YgbWV0aG9kcyB0byB0aGVpciB0b29sdGlwIGRlc2NyaXB0aW9uIG9iamVjdHMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIE1FVEhPRF9ERVNDUklQVElPTiA9IF8ub2JqZWN0KF8ubWFwKEhUVFBfTUVUSE9EUywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICB2YXIgYm9keSA9IGlzUXVlcnlNZXRob2QobWV0aG9kKSA/ICdxdWVyeT8nIDogJ2JvZHk/JztcblxuICByZXR1cm4gW21ldGhvZCwge1xuICAgICchdHlwZSc6ICdmbignICsgYm9keSArICcsIG9wdGlvbnM/LCBhc3luYz8pJ1xuICB9XTtcbn0pKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcmFtbCBvYmplY3QgaW50byBhIGRvY3VtZW50YXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciByYW1sVG9Eb2N1bWVudGF0aW9uRm9ybWF0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgZG9jdW1lbnRhdGlvbiA9IHt9O1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGtleSBhbmQgd2lwZSBvdXQgd2lwZSBhIGNsZWFuIGRvY3VtZW50YXRpb24gb2JqZWN0LlxuICBfLmVhY2gob2JqZWN0LCBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICBkb2N1bWVudGF0aW9uW2tleV0gPSB7XG4gICAgICAnIWRvYyc6ICAgICAgb2JqZWN0LmRlc2NyaXB0aW9uLFxuICAgICAgJyF0eXBlJzogICAgIG9iamVjdC50eXBlLFxuICAgICAgJyFyZXF1aXJlZCc6IG9iamVjdC5yZXF1aXJlZFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBkb2N1bWVudGF0aW9uO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBSQU1MIG1ldGhvZCBvYmplY3QgaW50byBhIHRvb2x0aXAgZG9jdW1lbnRhdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBtZXRob2RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIHRvTWV0aG9kRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobm9kZXMsIG1ldGhvZCkge1xuICB2YXIgaXNRdWVyeSAgICAgICA9IGlzUXVlcnlNZXRob2QobWV0aG9kLm1ldGhvZCk7XG4gIHZhciBjb25maWdPcHRpb25zID0geyAnIXR5cGUnOiAnb2JqZWN0JyB9O1xuICB2YXIgYm9keU9wdGlvbnMgICA9IHsgJyF0eXBlJzogJ29iamVjdCcgfTtcblxuICB2YXIgY2FsbGJhY2tPcHRpb25zID0ge1xuICAgICchZG9jJzogICdQYXNzIGEgZnVuY3Rpb24gdG8gbWFrZSB0aGUgcmVxdWVzdCBleGVjdXRlIGFzeW5jaG9ub3VzbHkuJyxcbiAgICAnIXR5cGUnOiAnZm4oZXJyb3IsIHJlc3BvbnNlKSdcbiAgfTtcblxuICAvLyBBZGQgZG9jdW1lbnRhdGlvbiBvbiB0aGUgcHJveHkuXG4gIGNvbmZpZ09wdGlvbnMucHJveHkgPSB7XG4gICAgJyF0eXBlJzogJ3N0cmluZ3xib29sZWFuJyxcbiAgICAnIWRvYyc6ICAnRGlzYWJsZSBvciBzZXQgYSBjdXN0b20gcHJveHkgdXJsIGZvciB0aGUgY3VycmVudCByZXF1ZXN0LidcbiAgfTtcblxuICAvLyBEb2N1bWVudCB0aGUgYGJlZm9yZVNlbmRgIGFiaWxpdHkuXG4gIGNvbmZpZ09wdGlvbnMuYmVmb3JlU2VuZCA9IHtcbiAgICAnIXR5cGUnOiAnZm4oeGhyKScsXG4gICAgJyFkb2MnOiAgJ01vZGlmeSB0aGUgYFhNTEh0dHBSZXF1ZXN0YCBiZWZvcmUgaXQgZ2V0cyBzZW50LidcbiAgfTtcblxuICAvLyBBZGQgZG9jdW1lbnRhdGlvbiBvbiBoZWFkZXIgcGFyYW1ldGVycy5cbiAgY29uZmlnT3B0aW9ucy5oZWFkZXJzID0gXy5leHRlbmQoe1xuICAgICchdHlwZSc6ICdvYmplY3QnXG4gIH0sIHJhbWxUb0RvY3VtZW50YXRpb25Gb3JtYXQobWV0aG9kLmhlYWRlcnMpKTtcblxuICAvLyBJZiB0aGUgbWV0aG9kIGlzIGEgcXVlcnkgbWV0aG9kIChHRVQvSEVBRCksIHNldCB0aGUgYm9keSBhcyBhIGNvbmZpZyBvcHRpb25cbiAgLy8gYW5kIHZpc2UgdmVyc2EuXG4gIGlmIChpc1F1ZXJ5KSB7XG4gICAgXy5leHRlbmQoYm9keU9wdGlvbnMsIHJhbWxUb0RvY3VtZW50YXRpb25Gb3JtYXQobWV0aG9kLnF1ZXJ5UGFyYW1ldGVycykpO1xuXG4gICAgY29uZmlnT3B0aW9ucy5ib2R5ID0ge1xuICAgICAgJyF0eXBlJzogJ29iamVjdCcsXG4gICAgICAnIWRvYyc6ICByYW1sQm9keVRvTWFya2Rvd24obWV0aG9kLmJvZHkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBib2R5T3B0aW9ucyA9IHtcbiAgICAgICchdHlwZSc6ICdvYmplY3R8c3RyaW5nJyxcbiAgICAgICchZG9jJzogIHJhbWxCb2R5VG9NYXJrZG93bihtZXRob2QuYm9keSksXG4gICAgfTtcblxuICAgIGNvbmZpZ09wdGlvbnMucXVlcnkgPSBfLmV4dGVuZCh7XG4gICAgICAnIXR5cGUnOiAnb2JqZWN0J1xuICAgIH0sIHJhbWxUb0RvY3VtZW50YXRpb25Gb3JtYXQobWV0aG9kLnF1ZXJ5UGFyYW1ldGVycykpO1xuICB9XG5cbiAgLy8gSWYgdGhlIGN1cnJlbnQgbm9kZSBoYXMgYmFzZVVyaVBhcmFtZXRlcnMsIHNob3cgaXQgaW4gdGhlIGRvY3VtZW50YXRpb24uXG4gIGlmIChub2Rlcy5jbGllbnQuYmFzZVVyaVBhcmFtZXRlcnMpIHtcbiAgICBjb25maWdPcHRpb25zLmJhc2VVcmlQYXJhbWV0ZXJzID0gXy5leHRlbmQoe1xuICAgICAgJyF0eXBlJzogJ29iamVjdCdcbiAgICB9LCByYW1sVG9Eb2N1bWVudGF0aW9uRm9ybWF0KG5vZGVzLmNsaWVudC5iYXNlVXJpUGFyYW1ldGVycykpO1xuICB9XG5cbiAgcmV0dXJuIF8uZXh0ZW5kKHtcbiAgICAnIWRvYyc6ICBtZXRob2QuZGVzY3JpcHRpb24sXG4gICAgJyFhcmdzJzogW2JvZHlPcHRpb25zLCBjb25maWdPcHRpb25zLCBjYWxsYmFja09wdGlvbnNdXG4gIH0sIE1FVEhPRF9ERVNDUklQVElPTlttZXRob2QubWV0aG9kXSk7XG59O1xuXG4vKipcbiAqIExpc3Qgb2YgYWxsIHBsYWluIEhUVFAgbWV0aG9kcyBpbiB0aGUgZm9ybWF0IGZyb20gdGhlIEFTVC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgYWxsSHR0cE1ldGhvZHMgPSBfLmNoYWluKEhUVFBfTUVUSE9EUykubWFwKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICByZXR1cm4gW21ldGhvZCwge1xuICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICB9XTtcbiAgfSkub2JqZWN0KCkudmFsdWUoKTtcblxuLyoqXG4gKiBQYXJzZSBhbiBYSFIgcmVxdWVzdCBmb3IgcmVzcG9uc2UgaGVhZGVycyBhbmQgcmV0dXJuIGFzIGFuIG9iamVjdC4gUGFzcyBhblxuICogYWRkaXRpb25hbCBmbGFnIHRvIGZpbHRlciBhbnkgcG90ZW50aWFsIGR1cGxpY2F0ZSBoZWFkZXJzIChFLmcuIGRpZmZlcmVudFxuICogY2FzZXMpLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0geGhyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBnZXRBbGxSZXBvbnNlSGVhZGVycyA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgdmFyIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXG4gIF8uZWFjaCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgaGVhZGVyID0gaGVhZGVyLnNwbGl0KCc6Jyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBib3RoIHBhcnRzIG9mIHRoZSBoZWFkZXIuXG4gICAgaWYgKGhlYWRlci5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgbmFtZSAgPSBoZWFkZXIuc2hpZnQoKTtcbiAgICAgIHZhciB2YWx1ZSA9IGhlYWRlci5qb2luKCc6JykudHJpbSgpO1xuXG4gICAgICByZXNwb25zZUhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlSGVhZGVycztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB4aHIgcmVzcG9uc2UgbWltZSB0eXBlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gY29udGVudFR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGdldE1pbWUgPSBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcbiAgcmV0dXJuIGNvbnRlbnRUeXBlID09IG51bGwgPyBudWxsIDogU3RyaW5nKGNvbnRlbnRUeXBlKS5zcGxpdCgnOycpWzBdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBob3N0IG9iamVjdCBhbmQgYXZvaWQgc2VyaWFsaXppbmcuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNIb3N0ID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgY2FzZSAnW29iamVjdCBGb3JtRGF0YV0nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTYW5pdGl6ZSBhIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gb3B0aW9uLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBzYW5pdGl6ZU9wdGlvbiA9IHtcbiAgcXVlcnk6IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIGlmIChfLmlzU3RyaW5nKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHFzLnBhcnNlKHF1ZXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyBhIGhlYWRlciBmcm9tIHRoZSBoZWFkZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIGhlYWRlcnNcbiAqIEBwYXJhbSAge1N0cmluZ30gIGhlYWRlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGZpbmRIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVycywgaGVhZGVyKSB7XG4gIGhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBfLmZpbmQoaGVhZGVycywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gaGVhZGVyO1xuICB9KTtcbn07XG5cbi8qKlxuICogU2FuaXRpemUgdGhlIFhIUiByZXF1ZXN0IGludG8gdGhlIGRlc2lyZWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSAge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIHNhbml0aXplWEhSID0gZnVuY3Rpb24gKHhocikge1xuICBpZiAoIXhocikgeyByZXR1cm4geGhyOyB9XG5cbiAgdmFyIG1pbWUgICAgPSBnZXRNaW1lKHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykpO1xuICB2YXIgYm9keSAgICA9IHhoci5yZXNwb25zZVRleHQudHJpbSgpO1xuICB2YXIgaGVhZGVycyA9IGdldEFsbFJlcG9uc2VIZWFkZXJzKHhocik7XG5cbiAgLy8gQXV0b21hdGljYWxseSBwYXJzZSBhbGwgcmVzcG9uc2UgYm9kaWVzLiBPbmx5IHBhcnNlIHdoZW4gd2UgaGF2ZSByZXNwb25zZVxuICAvLyBib2R5IGNvbnRlbnQuIEVycm9ycyB0aGF0IG9jY3VyIHBhcnNpbmcgd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHRoZSBjbGllbnQuXG4gIGJvZHkgPSBib2R5ID8gKGdldE1hdGNoKHBhcnNlLCBtaW1lKSB8fCBfLmlkZW50aXR5KShib2R5KSA6IHVuZGVmaW5lZDtcblxuICByZXR1cm4ge1xuICAgIGJvZHk6ICAgIGJvZHksXG4gICAgc3RhdHVzOiAgeGhyLnN0YXR1cyxcbiAgICBoZWFkZXJzOiBoZWFkZXJzXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYWpheCByZXF1ZXN0cy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgdXJsXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudmFyIGh0dHBSZXF1ZXN0ID0gZnVuY3Rpb24gKG5vZGVzLCBtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChib2R5LCBjb25maWcsIGRvbmUpIHtcbiAgICAvLyBBbGxvdyBjb25maWcgdG8gYmUgb21pdHRlZCBmcm9tIGFyZ3VtZW50cy5cbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIGRvbmUgICA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGNvbmZpZyA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgLy8gTWFwIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgbWVyZ2Ugd2l0aCB0aGUgcGFzc2VkIGluIG9iamVjdC5cbiAgICBjb25maWcgPSBfLm9iamVjdChDT05GSUdfT1BUSU9OUywgXy5tYXAoQ09ORklHX09QVElPTlMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgIGlmIChfLmhhcyhPVkVSUklEQUJMRV9DT05GSUdfT1BUSU9OUywgb3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gXy5oYXMoY29uZmlnLCBvcHRpb24pID8gY29uZmlnW29wdGlvbl0gOiBub2Rlcy5jb25maWdbb3B0aW9uXTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVPcHRpb24gICA9IG5vZGVzLmNvbmZpZ1tvcHRpb25dO1xuICAgICAgdmFyIGNvbmZpZ09wdGlvbiA9IGNvbmZpZyAmJiBjb25maWdbb3B0aW9uXTtcbiAgICAgIHZhciBzYW5pdGl6ZSAgICAgPSBzYW5pdGl6ZU9wdGlvbltvcHRpb25dIHx8IF8uaWRlbnRpdHk7XG5cbiAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgc2FuaXRpemUobm9kZU9wdGlvbiksIHNhbml0aXplKGNvbmZpZ09wdGlvbikpO1xuICAgIH0pKTtcblxuICAgIHZhciBhc3luYyAgID0gISFkb25lO1xuICAgIHZhciByZXF1ZXN0ID0gJ2FqYXgnO1xuICAgIHZhciBtaW1lICAgID0gZ2V0TWltZShmaW5kSGVhZGVyKGNvbmZpZy5oZWFkZXJzLCAnQ29udGVudC1UeXBlJykpO1xuICAgIHZhciBiYXNlVXJpID0gdGVtcGxhdGUoY29uZmlnLmJhc2VVcmksIGNvbmZpZy5iYXNlVXJpUGFyYW1ldGVycyk7XG4gICAgdmFyIGZ1bGxVcmkgPSBiYXNlVXJpLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgbm9kZXMuam9pbignLycpO1xuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgYXN5bmMsIHNldCB0aGUgcmVsZXZhbnQgZnVuY3Rpb24gY2FsbGJhY2tzLlxuICAgIGlmIChhc3luYykge1xuICAgICAgQXBwLl9leGVjdXRlQ29udGV4dC50aW1lb3V0KEluZmluaXR5KTtcblxuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oZG9uZSkpIHtcbiAgICAgICAgZG9uZSA9IEFwcC5fZXhlY3V0ZUNvbnRleHQuYXN5bmMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3luY2hyb25vdXMgZXJyb3IgYW5kIHJlc3BvbnNlIGhhbmRsaW5nLlxuICAgICAgZG9uZSA9IGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gR0VUIGFuZCBIRUFEIHJlcXVlc3RzIGFjY2VwdCB0aGUgcXVlcnkgc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICBpZiAoaXNRdWVyeU1ldGhvZChtZXRob2QubWV0aG9kKSkge1xuICAgICAgXy5leHRlbmQoY29uZmlnLnF1ZXJ5LCBzYW5pdGl6ZU9wdGlvbi5xdWVyeShib2R5KSk7XG4gICAgICBib2R5ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGNvbmZpZyBvYmplY3QgYm9keSB0byB0aGUgcGFzc2VkIGluIGJvZHkuXG4gICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLmJvZHkgPSBib2R5O1xuICAgIH1cblxuICAgIC8vIEFwcGVuZCB0aGUgcXVlcnkgc3RyaW5nIGlmIG9uZSBpcyBhdmFpbGFibGUuXG4gICAgaWYgKF8ua2V5cyhjb25maWcucXVlcnkpLmxlbmd0aCkge1xuICAgICAgZnVsbFVyaSArPSAnPycgKyBxcy5zdHJpbmdpZnkoY29uZmlnLnF1ZXJ5KTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIG5vIGFjY2VwdCBoZWFkZXIgc2V0IGFscmVhZHksIGRlZmF1bHQgdG8gYWNjZXB0aW5nXG4gICAgLy8gZXZlcnl0aGluZy4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggc2V0cyB0aGUgYmFzZSBhY2NlcHRcbiAgICAvLyBoZWFkZXIgdG8gZXNzZW50aWFsbHkgYmUgYGh0bWwveG1sYC5cbiAgICBpZiAoIWZpbmRIZWFkZXIoY29uZmlnLmhlYWRlcnMsICdhY2NlcHQnKSkge1xuICAgICAgY29uZmlnLmhlYWRlcnMuYWNjZXB0ID0gJyovKic7XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugd2VyZSBwYXNzZWQgaW4gZGF0YSwgYXR0ZW1wdCB0byBzYW5pdGl6ZSBpdCB0byB0aGUgY29ycmVjdCB0eXBlLlxuICAgIGlmICghaXNIb3N0KGNvbmZpZy5ib2R5KSkge1xuICAgICAgLy8gU2V0IHRoZSBjb3JyZWN0IGBDb250ZW50LVR5cGVgIGhlYWRlciwgaWYgbm9uZSBleGlzdHMuIEtpbmQgb2YgcmFuZG9tXG4gICAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGV4aXN0cyAtIEkgd291bGQgc3VnZ2VzdCBzZXR0aW5nIGl0IHlvdXJzZWxmLlxuICAgICAgaWYgKG1pbWUgPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWV0aG9kIGJvZHkgb2JqZWN0LCBzb3J0IHRoZSBtZXRob2QgdHlwZXMgYnkgbW9zdFxuICAgICAgICAvLyBkZXNpcmFibGUgYW5kIGZhbGxiYWNrIHRvIGEgcmFuZG9tIGNvbnRlbnQgdHlwZS5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBtaW1lID0gXy5rZXlzKG1ldGhvZC5ib2R5KS5zb3J0KG1pbWVQcmVmZXJlbmNlKS5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgY29uZmlnIHRvIHRoZSB1cGRhdGVkIG1pbWUgdHlwZSBoZWFkZXIuIElmIG5vbmUgZXhpc3RzLCB1c2VcbiAgICAgICAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIGJ5IGRlZmF1bHQuXG4gICAgICAgIGNvbmZpZy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IG1pbWUgPSBtaW1lIHx8ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIH1cblxuICAgICAgLy8gQXV0b21hdGljYWxseSBhdHRlbXB0IHRvIHNlcmlhbGl6ZSB0aGUgYm9keS5cbiAgICAgIHZhciBzZXJpYWxpemVyID0gZ2V0TWF0Y2goc2VyaWFsaXplLCBtaW1lKTtcblxuICAgICAgaWYgKCFzZXJpYWxpemVyKSB7XG4gICAgICAgIHJldHVybiBkb25lKFxuICAgICAgICAgIG5ldyBUeXBlRXJyb3IoJ0NhbiBub3Qgc2VyaWFsaXplIGNvbnRlbnQgdHlwZSBvZiBcIicgKyBtaW1lICsgJ1wiJylcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZmlnLmJvZHkgPSBzZXJpYWxpemVyKGNvbmZpZy5ib2R5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IFR5cGVFcnJvcignQ291bGQgbm90IHNlcmlhbGl6ZSBib2R5OiAnICsgZS5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmw6ICAgICAgICBmdWxsVXJpLFxuICAgICAgZGF0YTogICAgICAgY29uZmlnLmJvZHksXG4gICAgICBhc3luYzogICAgICBhc3luYyxcbiAgICAgIHByb3h5OiAgICAgIGNvbmZpZy5wcm94eSxcbiAgICAgIG1ldGhvZDogICAgIG1ldGhvZC5tZXRob2QsXG4gICAgICBoZWFkZXJzOiAgICBjb25maWcuaGVhZGVycyxcbiAgICAgIGJlZm9yZVNlbmQ6IGNvbmZpZy5iZWZvcmVTZW5kXG4gICAgfTtcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBgc2VjdXJlZEJ5YCBtZXRob2RzIGFuZCBhY2NlcHQgdGhlIGZpcnN0IG9uZSB3ZSBhcmVcbiAgICAvLyBhbHJlYWR5IGF1dGhlbnRpY2F0ZWQgZm9yLlxuICAgIF8uc29tZShtZXRob2Quc2VjdXJlZEJ5IHx8IG5vZGVzLmNsaWVudC5zZWN1cmVkQnksIGZ1bmN0aW9uIChzZWN1cmVkLCBrZXkpIHtcbiAgICAgIHZhciBzY2hlbWUgPSBub2Rlcy5jbGllbnQuc2VjdXJpdHlTY2hlbWVzW2tleV07XG5cbiAgICAgIC8vIFNjaGVtZSBpcyBub3QgZG9jdW1lbnRlZCBpbiB0aGUgUkFNTCBzZWN1cml0eSBzY2hlbWVzLlxuICAgICAgaWYgKCFzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXV0aGVudGljYXRlZCA9IG5vZGVzLmNsaWVudC5hdXRoZW50aWNhdGlvbltzY2hlbWUudHlwZV07XG4gICAgICB2YXIgYXV0aFR5cGUgICAgICA9IGF1dGhNYXBbc2NoZW1lLnR5cGVdO1xuXG4gICAgICBpZiAoYXV0aGVudGljYXRlZCkge1xuICAgICAgICBvcHRpb25zW2F1dGhUeXBlXSA9IGF1dGhlbnRpY2F0ZWQ7XG5cbiAgICAgICAgcmV0dXJuIChyZXF1ZXN0ID0gJ2FqYXg6JyArIGF1dGhUeXBlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEF3a3dhcmQgc3luYyBhbmQgYXN5bmMgY29kZSBtaXhpbmcuXG4gICAgdmFyIHJlc3BvbnNlLCBlcnJvcjtcblxuICAgIC8vIFRyaWdnZXIgdGhlIGFqYXggbWlkZGxld2FyZSBzbyBwbHVnaW5zIGNhbiBob29rIG9udG8gdGhlIHJlcXVlc3RzLiBJZlxuICAgIC8vIHRoZSBmdW5jdGlvbiBpcyBhc3luYyB3ZSBuZWVkIHRvIHJlZ2lzdGVyIGEgY2FsbGJhY2sgZm9yIHRoZSBtaWRkbGV3YXJlLlxuICAgIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIocmVxdWVzdCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgICBlcnJvciA9IGVycjtcblxuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gc2FuaXRpemVYSFIoeGhyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcignQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXN5bmMgJiYgZG9uZShlcnJvciwgcmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3Qgd2FzIHN5bmNocm9ub3VzLCByZXR1cm4gdGhlIHNhbml0aXplZCBYSFIgcmVzcG9uc2UgZGF0YS5cbiAgICBpZiAoIWFzeW5jKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnJvciwgcmVzcG9uc2UpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgWEhSIHJlcXVlc3QgbWV0aG9kcyB0byB0aGUgY29udGV4dCBvYmplY3QgZm9yIGVhY2ggYXZhaWxhYmxlIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIG5vZGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSAge09iamVjdH0gbWV0aG9kc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgYXR0YWNoTWV0aG9kcyA9IGZ1bmN0aW9uIChub2RlcywgY29udGV4dCwgbWV0aG9kcykge1xuICAvLyBBdHRhY2ggdGhlIGF2YWlsYWJsZSBtZXRob2RzIHRvIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kLCB2ZXJiKSB7XG4gICAgY29udGV4dFt2ZXJiXSA9IGh0dHBSZXF1ZXN0KG5vZGVzLCBtZXRob2QpO1xuICAgIGNvbnRleHRbdmVyYl1bREVTQ1JJUFRJT05fUFJPUEVSVFldID0gdG9NZXRob2REZXNjcmlwdGlvbihub2RlcywgbWV0aG9kKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vKipcbiAqIEF0dGFjaCBhIHNwZWNpYWwgbWVkaWEgZXh0ZW5zaW9uIGhhbmRsZXIuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlc291cmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBhdHRhY2hNZWRpYVR5cGVFeHRlbnNpb24gPSBmdW5jdGlvbiAobm9kZXMsIGNvbnRleHQsIHJlc291cmNlKSB7XG4gIC8qKlxuICAgKiBQdXNoIHRoZSBleHRlbnNpb24gb250byB0aGUgY3VycmVudCByb3V0ZSBhbmQgc2V0IHJlbGV2YW50IGhlYWRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZXh0ZW5zaW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGNvbnRleHQuZXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiA9PSBudWxsID8gJycgOiBTdHJpbmcoZXh0ZW5zaW9uKTtcblxuICAgIC8vIFByZXBlbmQgYSBwZXJpb2QgdG8gdGhlIGV4dGVuc2lvbiBiZWZvcmUgYWRkaW5nIHRvIHRoZSByb3V0ZS5cbiAgICBpZiAoZXh0ZW5zaW9uICYmIGV4dGVuc2lvbi5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgZXh0ZW5zaW9uID0gJy4nICsgZXh0ZW5zaW9uO1xuICAgIH1cblxuICAgIHZhciBuZXdDb250ZXh0ID0ge307XG4gICAgdmFyIHJvdXRlTm9kZXMgPSBfLmV4dGVuZChbXSwgbm9kZXMpO1xuXG4gICAgLy8gQXBwZW5kIHRoZSBleHRlbnNpb24gdG8gdGhlIGN1cnJlbnQgcm91dGUuXG4gICAgcm91dGVOb2Rlc1tyb3V0ZU5vZGVzLmxlbmd0aCAtIDFdICs9IGV4dGVuc2lvbjtcblxuICAgIGF0dGFjaE1ldGhvZHMocm91dGVOb2RlcywgbmV3Q29udGV4dCwgcmVzb3VyY2UubWV0aG9kcyk7XG4gICAgYXR0YWNoUmVzb3VyY2VzKHJvdXRlTm9kZXMsIG5ld0NvbnRleHQsIHJlc291cmNlLnJlc291cmNlcyk7XG5cbiAgICByZXR1cm4gbmV3Q29udGV4dDtcbiAgfTtcblxuICAvLyBBdHRhY2ggYSBkZXNjcmlwdGlvbiBhbmQgcmV0dXJuIHByb3BlcnR5LlxuICBjb250ZXh0LmV4dGVuc2lvbltSRVRVUk5fUFJPUEVSVFldICAgICAgPSBjb250ZXh0LmV4dGVuc2lvbignJyk7XG4gIGNvbnRleHQuZXh0ZW5zaW9uW0RFU0NSSVBUSU9OX1BST1BFUlRZXSA9IEVYVEVOU0lPTl9ERVNDUklQVElPTjtcblxuICAvLyBJZiB0aGUgbWVkaWEgdHlwZSBleHRlbnNpb24gaXMgbm90IHJlcXVpcmVkLCBhbGxvdyBkaXJlY3QgaW52b2NhdGlvbiBvZlxuICAvLyB0aGUgcmVxdWVzdCBtZXRob2QuXG4gIGlmIChyZXNvdXJjZS51cmlQYXJhbWV0ZXJzLm1lZGlhVHlwZUV4dGVuc2lvbi5yZXF1aXJlZCA9PT0gZmFsc2UpIHtcbiAgICBhdHRhY2hNZXRob2RzKG5vZGVzLCBjb250ZXh0LCByZXNvdXJjZS5tZXRob2RzKTtcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZW51bSBvcHRpb25zIGFuZCBhdXRvbWF0aWNhbGx5IGF0dGFjaCB0byB0aGUgY29udGV4dC5cbiAgXy5lYWNoKHJlc291cmNlLnVyaVBhcmFtZXRlcnMubWVkaWFUeXBlRXh0ZW5zaW9uLmVudW0sIGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICBpZiAoZXh0ZW5zaW9uLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICBleHRlbnNpb24gPSBleHRlbnNpb24uc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIGNvbnRleHRbZXh0ZW5zaW9uXSA9IGNvbnRleHQuZXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGNvbnRleHQgb3IgYXR0YWNoIG1ldGhvZHMgYW5kIHJlc291cmNlcyB0byBhbiBleGlzdGluZyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgIG5vZGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9ICByZXNvdXJjZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gaGFzTWVkaWFFeHRlbnNpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIGNvbnRleHRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIG5ld0NvbnRleHQgPSBmdW5jdGlvbiAobm9kZXMsIHJlc291cmNlLCBoYXNNZWRpYUV4dGVuc2lvbiwgY29udGV4dCkge1xuICBjb250ZXh0ID0gY29udGV4dCB8fCB7fTtcblxuICBpZiAoaGFzTWVkaWFFeHRlbnNpb24pIHtcbiAgICBhdHRhY2hNZWRpYVR5cGVFeHRlbnNpb24obm9kZXMsIGNvbnRleHQsIHJlc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICBhdHRhY2hNZXRob2RzKG5vZGVzLCBjb250ZXh0LCByZXNvdXJjZS5tZXRob2RzKTtcbiAgICBhdHRhY2hSZXNvdXJjZXMobm9kZXMsIGNvbnRleHQsIHJlc291cmNlLnJlc291cmNlcyk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogUmVjdXJzZXMgdGhyb3VnaCBhIHJlc291cmNlIG9iamVjdCBpbiB0aGUgUkFNTCBBU1QsIGdlbmVyYXRpbmcgYSBkeW5hbWljXG4gKiBEU0wgdGhhdCBvbmx5IGFsbG93cyBtZXRob2RzIHRoYXQgd2VyZSBkZWZpbmVkIGluIHRoZSBSQU1MIHNwZWMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlc291cmNlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbi8qIGpzaGludCAtVzAwMyAqL1xudmFyIGF0dGFjaFJlc291cmNlcyA9IGZ1bmN0aW9uIChub2RlcywgY29udGV4dCwgcmVzb3VyY2VzKSB7XG4gIF8uZWFjaChyZXNvdXJjZXMsIGZ1bmN0aW9uIChyZXNvdXJjZSwgcm91dGUpIHtcbiAgICB2YXIgcm91dGVOb2RlcyAgICAgICAgPSBfLmV4dGVuZChbXSwgbm9kZXMpO1xuICAgIHZhciByb3V0ZU5hbWUgICAgICAgICA9IHJvdXRlO1xuICAgIHZhciBoYXNNZWRpYUV4dGVuc2lvbiA9IHJvdXRlLnN1YnN0cigtMjApID09PSAne21lZGlhVHlwZUV4dGVuc2lvbn0nO1xuXG4gICAgLy8gSWdub3JlIG1lZGlhIHR5cGUgZXh0ZW5zaW9ucyBpbiByb3V0ZSBnZW5lcmF0aW9uLlxuICAgIGlmIChoYXNNZWRpYUV4dGVuc2lvbikge1xuICAgICAgcm91dGUgPSByb3V0ZU5hbWUgPSByb3V0ZS5zbGljZSgwLCAtMjApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSByb3V0ZSBhZ2FpbnN0IG91ciB2YWxpZCB1cmkgcGFyYW1ldGVycy5cbiAgICB2YXIgdGVtcGxhdGVUYWdzID0gcm91dGUubWF0Y2godGVtcGxhdGUuUkVHRVhQKTtcblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcm91dGUgaW50byB0aGUgcm91dGUgYXJyYXkuXG4gICAgcm91dGVOb2Rlcy5wdXNoKHJvdXRlKTtcblxuICAgIC8vIElmIHdlIGhhdmUgdGVtcGxhdGUgdGFncyBhdmFpbGFibGUsIGF0dGFjaCBhIGR5bmFtaWMgcm91dGUuXG4gICAgaWYgKHRlbXBsYXRlVGFncykge1xuICAgICAgdmFyIHJvdXRlU3VmZml4ID0gdGVtcGxhdGVUYWdzLmpvaW4oJycpO1xuXG4gICAgICAvLyBUaGUgcm91dGUgbXVzdCBlbmQgd2l0aCB0aGUgY2hhaW5lZCB0ZW1wbGF0ZSB0YWdzIGFuZCBoYXZlIG5vXG4gICAgICAvLyB0ZXh0IGJldHdlZW4gdGFncy5cbiAgICAgIGlmIChyb3V0ZS5zdWJzdHIoLXJvdXRlU3VmZml4Lmxlbmd0aCkgIT09IHJvdXRlU3VmZml4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHJvdXRlIGlzIG9ubHkgYSB0ZW1wbGF0ZSB0YWcgd2l0aCBubyBzdGF0aWMgdGV4dCwgdXNlIHRoZVxuICAgICAgLy8gdGVtcGxhdGUgdGFnIHRleHQgYXMgdGhlIG1ldGhvZCBuYW1lLlxuICAgICAgaWYgKHRlbXBsYXRlVGFncy5sZW5ndGggPT09IDEgJiYgcm91dGUgPT09IHRlbXBsYXRlVGFnc1swXSkge1xuICAgICAgICByb3V0ZU5hbWUgPSB0ZW1wbGF0ZVRhZ3NbMF0uc2xpY2UoMSwgLTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVOYW1lID0gcm91dGUuc3Vic3RyKDAsIHJvdXRlLmluZGV4T2YoJ3snKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEF2b2lkIGFkZGluZyBlbXB0eSByb3V0ZSBuYW1lIGNhc2VzLiBUaGlzIGNhbiBvY2N1ciB3aGVuIHdlIGhhdmVcbiAgICAgIC8vIG11bHRpcGxlIHRhZyBuYW1lcyBhbmQgbm8gZnJvbnQgdGV4dC4gRm9yIGV4YW1wbGUsIGB7dGhpc317dGhhdH1gLlxuICAgICAgLy8gVGhpcyBjb3VsZCBhbHNvIG9jY3VyIGlmIGZvciBzb21lIHJlYXNvbiB3ZSBhcmUgcGFzc2luZyBpbiBhIHJvdXRlIHRoYXRcbiAgICAgIC8vIGlzbid0IGR5bmFtaWMuXG4gICAgICBpZiAoIXJvdXRlTmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgb3JkZXJlZCB0YWcgbmFtZXMgZm9yIGNvbXBsZXRpb24uXG4gICAgICB2YXIgdGFncyA9IF8ubWFwKHRlbXBsYXRlVGFncywgZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZS51cmlQYXJhbWV0ZXJzW3BhcmFtLnNsaWNlKDEsIC0xKV07XG4gICAgICB9KTtcblxuICAgICAgLy8gVGhlIHJvdXRlIGlzIGR5bmFtaWMsIHNvIHdlIHNldCB0aGUgcm91dGUgbmFtZSB0byBiZSBhIGZ1bmN0aW9uXG4gICAgICAvLyB3aGljaCBhY2NlcHRzIHRoZSB0ZW1wbGF0ZSBhcmd1bWVudHMgYW5kIHVwZGF0ZXMgdGhlIHBhdGggZnJhZ21lbnQuXG4gICAgICAvLyBXZSdsbCBleHRlbmQgYW55IHJvdXRlIGFscmVhZHkgYXQgdGhlIHNhbWUgbmFtZXNwYWNlIHNvIHdlIGNhbiBkb1xuICAgICAgLy8gdGhpbmdzIGxpa2UgdXNlIGJvdGggYC97cm91dGV9YCBhbmQgYC9yb3V0ZWAsIGlmIG5lZWRlZC5cbiAgICAgIGNvbnRleHRbcm91dGVOYW1lXSA9IF8uZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgLy8gTWFwIHRoZSB0YWdzIHRvIHRoZSBhcmd1bWVudHMgb3IgZGVmYXVsdCBhcmd1bWVudHMuXG4gICAgICAgIHZhciBwYXJ0cyA9IF8ubWFwKHRhZ3MsIGZ1bmN0aW9uICh0YWcsIGluZGV4KSB7XG4gICAgICAgICAgLy8gSW5qZWN0IGVudW0gcGFyYW1ldGVycyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBhdmFpbGFibGUgZW51bS5cbiAgICAgICAgICAvLyBUT0RPOiBXaGVuL2lmIHdlIGFkZCB2YWxpZGF0aW9uIGJhY2ssIGhhdmUgdGhlc2Ugcm91dGVzXG4gICAgICAgICAgLy8gYmUgZ2VuZXJhdGVkIGluc3RlYWQgb2YgdHlwZWQgb3V0LlxuICAgICAgICAgIGlmIChhcmdzW2luZGV4XSA9PSBudWxsICYmIHRhZy5lbnVtICYmIHRhZy5lbnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZy5lbnVtWzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVzZSBhbnkgcGFzc2VkIGluIGFyZ3VtZW50IC0gZXZlbiBpdCdzIGZhbHN5LlxuICAgICAgICAgIGlmIChpbmRleCBpbiBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhcmFtID0gdGVtcGxhdGVUYWdzW2luZGV4XS5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBpbmplY3RpbmcgdGhlIGZhbGxiYWNrIGNvbmZpZ3VyYXRpb24gdXJpIHBhcmFtZXRlci5cbiAgICAgICAgICByZXR1cm4gcm91dGVOb2Rlcy5jb25maWcgJiYgcm91dGVOb2Rlcy5jb25maWcudXJpUGFyYW1ldGVyc1twYXJhbV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoYW5nZSB0aGUgbGFzdCBwYXRoIGZyYWdtZW50IHRvIHRoZSBwcm9wZXIgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAgcm91dGVOb2Rlc1tyb3V0ZU5vZGVzLmxlbmd0aCAtIDFdID0gdGVtcGxhdGUocm91dGUsIHBhcnRzKTtcblxuICAgICAgICByZXR1cm4gbmV3Q29udGV4dChyb3V0ZU5vZGVzLCByZXNvdXJjZSwgaGFzTWVkaWFFeHRlbnNpb24pO1xuICAgICAgfSwgY29udGV4dFtyb3V0ZU5hbWVdKTtcblxuICAgICAgLy8gR2VuZXJhdGUgdGhlIGRlc2NyaXB0aW9uIG9iamVjdCBmb3IgaGVscGluZyB0b29sdGlwIGRpc3BsYXkuXG4gICAgICBjb250ZXh0W3JvdXRlTmFtZV1bREVTQ1JJUFRJT05fUFJPUEVSVFldID0ge1xuICAgICAgICAnIXR5cGUnOiAnZm4oJyArIF8ubWFwKHRhZ3MsIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgIHJldHVybiBwYXJhbS5kaXNwbGF5TmFtZSArIChwYXJhbS5yZXF1aXJlZCA/ICcnIDogJz8nKTtcbiAgICAgICAgfSkuam9pbignLCAnKSArICcpJyxcbiAgICAgICAgJyFhcmdzJzogXy5tYXAodGFncywgZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICchdHlwZSc6IHBhcmFtLnR5cGUsXG4gICAgICAgICAgICAnIWRvYyc6ICBwYXJhbS5kZXNjcmlwdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAnIWRvYyc6ICdEeW5hbWljYWxseSBpbmplY3QgdmFyaWFibGVzIGludG8gdGhlIHJlcXVlc3QgcGF0aC4nXG4gICAgICB9O1xuXG4gICAgICAvLyBHZW5lcmF0ZSB0aGUgcmV0dXJuIHByb3BlcnR5IGZvciBoZWxwaW5nIGF1dG9jb21wbGV0aW9uLlxuICAgICAgY29udGV4dFtyb3V0ZU5hbWVdW1JFVFVSTl9QUk9QRVJUWV0gPSBuZXdDb250ZXh0KFxuICAgICAgICByb3V0ZU5vZGVzLCByZXNvdXJjZSwgaGFzTWVkaWFFeHRlbnNpb25cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBjb250ZXh0W3JvdXRlTmFtZV07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHJvb3QgYC9gIHJlc291cmNlcy5cbiAgICBpZiAoIXJvdXRlTmFtZSkge1xuICAgICAgY29udGV4dCA9IG5ld0NvbnRleHQocm91dGVOb2RlcywgcmVzb3VyY2UsIGhhc01lZGlhRXh0ZW5zaW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dFtyb3V0ZU5hbWVdID0gbmV3Q29udGV4dChcbiAgICAgICAgcm91dGVOb2RlcywgcmVzb3VyY2UsIGhhc01lZGlhRXh0ZW5zaW9uLCBjb250ZXh0W3JvdXRlTmFtZV1cbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGV4dDtcbn07XG4vKiBqc2hpbnQgK1cwMDMgKi9cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgY2xpZW50IG9iamVjdCBmcm9tIGEgc2FuaXRpemVkIEFTVCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBhc3QgUGFzc2VkIHRocm91Z2ggYHNhbml0aXplQVNUYFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgZ2VuZXJhdGVDbGllbnQgPSBmdW5jdGlvbiAoYXN0LCBjb25maWcpIHtcbiAgLy8gR2VuZXJhdGUgdGhlIGJhc2UgdXJpIHBhcmFtZXRlcnMgYW5kIGRlZmF1bHRzLlxuICB2YXIgYmFzZVVyaVBhcmFtZXRlcnMgPSBfLmV4dGVuZChcbiAgICB7fSwgXy5waWNrKGFzdCwgJ3ZlcnNpb24nKSwgY29uZmlnLmJhc2VVcmlQYXJhbWV0ZXJzXG4gICk7XG5cbiAgLy8gR2VuZXJhdGUgdGhlIHJvb3Qgbm9kZSBhcnJheS4gU2V0IHByb3BlcnRpZXMgZGlyZWN0bHkgb24gdGhpcyBhcnJheSB0byBiZVxuICAvLyBjb3BpZWQgdG8gdGhlIG5leHQgZXhlY3V0aW9uIHBhcnQuIFdlIGhhdmUgYSBnbG9iYWwgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgLy8gd2hpY2ggY2FuIGJlIGFsdGVyZWQgZXh0ZXJuYWxseSBhdCBhbnkgcG9pbnQsIGFzIHdlbGwgYXMgd2hlbiB3ZSBmaW5hbGx5XG4gIC8vIG1ha2UgYSByZXF1ZXN0LiBGb3IgdGhpcyByZWFzb24sIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgdXNlIG9iamVjdHMgd2hpY2hcbiAgLy8gYXJlIHBhc3NlZCBieSByZWZlcmVuY2UuXG4gIHZhciBub2RlcyA9IF8uZXh0ZW5kKFtdLCB7XG4gICAgY29uZmlnOiBfLmV4dGVuZCh7XG4gICAgICBiYXNlVXJpOiBhc3QuYmFzZVVyaVxuICAgIH0sIGNvbmZpZywge1xuICAgICAgYmFzZVVyaVBhcmFtZXRlcnM6IGJhc2VVcmlQYXJhbWV0ZXJzXG4gICAgfSksXG4gICAgY2xpZW50OiB7XG4gICAgICBzZWN1cmVkQnk6ICAgICAgICAgYXN0LnNlY3VyZWRCeSxcbiAgICAgIGF1dGhlbnRpY2F0aW9uOiAgICB7fSxcbiAgICAgIHNlY3VyaXR5U2NoZW1lczogICBhc3Quc2VjdXJpdHlTY2hlbWVzLFxuICAgICAgYmFzZVVyaVBhcmFtZXRlcnM6IGFzdC5iYXNlVXJpUGFyYW1ldGVyc1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIGJhc2VVcmkgc3RyaW5nIGlzIG1pc3NpbmcuXG4gIGlmICghXy5pc1N0cmluZyhub2Rlcy5jb25maWcuYmFzZVVyaSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJiYXNlVXJpXCIgc3RyaW5nIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJvb3QgY2xpZW50IGltcGxlbWVudGF0aW9uIGlzIHNpbXBseSBhIGZ1bmN0aW9uLiBUaGlzIGFsbG93cyB1cyB0b1xuICAgKiBlbnRlciBhIGN1c3RvbSBwYXRoIHRoYXQgbWF5IG5vdCBiZSBzdXBwb3J0ZWQgYnkgdGhlIERTTCBhbmQgcnVuIGFueVxuICAgKiBtZXRob2QgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IHdhcyBkZWZpbmVkIGluIHRoZSBzcGVjLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHZhciBjbGllbnQgPSBmdW5jdGlvbiAocGF0aCwgY29udGV4dCkge1xuICAgIHZhciByb3V0ZSA9IHRlbXBsYXRlKFxuICAgICAgcGF0aCB8fCAnJywgY29udGV4dCB8fCB7fVxuICAgICkucmVwbGFjZSgvXlxcLysvLCAnJykuc3BsaXQoJy8nKTtcblxuICAgIHJldHVybiBhdHRhY2hNZXRob2RzKF8uZXh0ZW5kKFtdLCBub2Rlcywgcm91dGUpLCB7fSwgYWxsSHR0cE1ldGhvZHMpO1xuICB9O1xuXG4gIGNsaWVudFtDT05GSUdfUFJPUEVSVFldICAgICAgPSBub2Rlcy5jb25maWc7XG4gIGNsaWVudFtDTElFTlRfUFJPUEVSVFldICAgICAgPSBub2Rlcy5jbGllbnQ7XG4gIGNsaWVudFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSBDTElFTlRfREVTQ1JJUFRJT047XG4gIGNsaWVudFtSRVRVUk5fUFJPUEVSVFldICAgICAgPSBhdHRhY2hNZXRob2RzKG5vZGVzLCB7fSwgYWxsSHR0cE1ldGhvZHMpO1xuXG4gIGF0dGFjaFJlc291cmNlcyhub2RlcywgY2xpZW50LCBhc3QucmVzb3VyY2VzKTtcblxuICByZXR1cm4gY2xpZW50O1xufTtcblxuLyoqXG4gKiBFeHBvcnRzIHRoZSBjbGllbnQgZ2VuZXJhdG9yLCB3aGljaCBhY2NlcHRzIHRoZSBBU1Qgb2YgYSBSQU1MIGRvY3VtZW50LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gRHluYW1pYyBvYmplY3QgZm9yIGNvbnN0cnVjdGluZyBBUEkgcmVxdWVzdHMgZnJvbSB0aGUgQVNULlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhc3QsIGNvbmZpZykge1xuICByZXR1cm4gZ2VuZXJhdGVDbGllbnQoc2FuaXRpemVBU1QoYXN0KSwgY29uZmlnKTtcbn07XG4iLCIvKiBnbG9iYWwgQXBwICovXG52YXIgXyA9IEFwcC5MaWJyYXJ5Ll87XG5cbi8qKlxuICogU2FuaXRpemUgdGhlIHNlY3VyZWQgYnkgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBzZWN1cmVkXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBzYW5pdGl6ZVNlY3VyZWRCeSA9IGZ1bmN0aW9uIChzZWN1cmVkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShzZWN1cmVkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNlY3VyZWRCeSA9IHt9O1xuXG4gIC8vIFNpbmNlIGBzZWN1cmVkQnlgIGNhbiBlaXRoZXIgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBhcnJheSBvZiBvYmplY3RzXG4gIC8vIHdpdGggb25seSBhIHNpbmdsZSBrZXksIHdlIG1lcmdlIGl0IGRvd24gdG8gYW4gb2JqZWN0LlxuICBfLmVhY2goc2VjdXJlZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIGBudWxsYCBhcnJheSB2YWx1ZXMsIHNob3VsZG4ndCBiZSB1c2VmdWwgdG8gbWUuXG4gICAgfVxuXG4gICAgaWYgKF8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc2VjdXJlZEJ5W3ZhbHVlXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF8uZXh0ZW5kKHNlY3VyZWRCeSwgdmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gc2VjdXJlZEJ5O1xufTtcblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgQVNUIGZyb20gdGhlIFJBTUwgcGFyc2VyIGludG8gc29tZXRoaW5nIGVhc2llciB0byB3b3JrIHdpdGguXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBhc3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXN0KSB7XG4gIC8vIENyZWF0ZSB0aGUgYmFzZSBzYW5pdGl6ZWQgYXN0IHdpdGggb25seSB0aGUgcHJvcGVydGllcyB3ZSB3YW50LlxuICB2YXIgc2FuaXRpemVkQXN0ID0gXy5waWNrKGFzdCwgW1xuICAgICd0aXRsZScsXG4gICAgJ3ZlcnNpb24nLFxuICAgICdiYXNlVXJpJyxcbiAgICAnYmFzZVVyaVBhcmFtZXRlcnMnXG4gIF0pO1xuXG4gIC8vIE1lcmdlIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QgdXNpbmcgYF8uZXh0ZW5kYCBhbmRcbiAgLy8gYGFwcGx5YCAoc2luY2UgYF8uZXh0ZW5kYCBhY2NlcHRzIHVubGltaXRlZCBudW1iZXIgb2YgYXJndW1lbnRzKS5cbiAgaWYgKGFzdC5zZWN1cml0eVNjaGVtZXMpIHtcbiAgICBzYW5pdGl6ZWRBc3Quc2VjdXJpdHlTY2hlbWVzID0gXy5leHRlbmQuYXBwbHkoXywgYXN0LnNlY3VyaXR5U2NoZW1lcyk7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBzZWN1cmVkIGJ5IHdoaWNoIGlzIGEgYml0IG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBleHRlbmRpbmcuXG4gIGlmIChhc3Quc2VjdXJlZEJ5KSB7XG4gICAgc2FuaXRpemVkQXN0LnNlY3VyZWRCeSA9IHNhbml0aXplU2VjdXJlZEJ5KGFzdC5zZWN1cmVkQnkpO1xuICB9XG5cbiAgLy8gUmVjdXJzZSB0aHJvdWdoIHRoZSByZXNvdXJjZXMgYW5kIG1vdmUgVVJJcyB0byBiZSB0aGUga2V5IG5hbWVzLlxuICBzYW5pdGl6ZWRBc3QucmVzb3VyY2VzID0gKGZ1bmN0aW9uIGZsYXR0ZW5SZXNvdXJjZXMgKHJlc291cmNlcykge1xuICAgIHZhciBtYXAgPSB7fTtcblxuICAgIC8vIFJlc291cmNlcyBhcmUgcHJvdmlkZWQgYXMgYW4gYXJyYXksIHdlJ2xsIG1vdmUgdGhlbSB0byBiZSBhbiBvYmplY3QuXG4gICAgXy5lYWNoKHJlc291cmNlcywgZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICB2YXIgc2FuaXRpemVkUmVzb3VyY2UgPSB7fTtcblxuICAgICAgLy8gTWV0aG9kcyBhcmUgaW1wbGVtZW50ZWQgYXMgYXJyYXlzIG9mIG9iamVjdHMgdG9vLCBidXQgbm90IHJlY3Vyc2l2ZWx5LlxuICAgICAgLy8gVE9ETzogSWYgdGhlIGVuZHBvaW50IGlzIHRoZSBmaW5hbCByb3V0ZSBhbmQgaGFzIG5vIG1ldGhvZHMsIGltcGxlbWVudFxuICAgICAgLy8gYmFja3RyYWNraW5nIGFuZCByZW1vdmUgYWNjZXNzIHRvIGl0IGZyb20gdGhlIEFTVC5cbiAgICAgIGlmIChyZXNvdXJjZS5tZXRob2RzKSB7XG4gICAgICAgIHNhbml0aXplZFJlc291cmNlLm1ldGhvZHMgPSBfLm9iamVjdChcbiAgICAgICAgICBfLnBsdWNrKHJlc291cmNlLm1ldGhvZHMsICdtZXRob2QnKSxcbiAgICAgICAgICBfLm1hcChyZXNvdXJjZS5tZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNhbml0aXplZCBtZXRob2QgYnkgaW5jbHVkaW5nIHRoZSBwcm9wZXJ0aWVzIHdlIHdhbnQuXG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkTWV0aG9kID0gXy5waWNrKG1ldGhvZCwgW1xuICAgICAgICAgICAgICAnbWV0aG9kJyxcbiAgICAgICAgICAgICAgJ2JvZHknLFxuICAgICAgICAgICAgICAnaGVhZGVycycsXG4gICAgICAgICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAgICdxdWVyeVBhcmFtZXRlcnMnXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgLy8gU2FuaXRpemUgdGhlIGBzZWN1cmVkQnlgIG1ldGhvZC5cbiAgICAgICAgICAgIGlmIChtZXRob2Quc2VjdXJlZEJ5KSB7XG4gICAgICAgICAgICAgIHNhbml0aXplZE1ldGhvZC5zZWN1cmVkQnkgPSBzYW5pdGl6ZVNlY3VyZWRCeShtZXRob2Quc2VjdXJlZEJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNhbml0aXplZE1ldGhvZDtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzb3VyY2UucmVzb3VyY2VzKSB7XG4gICAgICAgIHNhbml0aXplZFJlc291cmNlLnJlc291cmNlcyA9IGZsYXR0ZW5SZXNvdXJjZXMocmVzb3VyY2UucmVzb3VyY2VzKTtcbiAgICAgIH1cblxuICAgICAgKGZ1bmN0aW9uIGF0dGFjaFJlc291cmNlIChtYXAsIHNlZ21lbnRzKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIHBhcnQgICAgPSBtYXBbc2VnbWVudF0gPSBtYXBbc2VnbWVudF0gfHwge307XG5cbiAgICAgICAgLy8gQ3VycmVudGx5IG9uIHRoZSBsYXN0IHVybCBzZWdtZW50LCBlbWJlZCB0aGUgZnVsbCByZXNvdXJjZS5cbiAgICAgICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJ0ID0gbWFwW3NlZ21lbnRdID0gc2FuaXRpemVkUmVzb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdWxsIGFueSBwb3NzaWJsZSB0YWdzIG91dCBvZiB0aGUgcmVsYXRpdmUgdXJpIHBhcnQuXG4gICAgICAgIHZhciB0YWdzID0gXy5tYXAoc2VnbWVudC5tYXRjaCgvXFx7KFteXFx9XSspXFx9L2cpLCBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZy5zbGljZSgxLCAtMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBvbmx5IHRoZSB1c2VkIHRhZ3MgdG8gdGhlIGN1cnJlbnQgcmVzb3VyY2Ugc2VnbWVudC5cbiAgICAgICAgaWYgKHRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgcGFydC51cmlQYXJhbWV0ZXJzID0gXy5waWNrKHJlc291cmNlLnVyaVBhcmFtZXRlcnMsIHRhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHNlZ21lbnQgcGFydHMgbGVmdCwgcmVjdXJzaXZlbHkgZW1iZWQgcmVzb3VyY2VzLlxuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcGFydC5yZXNvdXJjZXMgPSBwYXJ0LnJlc291cmNlcyB8fCB7fTtcblxuICAgICAgICAgIHJldHVybiBhdHRhY2hSZXNvdXJjZShwYXJ0LnJlc291cmNlcywgc2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9KShtYXAsIHJlc291cmNlLnJlbGF0aXZlVXJpLnN1YnN0cigxKS5zcGxpdCgnLycpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXA7XG4gIH0pKGFzdC5yZXNvdXJjZXMpO1xuXG4gIHJldHVybiBzYW5pdGl6ZWRBc3Q7XG59O1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gPSBBcHAuTGlicmFyeS5fO1xuXG4vKipcbiAqIE1hdGNoIHJhbWwgdXJpIHBhcmFtZXRlcnMgaW4gYSB1cmkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFVSSV9QQVJBTV9SRUdFWFAgPSAve1tefV0rfS9nO1xuXG4vKipcbiAqIFNpbXBsZSBcInRlbXBsYXRlXCIgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCB0aGUgdXJpIHBhcmFtIHZhcmlhYmxlcy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgdGVtcGxhdGVcbiAqIEBwYXJhbSAgeyhPYmplY3R8QXJyYXkpfSBjb250ZXh0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcsIGNvbnRleHQpIHtcbiAgY29udGV4dCA9IGNvbnRleHQgfHwge307XG5cbiAgLy8gTm8gdXJpIHN0cmluZyBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gIGlmIChzdHJpbmcgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIGNvbnRleHQgaXMgYW4gYXJyYXksIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZSByZXBsYWNlbWVudHMgaW50b1xuICAvLyBpbmRleCBiYXNlZCBwb3NpdGlvbnMgZm9yIHRoZSB1cmkgdGVtcGxhdGUgcGFyc2VyLlxuICBpZiAoXy5pc0FycmF5KGNvbnRleHQpKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShVUklfUEFSQU1fUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRleHRbaW5kZXgrK10gfHwgJycpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKFVSSV9QQVJBTV9SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoY29udGV4dFttYXRjaC5zbGljZSgxLCAtMSldIHx8ICcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgcmVwbGFjZW1lbnQgcmVnZXhwLlxuICovXG5leHBvcnRzLlJFR0VYUCA9IFVSSV9QQVJBTV9SRUdFWFA7XG4iLCIvKiBnbG9iYWwgQXBwICovXG52YXIgXyAgICAgICAgICAgICAgID0gQXBwLl87XG52YXIgcmFtbFBhcnNlciAgICAgID0gcmVxdWlyZSgncmFtbC1wYXJzZXInKTtcbnZhciBhdXRoZW50aWNhdGUgICAgPSByZXF1aXJlKCcuL2F1dGhlbnRpY2F0ZScpO1xudmFyIGNsaWVudEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vY2xpZW50LWdlbmVyYXRvcicpO1xudmFyIGZyb21QYXRoICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2xpYi9mcm9tLXBhdGgnKTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBoZWxwZXJzLlxuICovXG5yZXF1aXJlKCcuL2luamVjdC1hcGkta2V5cycpO1xucmVxdWlyZSgnLi9pbnNlcnQtYXBpLWNsaWVudCcpO1xuXG4vKipcbiAqIFByb3ZpZGVkIGEgc3BlY2lhbCBkb2N1bWVudGF0aW9uIHByb3BlcnR5IGZvciBmdW5jdGlvbnN3IHdpdGggYW5vdGhlciBwbHVnaW4uXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xudmFyIERFU0NSSVBUSU9OX1BST1BFUlRZID0gJyFkZXNjcmlwdGlvbic7XG5cbi8qKlxuICogQ3VzdG9tIGZpbGUgcmVhZGVyIGZvciBSQU1MIHNwZWNzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIHVybFxuICogQHJldHVybiB7US5kZWZlcn1cbiAqL1xudmFyIGNyZWF0ZVJlYWRlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIG5ldyByYW1sUGFyc2VyLkZpbGVSZWFkZXIoZnVuY3Rpb24gKHVybCkge1xuICAgIHZhciBkZWZlcnJlZCA9IHRoaXMucS5kZWZlcigpO1xuXG4gICAgQXBwLm1pZGRsZXdhcmUudHJpZ2dlcignYWpheCcsIHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgcHJveHk6IGNvbmZpZy5wcm94eSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9yYW1sK3lhbWwsICovKidcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyLCB4aHIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5mbG9vcih4aHIuc3RhdHVzIC8gMTAwKSAhPT0gMikge1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcignUmVjZWl2ZWQgc3RhdHVzIGNvZGUgJyArIHhoci5zdGF0dXMgKyAnIGxvYWRpbmcgJyArIHVybClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBBcGkgb2JqZWN0IGlzIHVzZWQgaW4gdGhlIGV4ZWN1dGlvbiBjb250ZXh0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBBUEkgPSB7fTtcblxuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3IgbG9hZGluZyBSQU1MIGRvY3VtZW50cyBhbmQgcmV0dXJuIEFQSSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIHVyaVxuICogQHBhcmFtIHtPYmplY3R9ICAgW2NvbmZpZ11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xuQVBJLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIChuYW1lLCB1cmksIGNvbmZpZywgZG9uZSkge1xuICBpZiAoIV8uaXNTdHJpbmcobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGUgYSBuYW1lIGZvciB0aGUgZ2VuZXJhdGVkIGNsaWVudCcpO1xuICB9XG5cbiAgaWYgKCFfLmlzU3RyaW5nKHVyaSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGUgYSBVUkwgZm9yIHRoZSAnICsgbmFtZSArICcgUkFNTCBkb2N1bWVudCcpO1xuICB9XG5cbiAgLy8gQWxsb3cgdGhlIGNvbmZpZyBvYmplY3QgdG8gYmUgc2tpcHBlZC5cbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkb25lICAgPSBhcmd1bWVudHNbMl07XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBBcHAuX2V4ZWN1dGVDb250ZXh0LnRpbWVvdXQoSW5maW5pdHkpO1xuICBkb25lICAgPSBkb25lICAgfHwgQXBwLl9leGVjdXRlQ29udGV4dC5hc3luYygpO1xuICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuZCBhdHRhY2ggdGhlIFJBTUwgY2xpZW50IGZyb20gdGhlIEFTVC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBhc3RcbiAgICovXG4gIHZhciBjcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGZyb21QYXRoKFxuICAgICAgICBBcHAuX2V4ZWN1dGVXaW5kb3csIG5hbWUuc3BsaXQoJy4nKSwgY2xpZW50R2VuZXJhdG9yKGFzdCwgY29uZmlnKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZG9uZShlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShcbiAgICAgIG51bGwsXG4gICAgICAnQ3JlYXRlIGEgbmV3IGNvZGUgY2VsbCBhbmQgdHlwZSBcIicgKyBuYW1lICsgJy5cIiB0byBleHBsb3JlIHRoaXMgQVBJLidcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYW51YWxseSBpbml0aWFsaXNlIHRoZSBmaXJzdCBhamF4IHJlcXVlc3QgdG8gc3VwcG9ydCBKU09OIHJlc3BvbnNlcy5cbiAgICovXG4gIHJldHVybiBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCdhamF4Jywge1xuICAgIHVybDogICB1cmksXG4gICAgcHJveHk6IGNvbmZpZy5wcm94eSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL3JhbWwreWFtbCwgYXBwbGljYXRpb24vanNvbiwgKi8qJ1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5mbG9vcih4aHIuc3RhdHVzIC8gMTAwKSAhPT0gMikge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdIVFRQICcgKyB4aHIuc3RhdHVzKSk7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBKU09OIHJlc3BvbnNlcy4gT3JpZ2luYWxseSB0aGlzIGNoZWNrZWQgdGhlIHJlc3BvbnNlIGNvbnRlbnRcbiAgICAvLyB0eXBlcywgZXRjLiBidXQgaXQncyBqdXN0IGFzIGVhc3kgdG8gYXR0ZW1wdCBwYXJzaW5nIGFzIEpTT04gYW5kIGlmIGl0XG4gICAgLy8gZmFpbHMgcGFzcyBpdCBvbnRvIHRoZSByYW1sIHBhcnNlci5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudChKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgLy8gUGFzcyBvdXIgdXJsIHRvIHRoZSBSQU1MIHBhcnNlciBmb3IgcHJvY2Vzc2luZyBhbmQgdHJhbnNmb3JtIHRoZSBwcm9taXNlXG4gICAgLy8gYmFjayBpbnRvIGEgY2FsbGJhY2sgZm9ybWF0LlxuICAgIHJldHVybiByYW1sUGFyc2VyLmxvYWQoeGhyLnJlc3BvbnNlVGV4dCwgdXJpLCB7XG4gICAgICByZWFkZXI6IGNyZWF0ZVJlYWRlcihjb25maWcpXG4gICAgfSkudGhlbihjcmVhdGVDbGllbnQsIGRvbmUpO1xuICB9KTtcblxufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvbiBvZiB0aGUgY3JlYXRlIGNsaWVudCBmdW5jdGlvbi5cbiAqL1xuQVBJLmNyZWF0ZUNsaWVudFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6ICdmbihhbGlhcywgdXJsLCBvcHRpb25zPywgY2I/KScsXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ3N0cmluZydcbiAgfSwge1xuICAgICchdHlwZSc6ICdzdHJpbmcnXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnb2JqZWN0JyxcbiAgICAnIWRvYyc6IFtcbiAgICAgICdJbml0aWFsaXplIHRoZSBjbGllbnQgd2l0aCBkZWZhdWx0IGNvbmZpZyBvcHRpb25zLiBWYWxpZCBvcHRpb25zOicsXG4gICAgICAnKiAqKnByb3h5Kio6IFNldCB0byBhIGN1c3RvbSBwcm94eSBvciBgZmFsc2VgIHRvIGRpc2FibGUgZW50aXJlbHknLFxuICAgICAgJyogKipib2R5Kio6IFNldCBhIGZhbGxiYWNrIHJlcXVlc3QgYm9keScsXG4gICAgICAnKiAqKnVyaVBhcmFtZXRlcnMqKjogU2V0IGZhbGxiYWNrIHVyaSBwYXJhbWV0ZXJzIHRvIGluamVjdCcsXG4gICAgICAnKiAqKmJhc2VVcmk6KiogT3ZlcnJpZGUgdGhlIGJhc2UgdXJpJyxcbiAgICAgICcqICoqYmFzZVVyaVBhcmFtZXRlcnMqKjogSW5qZWN0IGJhc2UgdXJpIHBhcmFtZXRlcnMgdG8gb3ZlcnJpZGUnLFxuICAgICAgJyogKipoZWFkZXJzKio6IFNldCBkZWZhdWx0IGhlYWRlcnMgdG8gc2VuZCB3aXRoIGV2ZXJ5IHJlcXVlc3QnLFxuICAgICAgJyogKipxdWVyeSoqOiBTZXQgYSBkZWZhdWx0IHF1ZXJ5IHN0cmluZyB0byBzZW5kIHdpdGggZXZlcnkgcmVxdWVzdCdcbiAgICBdLmpvaW4oJ1xcbicpXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnZm4oZXJyb3IsIGNsaWVudCknLFxuICAgICchZG9jJzogW1xuICAgICAgJ1Bhc3MgaW4gYSBjdXN0b20gY2FsbGJhY2sgdG8gcnVuIHdoZW4gdGhlIGNsaWVudCBoYXMgbG9hZGVkLidcbiAgICBdLmpvaW4oJ1xcbicpXG4gIH1dLFxuICAnIWRvYyc6IFtcbiAgICAnR2VuZXJhdGUgYW4gQVBJIGNsaWVudCBmcm9tIGEgUkFNTCBkb2N1bWVudCBhbmQgYWxpYXMgaXQgb24gdGhlIHdpbmRvdy4nXG4gIF0uam9pbignICcpXG59O1xuXG4vKipcbiAqIFNldCBhIGNvbmZpZ3VyYXRpb24gdmFsdWUgb24gYSBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xpZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gICBrZXlcbiAqIEBwYXJhbSB7Kn0gICAgICAgIHZhbHVlXG4gKi9cbkFQSS5zZXQgPSBmdW5jdGlvbiAoY2xpZW50LCBrZXksIHZhbHVlKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgZW5vdWdoIGFyZ3VtZW50cyBmb3IgYSBrZXkgYW5kIHZhbHVlLCBhc3N1bWUgd2UgaGF2ZVxuICAvLyBhIGZyZXNoIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICByZXR1cm4gXy5leHRlbmQoY2xpZW50WychY29uZmlnJ10sIGtleSk7XG4gIH1cblxuICByZXR1cm4gY2xpZW50WychY29uZmlnJ11ba2V5XSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBBUEkgY2xpZW50IGNvbmZpZ3VyYXRpb24gc2V0dGVyLlxuICovXG5BUEkuc2V0W0RFU0NSSVBUSU9OX1BST1BFUlRZXSA9IHtcbiAgJyF0eXBlJzogJ2ZuKGNsaWVudCwga2V5LCB2YWx1ZSknLFxuICAnIWFyZ3MnOiBbe1xuICAgICchdHlwZSc6ICdmbigpJyxcbiAgICAnIWRvYyc6ICdBIGZ1bmN0aW9uIGdlbmVyYXRlZCBieSBgQVBJLmNyZWF0ZUNsaWVudGAuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ3N0cmluZydcbiAgfV0sXG4gICchZG9jJzogJ1NldCBhIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG9mIGEgUkFNTCBBUEkgY2xpZW50Lidcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYSB2YWx1ZSBmcm9tIHRoZSBjbGllbnQgY29uZmlnIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2xpZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAga2V5XG4gKiBAcmV0dXJuIHsqfVxuICovXG5BUEkuZ2V0ID0gZnVuY3Rpb24gKGNsaWVudCwga2V5KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBjbGllbnRbJyFjb25maWcnXTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnRbJyFjb25maWcnXVtrZXldO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBBUEkgY2xpZW50IGNvbmZpZ3VyYXRpb24gZ2V0dGVyLlxuICovXG5BUEkuZ2V0W0RFU0NSSVBUSU9OX1BST1BFUlRZXSA9IHtcbiAgJyF0eXBlJzogJ2ZuKGNsaWVudCwga2V5KScsXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ2ZuKCknLFxuICAgICchZG9jJzogJ0EgZnVuY3Rpb24gZ2VuZXJhdGVkIGJ5IGBBUEkuY3JlYXRlQ2xpZW50YC4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnc3RyaW5nJ1xuICB9XSxcbiAgJyFkb2MnOiAnR2V0IGEgY29uZmlndXJhdGlvbiBvcHRpb24gZnJvbSBhIFJBTUwgQVBJIGNsaWVudC4nXG59O1xuXG4vKipcbiAqIFVuc2V0IGEga2V5IGZyb20gdGhlIGNsaWVudCBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjbGllbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gICBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkFQSS51bnNldCA9IGZ1bmN0aW9uIChjbGllbnQsIGtleSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICBfLmVhY2goY2xpZW50WychY29uZmlnJ10sIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGRlbGV0ZSBjbGllbnRbJyFjb25maWcnXVtrZXldO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBBUEkgY2xpZW50IGNvbmZpZ3VyYXRpb24gdW5zZXR0ZXIuXG4gKi9cbkFQSS51bnNldFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6ICdmbihjbGllbnQsIGtleSknLFxuICAnIWFyZ3MnOiBbe1xuICAgICchdHlwZSc6ICdmbigpJyxcbiAgICAnIWRvYyc6ICdBIGZ1bmN0aW9uIGdlbmVyYXRlZCBieSBgQVBJLmNyZWF0ZUNsaWVudGAuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ3N0cmluZydcbiAgfV0sXG4gICchZG9jJzogJ1Vuc2V0IGEgY29uZmlndXJhdGlvbiBvcHRpb24gZnJvbSBhIFJBTUwgQVBJIGNsaWVudC4nXG59O1xuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZSBhIFJBTUwgQVBJIGNsaWVudCBwYXNzaW5nIGFuIG9wdGlvbmFsIG1ldGhvZCBhbmQgYWNjb21wYW55aW5nXG4gKiBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGllbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5BUEkuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKGNsaWVudCwgbWV0aG9kLCBvcHRpb25zLCBkb25lKSB7XG4gIEFwcC5fZXhlY3V0ZUNvbnRleHQudGltZW91dCgxMCAqIDYwICogMTAwMCk7XG4gIGRvbmUgPSBkb25lIHx8IEFwcC5fZXhlY3V0ZUNvbnRleHQuYXN5bmMoKTtcblxuICB2YXIgY2xpZW50T3B0aW9uICAgID0gY2xpZW50WychY2xpZW50J107XG4gIHZhciBzZWN1cml0eVNjaGVtZXMgPSBjbGllbnRPcHRpb24uc2VjdXJpdHlTY2hlbWVzO1xuXG4gIC8vIEV4dGVuZCBwYXNzZWQgaW4gb3B0aW9ucyB3aXRoIGdsb2JhbCBvcHRpb25zIChmb3IgYGJhc2VVcmlQYXJhbWV0ZXJzYCkuXG4gIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucywgY2xpZW50WychY29uZmlnJ10pO1xuXG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgaXMgdXNlZCB0byBoYW5kbGUgdGhlIHBlcnNpc3RlbmNlIG9mIGRhdGEgdG8gdGhlIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7RXJyb3J9ICAgIGVyclxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgc2NoZW1lXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gICB0b2tlbnNcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICB2YXIgY2IgPSBmdW5jdGlvbiAoZXJyLCBzY2hlbWUsIG9wdGlvbnMsIHRva2Vucykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgfVxuXG4gICAgLy8gQWxpYXMgb250byB0aGUgY2xpZW50IG9iamVjdCBmb3IgZnV0dXJlIHVzZS5cbiAgICBjbGllbnRPcHRpb24uYXV0aGVudGljYXRpb25bc2NoZW1lLnR5cGVdID0gXy5leHRlbmQoe30sIG9wdGlvbnMsIHRva2Vucyk7XG5cbiAgICAvLyBTZXQgcHJpdmF0ZSBmaWVsZHMgdG8gYXN0ZXJpc2tzIG9mIGFuIGFyYml0cmFyeSBsZW5ndGguXG4gICAgXy5lYWNoKHRva2VucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChhdXRoZW50aWNhdGUuU0VDUkVUX0ZJRUxEU1trZXldKSB7XG4gICAgICAgIHRva2Vuc1trZXldID0gbmV3IEFycmF5KE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyA1KSAqIDUpLmpvaW4oJyonKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkb25lKG51bGwsIHRva2Vucyk7XG4gIH07XG5cbiAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzZWN1cml0eVNjaGVtZXMsIG1ldGhvZCwgb3B0aW9ucywgY2IpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBBUEkgY2xpZW50IGF1dGhlbnRpY2F0b3IuXG4gKi9cbkFQSS5hdXRoZW50aWNhdGVbREVTQ1JJUFRJT05fUFJPUEVSVFldID0ge1xuICAnIXR5cGUnOiBbXG4gICAgJ2ZuKGNsaWVudCwgbWV0aG9kPywgb3B0aW9ucz8sIGNiPyknXG4gIF0uam9pbignJyksXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ2ZuKCknLFxuICAgICchZG9jJzogJ0EgZnVuY3Rpb24gZ2VuZXJhdGVkIGJ5IGBBUEkuY3JlYXRlQ2xpZW50YC4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnc3RyaW5nJyxcbiAgICAnIWRvYyc6ICdTZWxlY3QgYW4gYXV0aGVudGljYXRpb24gbWV0aG9kIGRlZmluZWQgaW4gdGhlIFJBTUwgZmlsZS4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnb2JqZWN0JyxcbiAgICAnIWRvYyc6ICdPdmVycmlkZSB0aGUgZGVmYXVsdCBzZWxlY3RlZCBhdXRoZW50aWNhdGlvbiBtZXRob2Qgb3B0aW9ucy4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnZm4oZXJyb3IsIHJlc3BvbnNlKSdcbiAgfV0sXG4gICchZG9jJzogW1xuICAgICdBdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gRm9yIHBvcHVsYXIgQVBJcywgd2UgcHJvdmlkZScsXG4gICAgJ2tleXMuIElmIHdlIG5lZWQgeW91ciBrZXlzIHdlIHdpbGwgcHJvbXB0IHlvdSB2aWEgYSBtb2RhbC4gTmV2ZXIgZW50ZXInLFxuICAgICdrZXlzIGRpcmVjdGx5IGludG8gYSBub3RlYm9vayB1bmxlc3MgeW91IGV4cGxpY2l0bHkgaW50ZW5kIHRvIHNoYXJlJyxcbiAgICAndGhlbS4gSWYgeW91IHdvdWxkIGxpa2UgdG8ga25vdyBtb3JlIGFib3V0IGF1dGhlbnRpY2F0aW5nJyxcbiAgICAnd2l0aCB0aGlzIEFQSSwgc2VlIFxcJ3NlY3VyaXR5U2NoZW1lLnNldHRpbmdzXFwnIGluIHRoZSBSQU1MIGZpbGUuJ1xuICBdLmpvaW4oJyAnKVxufTtcblxuLyoqXG4gKiBBbHRlciB0aGUgY29udGV4dCB0byBpbmNsdWRlIHRoZSBSQU1MIGNsaWVudCBnZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICovXG5leHBvcnRzWydzYW5kYm94OmNvbnRleHQnXSA9IGZ1bmN0aW9uIChjb250ZXh0LCBuZXh0KSB7XG4gIC8vIFRoaXMgaXMgZXh0cmVtZWx5IGphbmt5LCBidXQgaXMgcmVxdWlyZWQgZm9yIFNhZmFyaSA3LjAgd2hpY2ggc2VlbXMgdG9cbiAgLy8gYmUgaWdub3JpbmcgZGlyZWN0IHByb3BlcnR5IGFzc2lnbm1lbnRzIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucy5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRleHQsICdBUEknLCB7IHZhbHVlOiBBUEkgfSk7XG4gIHJldHVybiBuZXh0KCk7XG59O1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIGFwaUtleXMgPSB7fS5yYW1sQ2xpZW50O1xuXG4vKipcbiAqIENoZWNrIGFnYWluc3Qgb3VyIE9BdXRoIHRva2VucyBhbmQgaW5qZWN0IHRoZSB0b2tlbnMgd2UgaGF2ZSBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICovXG5BcHAubWlkZGxld2FyZS5yZWdpc3RlcigncmFtbENsaWVudDp0b2tlbicsIGZ1bmN0aW9uIChzY2hlbWUsIG5leHQsIGRvbmUpIHtcbiAgdmFyIGF1dGhVcmkgPSBzY2hlbWUuc2V0dGluZ3MuYXV0aG9yaXphdGlvblVyaTtcblxuICBpZiAoc2NoZW1lLnR5cGUgPT09ICdPQXV0aCAxLjAnICYmIGFwaUtleXMub2F1dGgxW2F1dGhVcmldKSB7XG4gICAgcmV0dXJuIGRvbmUobnVsbCwgYXBpS2V5cy5vYXV0aDFbYXV0aFVyaV0pO1xuICB9XG5cbiAgaWYgKHNjaGVtZS50eXBlID09PSAnT0F1dGggMi4wJyAmJiBhcGlLZXlzLm9hdXRoMlthdXRoVXJpXSkge1xuICAgIHJldHVybiBkb25lKG51bGwsIGFwaUtleXMub2F1dGgyW2F1dGhVcmldKTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KCk7XG59KTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfICAgICAgICAgID0gQXBwLkxpYnJhcnkuXztcbnZhciBxcyAgICAgICAgID0gQXBwLkxpYnJhcnkucXM7XG52YXIgZG9taWZ5ICAgICA9IEFwcC5MaWJyYXJ5LmRvbWlmeTtcbnZhciBCYWNrYm9uZSAgID0gQXBwLkxpYnJhcnkuQmFja2JvbmU7XG52YXIgY2hhbmdlQ2FzZSA9IEFwcC5MaWJyYXJ5LmNoYW5nZUNhc2U7XG5cbnZhciBCQVNFX1VSSSA9ICdodHRwczovL2FueXBvaW50Lm11bGVzb2Z0LmNvbS9hcGlwbGF0Zm9ybS9yZXBvc2l0b3J5L3YyLycgK1xuICAnb3JnYW5pemF0aW9ucy81MjU2MGQzZi1jMzdhLTQwOWQtOTg4Ny03OWUwYTlhOWVjZmYvcHVibGljL3BvcnRhbHMnO1xudmFyIElURU1TX1BFUl9QQUdFID0gMTA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFwaSBjbGllbnQgY2VsbCB0aGF0IGNhbiBsb2FkIHRoZSBzZWxlY3RlZCBhcGkgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtICB7Q2VsbH0gICAgIGNlbGxcbiAqIEBwYXJhbSAge1N0cmluZ30gICBpbnZva2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgY3JlYXRlQXBpQ2xpZW50Q2VsbCA9IGZ1bmN0aW9uIChjZWxsLCBpbnZva2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIGFwaSwgdmVyc2lvbikge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBBUEkgbmFtZSBpbnRvIGEgdmFyaWFibGUgZm9yIHVzZS5cbiAgICB2YXIgdmFyaWFibGUgPSBjaGFuZ2VDYXNlLmNhbWVsQ2FzZShhcGkubmFtZSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHZpZXcgd2l0aCBhcGkgY3JlYXRpb24gZGV0YWlscy5cbiAgICB2YXIgdmlldyA9IGNlbGwubm90ZWJvb2tbaW52b2tlICsgJ0NvZGVWaWV3J10oY2VsbC5lbCwgW1xuICAgICAgJy8vIFJlYWQgYWJvdXQgdGhlICcgKyBhcGkubmFtZSArICcgYXQgJyArIHZlcnNpb24ucG9ydGFsVXJsLFxuICAgICAgJ0FQSS5jcmVhdGVDbGllbnQoXFwnJyArIHZhcmlhYmxlICsgJ1xcJywgXFwnJyArIHZlcnNpb24ucmFtbFVybCArICdcXCcpOydcbiAgICBdLmpvaW4oJ1xcbicpKS5leGVjdXRlKCk7XG5cbiAgICBjZWxsLmZvY3VzKCk7XG5cbiAgICAvLyBUcmlnZ2VyIGEgcmFtbCBjbGllbnQgaW5zZXJ0aW9uIG1lc3NhZ2UuXG4gICAgQXBwLm1lc3NhZ2VzLnRyaWdnZXIoJ3JhbWxDbGllbnQ6aW5zZXJ0Jyk7XG5cbiAgICByZXR1cm4gdmlldztcbiAgfTtcbn07XG5cbi8qKlxuICogU2hvdyBSQU1MIGRlZmluaXRpb25zIHRvIHVzZXJzIGluIGEgbW9kYWwsIGFuZCB1cG9uIHNlbGVjdGlvbiBwYXNzIHRoZVxuICogc2VsZWN0ZWQgZGVmaW5pdGlvbiBiYWNrIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbnZhciBzZWxlY3RBUElEZWZpbml0aW9uID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgLy8gVHJpZ2dlciBtb2RhbCBkaXNwbGF5IG1lc3NhZ2VzLlxuICBBcHAubWVzc2FnZXMudHJpZ2dlcigncmFtbENsaWVudDptb2RhbCcpO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzZWFyY2ggc3BlY2lmaWNhdGlvbiBvYmplY3QsIHBhc3NlZCB0byB0aGUgbWlkZGxld2FyZSBsYXllci5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBzZWFyY2hTcGVjID0ge1xuICAgIG9mZnNldDogMCxcbiAgICBsaW1pdDogIElURU1TX1BFUl9QQUdFLFxuICAgIHF1ZXJ5OiAgJydcbiAgfTtcblxuICByZXR1cm4gQXBwLm1pZGRsZXdhcmUudHJpZ2dlcigndWk6bW9kYWwnLCB7XG4gICAgdGl0bGU6ICdJbnNlcnQgYW4gQVBJIENsaWVudCcsXG4gICAgY29udGVudDogZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHJldHVybiBkb25lKG51bGwsICc8ZGl2IGNsYXNzPVwibW9kYWwtaW5zdHJ1Y3Rpb25zXCI+JyArXG4gICAgICAgICdJbnNlcnQgYW4gQVBJIGNsaWVudCBmcm9tIGEgUkFNTCBzcGVjaWZpY2F0aW9uLiBBbiBBUEkgY2xpZW50IGlzICcgK1xuICAgICAgICAnYSBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGFuIEFQSSB0aGF0IHlvdSBjYW4gdXNlIHRvIGV4cGxvcmUgJyArXG4gICAgICAgICdhdmFpbGFibGUgZW5kcG9pbnRzIGFuZCB0aGVpciBwYXJhbWV0ZXJzLiAnICtcbiAgICAgICAgJzxhIGhyZWY9XCJodHRwOi8vcmFtbC5vcmcvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JyArXG4gICAgICAgICdMZWFybiBtb3JlIGFib3V0IFJBTUw8L2E+LicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xuICAgICAgICAnPGlucHV0IGNsYXNzPVwiaXRlbS1zZWFyY2hcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaFwiPicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiaXRlbXMtbG9hZGluZ1wiICcgK1xuICAgICAgICAnc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQtc2l6ZTogM2VtO1wiPicgK1xuICAgICAgICAnPGkgY2xhc3M9XCJpY29uLWFycm93cy1jdyBhbmltYXRlLXNwaW5cIj48L2k+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtcy1jb250YWluZXIgY2xlYXJmaXhcIj4nICtcbiAgICAgICAgJzx1bCBjbGFzcz1cIml0ZW1zLWxpc3RcIj48L3VsPicgK1xuICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0bi1zZWNvbmRhcnkgaXRlbXMtcHJldi1idG5cIiBzdHlsZT1cImZsb2F0OiBsZWZ0XCI+JyArXG4gICAgICAgICdQcmV2aW91czwvYnV0dG9uPicgK1xuICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0bi1zZWNvbmRhcnkgaXRlbXMtbmV4dC1idG5cIiBzdHlsZT1cImZsb2F0OiByaWdodFwiPicgK1xuICAgICAgICAnTmV4dDwvYnV0dG9uPicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8cCBjbGFzcz1cIml0ZW1zLXVuYXZhaWxhYmxlXCI+Tm8gbWF0Y2hpbmcgQVBJcyBmb3VuZC48L3A+J1xuICAgICAgKTtcbiAgICB9LFxuICAgIHNob3c6IGZ1bmN0aW9uIChtb2RhbCkge1xuICAgICAgdmFyIGl0ZW1zRWwgICAgICAgICAgICA9IG1vZGFsLmVsLnF1ZXJ5U2VsZWN0b3IoJy5pdGVtcy1jb250YWluZXInKTtcbiAgICAgIHZhciBpdGVtc0xpc3RFbCAgICAgICAgPSBpdGVtc0VsLnF1ZXJ5U2VsZWN0b3IoJy5pdGVtcy1saXN0Jyk7XG4gICAgICB2YXIgaXRlbXNMb2FkaW5nRWwgICAgID0gbW9kYWwuZWwucXVlcnlTZWxlY3RvcignLml0ZW1zLWxvYWRpbmcnKTtcbiAgICAgIHZhciBpdGVtc05leHRCdG5FbCAgICAgPSBpdGVtc0VsLnF1ZXJ5U2VsZWN0b3IoJy5pdGVtcy1uZXh0LWJ0bicpO1xuICAgICAgdmFyIGl0ZW1zUHJldkJ0bkVsICAgICA9IGl0ZW1zRWwucXVlcnlTZWxlY3RvcignLml0ZW1zLXByZXYtYnRuJyk7XG4gICAgICB2YXIgaXRlbXNVbmF2YWlsYWJsZUVsID0gbW9kYWwuZWwucXVlcnlTZWxlY3RvcignLml0ZW1zLXVuYXZhaWxhYmxlJyk7XG4gICAgICB2YXIgc2VhcmNoSWQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogTG9hZCBhbGwgdGhlIEFQSSBkZWZpbml0aW9ucyBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhcyBhbiBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAgICAgKi9cbiAgICAgIHZhciBsb2FkQVBJRGVmaW5pdGlvbnMgPSBmdW5jdGlvbiAoc2VhcmNoLCBkb25lKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2VhcmNoSWQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIC8vIFRyYWNrIGN1cnJlbnQgc2VhcmNoIGluZGV4LlxuICAgICAgICBzZWFyY2hJZCA9IGN1cnJlbnRTZWFyY2hJZDtcblxuICAgICAgICAvLyBSZXNldCBlbGVtZW50IHN0YXRlcyBhbmQgc2hvdyBhIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgICAgICBpdGVtc0VsLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcbiAgICAgICAgaXRlbXNVbmF2YWlsYWJsZUVsLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcbiAgICAgICAgaXRlbXNMb2FkaW5nRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpO1xuXG4gICAgICAgIC8vIFNldCBib3RoIGJ1dHRvbnMgdG8gZGlzYWJsZWQgZm9yIG5vdy5cbiAgICAgICAgaXRlbXNOZXh0QnRuRWwuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICBpdGVtc1ByZXZCdG5FbC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgcmV0dXJuIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoXG4gICAgICAgICAgJ3JhbWxDbGllbnQ6c2VhcmNoJyxcbiAgICAgICAgICBzZWFyY2gsXG4gICAgICAgICAgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgLy8gU2tpcCB1cGRhdGVzIHdoZW4gdGhlIElEIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWFyY2hJZCAhPT0gc2VhcmNoSWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZG9uZShlcnIsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVuZGVyIHRoZSBzZWFyY2ggcmVzdWx0cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Vycm9yfSAgZXJyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0XG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVzdWx0LnRvdGFsXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSAgcmVzdWx0Lml0ZW1zXG4gICAgICAgKi9cbiAgICAgIHZhciB1cGRhdGVSZXN1bHRzID0gZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIC8vIEFsd2F5cyByZW1vdmUgdGhlIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgICAgICBpdGVtc0xvYWRpbmdFbC5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XG5cbiAgICAgICAgLy8gRW1wdHkgdGhlIGxpc3QgYmVmb3JlIHdlIHBvcHVsYXRlIGl0IGFnYWluLlxuICAgICAgICBpdGVtc0xpc3RFbC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0Lml0ZW1zKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zVW5hdmFpbGFibGVFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtc0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcblxuICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGlzIHBhc3QgdGhlIGZpcnN0IHBhZ2UsIGFsbG93IGdvaW5nIGJhY2suXG4gICAgICAgIGlmIChzZWFyY2hTcGVjLm9mZnNldCA+IDApIHtcbiAgICAgICAgICBpdGVtc1ByZXZCdG5FbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGNhbiBzdGlsbCBtb3ZlIGJlZm9yZSBoaXR0aW5nIHRoZSBsYXN0IHJlc3VsdCwgYWxsb3cuXG4gICAgICAgIGlmIChzZWFyY2hTcGVjLm9mZnNldCA8IHJlc3VsdC50b3RhbCAtIHNlYXJjaFNwZWMubGltaXQpIHtcbiAgICAgICAgICBpdGVtc05leHRCdG5FbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCB2ZXJzaW9uIGFuZCBhcHBlbmQgdG8gdGhlIGl0ZW0gbGlzdC5cbiAgICAgICAgXy5lYWNoKHJlc3VsdC5pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IF8uZXNjYXBlKGl0ZW0ubmFtZSk7XG5cbiAgICAgICAgICB2YXIgZWwgPSBkb21pZnkoW1xuICAgICAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWluZm8gY2xlYXJmaXhcIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWFjdGlvblwiPicsXG4gICAgICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tc21hbGwgaXRlbS1hZGRcIj5BZGQ8L2J1dHRvbj4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cIml0ZW0tbGlua1wiPkFsbCB2ZXJzaW9uczwvYT4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLW5hbWVcIj4nICsgbmFtZSArICc8L2Rpdj4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cIml0ZW0tdmVyc2lvbnNcIj4nLFxuICAgICAgICAgICAgXy5tYXAoaXRlbS52ZXJzaW9ucywgZnVuY3Rpb24gKHZlcnNpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lICAgICAgICA9IF8uZXNjYXBlKHZlcnNpb24ubmFtZSk7XG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IF8uZXNjYXBlKHZlcnNpb24uZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICB2YXIgcG9ydGFsVXJsICAgPSBfLmVzY2FwZSh2ZXJzaW9uLnBvcnRhbFVybCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIml0ZW0tdmVyc2lvbiBjbGVhcmZpeFwiPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWFjdGlvblwiPicsXG4gICAgICAgICAgICAgICAgJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtYWxsIGl0ZW0tYWRkXCIgJyArXG4gICAgICAgICAgICAgICAgJ2RhdGEtaW5kZXg9XCInICsgaW5kZXggKyAnXCI+JyxcbiAgICAgICAgICAgICAgICAnU2VsZWN0JyxcbiAgICAgICAgICAgICAgICAnPC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIicgKyBwb3J0YWxVcmwgKyAnXCIgY2xhc3M9XCJpdGVtLWxpbmsgJyArXG4gICAgICAgICAgICAgICAgJ2l0ZW0tcmVhZC1tb3JlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UmVhZCBtb3JlPC9hPicsXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLW5hbWVcIj4nLFxuICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImhpbnQtLXRvcFwiIGRhdGEtaGludD1cIicgKyBkZXNjcmlwdGlvbiArICdcIj4nLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nLFxuICAgICAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgJzwvbGk+J1xuICAgICAgICAgIF0uam9pbignXFxuJykpO1xuXG4gICAgICAgICAgaXRlbXNMaXN0RWwuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgICAgICAgLy8gV2hlbiB0aGUgZWxlbWVudCBpcyBjbGlja2VkLCByZW5kZXIgdGhlIGNvZGUgY2VsbC5cbiAgICAgICAgICBCYWNrYm9uZS4kKGVsKVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHJlYWQgbW9yZSBsaW5rIGlzIGNsaWNrZWQuXG4gICAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2l0ZW0tcmVhZC1tb3JlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQcmV2ZW50IGZvbGxvd2luZyBvZiBsaW5rcy5cbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgIHZhciBtZXRob2QgPSAnYWRkJztcblxuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGF0dHJpYnV0ZSBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2l0ZW0tdmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlbW92ZSc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlbC5jbGFzc0xpc3RbbWV0aG9kXSgnaXRlbS12aXNpYmxlJyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsICcuaXRlbS1hZGQnLCBmdW5jdGlvbiAoZSwgZWwpIHtcbiAgICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRvIHRoZSBjbGlja2VkIEFQSSB2ZXJzaW9uLCBvciBcImxhdGVzdFwiLlxuICAgICAgICAgICAgICB2YXIgdmVyc2lvbiA9IGl0ZW0udmVyc2lvbnNbZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JykgfHwgMF07XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgaXRlbSwgdmVyc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBCYWNrYm9uZS4kKG1vZGFsLmVsKVxuICAgICAgICAub24oJ2NsaWNrJywgJy5pdGVtcy1uZXh0LWJ0bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZEFQSURlZmluaXRpb25zKF8uZXh0ZW5kKHNlYXJjaFNwZWMsIHtcbiAgICAgICAgICAgIG9mZnNldDogc2VhcmNoU3BlYy5vZmZzZXQgKyBJVEVNU19QRVJfUEFHRVxuICAgICAgICAgIH0pLCB1cGRhdGVSZXN1bHRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdjbGljaycsICcuaXRlbXMtcHJldi1idG4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRBUElEZWZpbml0aW9ucyhfLmV4dGVuZChzZWFyY2hTcGVjLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHNlYXJjaFNwZWMub2Zmc2V0IC0gSVRFTVNfUEVSX1BBR0VcbiAgICAgICAgICB9KSwgdXBkYXRlUmVzdWx0cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbigna2V5dXAnLCAnLml0ZW0tc2VhcmNoJywgXy50aHJvdHRsZShmdW5jdGlvbiAoZSwgZWwpIHtcbiAgICAgICAgICAvLyBBdm9pZCB1cGRhdGluZyB3aGVuIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgICAgICBpZiAoc2VhcmNoU3BlYy5xdWVyeSA9PT0gZWwudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbG9hZEFQSURlZmluaXRpb25zKF8uZXh0ZW5kKHNlYXJjaFNwZWMsIHtcbiAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgIHF1ZXJ5OiAgZWwudmFsdWVcbiAgICAgICAgICB9KSwgdXBkYXRlUmVzdWx0cyk7XG4gICAgICAgIH0sIDcwMCkpO1xuXG4gICAgICByZXR1cm4gbG9hZEFQSURlZmluaXRpb25zKHNlYXJjaFNwZWMsIHVwZGF0ZVJlc3VsdHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSBuZXcgY29kZSBjZWxsIGFib3ZlIHdpdGggYSBSQU1MIEFQSSBjbGllbnQgYW5kIGV4ZWN1dGVzIGl0LlxuICovXG5BcHAuVmlldy5FZGl0b3JDZWxsLnByb3RvdHlwZS5uZXdSQU1MQWJvdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzZWxlY3RBUElEZWZpbml0aW9uKGNyZWF0ZUFwaUNsaWVudENlbGwodGhpcywgJ3ByZXBlbmQnKSk7XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSBuZXcgY29kZSBjZWxsIGJlbG93IHdpdGggYSBSQU1MIEFQSSBjbGllbnQgYW5kIGV4ZWN1dGVzIGl0LlxuICovXG5BcHAuVmlldy5FZGl0b3JDZWxsLnByb3RvdHlwZS5uZXdSQU1MQmVsb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzZWxlY3RBUElEZWZpbml0aW9uKGNyZWF0ZUFwaUNsaWVudENlbGwodGhpcywgJ2FwcGVuZCcpKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0IGEgUkFNTCBkb2N1bWVudCBieSB1c2luZyB0aGUgY2VsbCBib3JkZXIgYnV0dG9ucy5cbiAqL1xuQXBwLlZpZXcuQ2VsbEJ1dHRvbnMuY29udHJvbHMucHVzaCh7XG4gIGxhYmVsOiAgICdJbnNlcnQgQVBJIENsaWVudCcsXG4gIGNvbW1hbmQ6ICduZXdSQU1MJ1xufSk7XG5cbi8qKlxuICogSW5zZXJ0IGEgUkFNTCBkb2N1bWVudCBieSB1c2luZyB0aGUgY2VsbCBtZW51IGJ1dHRvbnMuXG4gKi9cbkFwcC5WaWV3LkNvZGVDZWxsLnByb3RvdHlwZS5jZWxsQ29udHJvbHMucHVzaCh7XG4gIGxhYmVsOiAgICdJbnNlcnQgQVBJIENsaWVudCcsXG4gIGNvbW1hbmQ6ICduZXdSQU1MQmVsb3cnXG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgYmFzaWMgcmFtbCBjbGllbnQgc2VhcmNoIG1pZGRsZXdhcmUuXG4gKi9cbkFwcC5taWRkbGV3YXJlLnJlZ2lzdGVyKCdyYW1sQ2xpZW50OnNlYXJjaCcsIGZ1bmN0aW9uIChzZWFyY2gsIG5leHQsIGRvbmUpIHtcbiAgdmFyIHVybCA9IEJBU0VfVVJJICsgJz8nICsgcXMuc3RyaW5naWZ5KHtcbiAgICBzb3J0OiAgICAgICduYW1lJyxcbiAgICBhc2NlbmRpbmc6IHRydWUsXG4gICAgbGltaXQ6ICAgICBzZWFyY2gubGltaXQsXG4gICAgb2Zmc2V0OiAgICBzZWFyY2gub2Zmc2V0LFxuICAgIHF1ZXJ5OiAgICAgc2VhcmNoLnF1ZXJ5XG4gIH0pO1xuXG4gIHJldHVybiBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCdhamF4Jywge1xuICAgIHVybDogdXJsXG4gIH0sIGZ1bmN0aW9uIChlcnIsIHhocikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIGRhdGEgPSB7fTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGRvbmUoZSk7XG4gICAgfVxuXG4gICAgZGF0YS50b3RhbCA9IHJlc3VsdC50b3RhbDtcblxuICAgIGRhdGEuaXRlbXMgPSByZXN1bHQuYXBpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgdmVyc2lvbnM6IGl0ZW0udmVyc2lvbnMubWFwKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHZlcnNpb24ubmFtZSxcbiAgICAgICAgICAgIHBvcnRhbFVybDogJ2h0dHBzOi8vYW55cG9pbnQubXVsZXNvZnQuY29tL2FwaXBsYXRmb3JtL3BvcHVsYXIvIycgK1xuICAgICAgICAgICAgICAnL3BvcnRhbHMvb3JnYW5pemF0aW9ucy8nICsgdmVyc2lvbi5vcmdhbml6YXRpb25JZCArICcvYXBpcy8nICtcbiAgICAgICAgICAgICAgdmVyc2lvbi5hcGlJZCArICcvdmVyc2lvbnMvJyArIHZlcnNpb24uaWQsXG4gICAgICAgICAgICByYW1sVXJsOiAnaHR0cHM6Ly9hbnlwb2ludC5tdWxlc29mdC5jb20vYXBpcGxhdGZvcm0vcmVwb3NpdG9yeS92MicgK1xuICAgICAgICAgICAgICAnL29yZ2FuaXphdGlvbnMvJyArIHZlcnNpb24ub3JnYW5pemF0aW9uSWQgKyAnL3B1YmxpYy9hcGlzLycgK1xuICAgICAgICAgICAgICB2ZXJzaW9uLmFwaUlkICsgJy92ZXJzaW9ucy8nICsgdmVyc2lvbi5pZCArICcvZmlsZXMvcm9vdCcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdmVyc2lvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQ6IHZlcnNpb24uZGVwcmVjYXRlZCxcbiAgICAgICAgICAgIHRhZ3M6IHZlcnNpb24udGFnc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRvbmUobnVsbCwgZGF0YSk7XG4gIH0pO1xufSk7XG4iXX0=
(59)
});
